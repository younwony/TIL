# CDN (Content Delivery Network)

**난이도: [4] 심화**

> 전 세계에 분산된 엣지 서버를 통해 콘텐츠를 사용자와 가까운 위치에서 전달하여 속도와 안정성을 향상시키는 네트워크

## 왜 알아야 하는가?

- **글로벌 서비스 필수**: 전 세계 사용자에게 빠른 콘텐츠 전달을 위해 CDN은 선택이 아닌 필수
- **비용 절감**: 원본 서버 대역폭 비용을 90% 이상 절감 가능
- **성능 최적화**: 레이턴시 감소로 사용자 경험 향상 및 전환율 증가
- **보안 강화**: DDoS 방어와 WAF 기능으로 서비스 안정성 확보
- **실무 필수 지식**: 정적 리소스 배포, 동영상 스트리밍, API 캐싱 등 다양한 시나리오에서 활용

## 핵심 개념

- CDN은 원본 서버의 콘텐츠를 전 세계 엣지 서버에 캐싱하여 사용자와 가까운 곳에서 제공
- 지리적 거리 단축으로 레이턴시 감소, 원본 서버 부하 분산, DDoS 방어 효과
- 엣지 서버: 사용자와 가까운 위치에 배치된 캐시 서버 (PoP: Point of Presence)
- 캐싱 전략: Push vs Pull, TTL 설정, Cache-Control 헤더 활용
- 사용 사례: 정적 파일 (이미지, CSS, JS), 동영상 스트리밍, API 응답 캐싱

## 쉽게 이해하기

**CDN은 편의점 체인**에 비유할 수 있습니다.

본사 창고(원본 서버)가 서울에 있고, 고객이 부산에 산다면 매번 서울까지 가서 물건을 사와야 합니다. 왕복 10시간이 걸립니다. 하지만 부산 동네마다 편의점(엣지 서버)이 있다면? 집 앞 편의점에서 5분 만에 구매할 수 있습니다.

예를 들어, 넷플릭스가 서울에만 서버가 있다면 부산 사용자는 동영상을 볼 때마다 서울에서 데이터를 받아야 합니다. 하지만 부산에 CDN 엣지 서버가 있으면, 같은 영화를 보는 첫 번째 사용자가 데이터를 가져온 후 엣지 서버에 캐싱됩니다. 두 번째 사용자부터는 부산 엣지 서버에서 바로 받으므로 빠르고, 서울 서버는 부하가 줄어듭니다.

편의점(엣지 서버)의 재고(캐시)가 떨어지거나 유통기한(TTL)이 지나면? 본사 창고(원본 서버)에서 다시 가져옵니다.

## 상세 설명

### CDN의 필요성

**문제 1: 지리적 거리로 인한 레이턴시**

```
사용자 (뉴욕) ------ 200ms ------> 원본 서버 (서울)
사용자 (뉴욕) ------ 10ms -------> 엣지 서버 (뉴욕)
```

빛의 속도로도 서울-뉴욕 간 물리적 거리로 인해 100ms 이상 소요됩니다. 여기에 라우터 홉, 네트워크 혼잡 등을 고려하면 200-300ms까지 증가합니다. CDN 엣지 서버를 뉴욕에 두면 10-20ms로 단축됩니다.

**왜 레이턴시가 중요한가?**

- 구글 연구: 페이지 로딩 속도가 100ms 느려지면 전환율 1% 감소
- 아마존 연구: 100ms 지연 시 매출 1% 감소
- 사용자 경험: 100ms 이하는 즉각적으로 느껴지지만, 300ms 이상은 느리게 느껴짐

**문제 2: 원본 서버 부하**

100만 명이 같은 이미지를 요청하면 원본 서버는 100만 번 전송해야 합니다. CDN을 사용하면:
- 엣지 서버가 1번만 원본에서 가져옴
- 나머지 99만 9999번은 엣지에서 제공
- 원본 서버 대역폭 사용량 1/100만로 감소

**문제 3: 단일 장애점 (SPOF)**

원본 서버가 1대뿐이면 서버 장애 또는 네트워크 장애 시 서비스 중단. CDN은 수백 개의 엣지 서버가 분산되어 있어, 일부 엣지 서버 장애에도 다른 엣지 서버로 자동 전환됩니다.

### 엣지 서버 (Edge Server)

**PoP (Point of Presence)**: CDN 제공자가 전 세계 주요 도시에 배치한 데이터센터

```
Cloudflare: 300+ 도시
AWS CloudFront: 400+ PoP
Akamai: 4000+ PoP
```

**왜 이렇게 많은 PoP가 필요한가?**

- 더 가까운 엣지 서버 = 더 낮은 레이턴시
- 지역별 인터넷 사업자(ISP)와 직접 연결하여 네트워크 홉 감소
- 특정 지역 트래픽 급증 시 분산 처리

**동작 방식**:
```
1. 사용자 (부산) → DNS 조회: cdn.example.com
2. DNS → 부산에 가장 가까운 엣지 서버 IP 반환
3. 사용자 → 부산 엣지 서버 요청
4. 엣지 서버에 캐시 있으면: 즉시 반환 (Cache Hit)
5. 엣지 서버에 캐시 없으면: 원본 서버에서 가져와서 캐싱 후 반환 (Cache Miss)
```

**Anycast DNS**: 같은 IP 주소를 여러 엣지 서버가 공유하고, 라우터가 가장 가까운 서버로 자동 전달. 사용자는 "어디에 연결되는지" 신경 쓸 필요 없이 항상 빠른 서버로 연결됩니다.

### 캐싱 전략

#### Pull (Origin Pull) vs Push

**Pull (일반적)**:
```
1. 사용자 → 엣지 서버: /image.png 요청
2. 엣지 서버: 캐시에 있나? → 없음
3. 엣지 서버 → 원본 서버: /image.png 요청
4. 원본 서버 → 엣지 서버: image.png 전달
5. 엣지 서버: 캐싱 + 사용자에게 전달
6. 다음 요청부터는 엣지에서 바로 제공
```

**장점**:
- 자동으로 캐싱됨 (설정 간단)
- 요청된 콘텐츠만 캐싱 (공간 효율적)

**단점**:
- 첫 요청은 느림 (Cache Miss)

**Push**:
```
1. 개발자 → CDN API: "이 파일들을 모든 엣지에 미리 배포해"
2. CDN → 모든 엣지 서버: 파일 배포
3. 사용자 요청 시: 항상 Cache Hit (빠름)
```

**장점**:
- 첫 요청도 빠름 (이미 캐싱됨)
- 대규모 이벤트 (예: 신제품 출시) 시 유용

**단점**:
- 수동 배포 필요
- 사용되지 않는 파일도 모든 엣지에 저장 (공간 낭비)

**언제 Push를 사용하나?**

- 전 세계 동시 접속이 예상되는 이벤트 (예: 월드컵, 대선, 신제품 발표)
- 파일 크기가 작고 개수가 적은 경우
- 첫 요청부터 빠른 속도가 중요한 경우

#### TTL (Time To Live)

**개념**: 캐시 유효 기간

```http
Cache-Control: max-age=3600  // 1시간 동안 캐싱
Cache-Control: max-age=86400 // 24시간 동안 캐싱
Cache-Control: no-cache      // 매번 원본 서버에 확인 (조건부 요청)
Cache-Control: no-store      // 캐싱 금지
```

**왜 TTL이 필요한가?**

만약 캐시가 영원히 유지되면:
- 원본 서버에서 파일을 수정해도 엣지는 옛날 버전 제공
- 사용자는 업데이트된 콘텐츠를 볼 수 없음

TTL이 지나면 엣지 서버는 원본 서버에 "파일 바뀌었어?"라고 확인합니다.

**조건부 요청 (Conditional Request)**:
```http
엣지 → 원본: If-Modified-Since: Wed, 21 Oct 2024 07:28:00 GMT
원본 → 엣지: 304 Not Modified (바뀌지 않았으니 그대로 써)
또는
원본 → 엣지: 200 OK + 새 콘텐츠 (바뀌었어, 이거 써)
```

**왜 304를 사용하나?**

콘텐츠가 안 바뀌었으면 본문 전송이 불필요합니다. 304는 헤더만 보내므로 대역폭을 절약할 수 있습니다. 10MB 이미지를 매번 전송하는 대신, 몇 백 바이트 헤더만 보내면 됩니다.

**TTL 설정 전략**:

| 콘텐츠 종류 | TTL | 이유 |
|-----------|-----|------|
| 로고, 폰트 | 1년 (31536000) | 거의 안 바뀜 |
| CSS, JS | 1일-1주 | 배포 시 파일명 변경 (예: app.v2.js) |
| HTML | 1분-1시간 | 자주 업데이트 |
| API 응답 | 1초-1분 | 실시간성 중요 |
| 사용자별 콘텐츠 | 캐싱 금지 | 개인화 데이터 |

**Cache Busting (캐시 무효화)**:

파일이 바뀌었는데 TTL이 남아있으면? 파일명을 변경합니다.

```html
<!-- Before -->
<link rel="stylesheet" href="style.css">

<!-- After (파일 수정 시) -->
<link rel="stylesheet" href="style.v2.css">
또는
<link rel="stylesheet" href="style.css?v=20241218">
```

파일명이 바뀌면 CDN은 새 파일로 인식하여 원본에서 다시 가져옵니다.

#### Cache-Control 헤더 상세

```http
Cache-Control: public, max-age=86400, must-revalidate
```

- **public**: 중간 프록시(CDN)도 캐싱 가능
- **private**: 브라우저만 캐싱 (CDN 캐싱 안 함), 사용자별 콘텐츠에 사용
- **max-age=N**: N초 동안 캐싱
- **s-maxage=N**: CDN용 TTL (브라우저 TTL과 별도)
- **must-revalidate**: TTL 만료 시 반드시 원본 서버에 확인
- **immutable**: 절대 안 바뀜 (브라우저가 조건부 요청도 안 보냄)

**예시**:
```http
Cache-Control: public, max-age=3600, s-maxage=86400, immutable
```
- 브라우저: 1시간 캐싱
- CDN: 24시간 캐싱
- 브라우저는 1시간 후 재요청하지만, CDN에서 바로 제공 (원본 서버 부하 없음)

### 캐싱 대상

**정적 콘텐츠 (적극 캐싱)**:
- 이미지, 동영상
- CSS, JavaScript
- 폰트, 아이콘
- PDF, ZIP 파일

**동적 콘텐츠 (조건부 캐싱)**:
- API 응답: 짧은 TTL로 캐싱 (예: 상품 목록 1분)
- HTML 페이지: 자주 바뀌면 캐싱 안 하거나 짧은 TTL

**캐싱 금지**:
- 사용자별 콘텐츠 (마이페이지, 장바구니)
- 민감한 정보 (개인정보, 결제 정보)
- 실시간 데이터 (주식 시세, 스포츠 점수)

**왜 동적 콘텐츠도 캐싱하나?**

API 응답도 동일한 요청이 반복되면 캐싱이 효과적입니다. 예를 들어:
- 상품 목록 API: 1분에 1만 명이 요청 → 1분 TTL로 캐싱하면 원본 서버는 1분에 1번만 처리
- 10,000번 → 1번으로 부하 감소

단, 사용자별로 다른 응답(예: 추천 상품)은 캐싱하면 안 됩니다.

### CDN의 추가 기능

#### 1. DDoS 방어

**CDN은 자연스럽게 DDoS 방어 효과**가 있습니다:
- 엣지 서버가 전 세계에 분산되어 트래픽 분산
- 악성 트래픽을 엣지에서 필터링 (원본 서버까지 도달 전 차단)
- WAF (Web Application Firewall) 기능 제공

**왜 CDN이 DDoS 방어에 효과적인가?**

DDoS는 대량 트래픽으로 서버를 마비시키는 공격입니다. CDN 없이 원본 서버만 있으면:
- 1Gbps 대역폭인 서버에 10Gbps 공격 → 서버 다운

CDN이 있으면:
- 공격 트래픽이 수백 개 엣지 서버로 분산
- 엣지 서버가 악성 요청 필터링 (예: 동일 IP 초당 100건 이상 차단)
- 정상 요청만 원본 서버로 전달

#### 2. 압축 (Compression)

엣지 서버에서 자동으로 Gzip, Brotli 압축:
```
원본 파일: app.js (500KB)
압축 후: app.js.gz (100KB)
→ 대역폭 80% 절약, 로딩 속도 5배 향상
```

#### 3. 이미지 최적화

실시간 이미지 변환:
```
원본: image.png (5MB, 4000x3000)
요청: image.png?w=800&h=600&format=webp
→ 엣지 서버가 자동 리사이징 + WebP 변환 (200KB)
```

**왜 이렇게 하나?**

모바일에서 4000x3000 원본을 받으면:
- 불필요한 대역폭 낭비
- 느린 로딩 속도
- 데이터 요금 증가

엣지 서버가 디바이스에 맞게 최적화된 이미지를 제공하면 효율적입니다.

## 동작 원리

### 전체 흐름

```
1. 사용자 (도쿄) → DNS 조회: cdn.example.com
   ↓
2. DNS → GeoDNS: "사용자가 도쿄에 있네? 도쿄 엣지 서버 IP 반환"
   ↓
3. 사용자 → 도쿄 엣지 서버: GET /image.png
   ↓
4. 엣지 서버: 캐시 확인
   - Cache Hit → 즉시 반환 (10ms)
   - Cache Miss → 원본 서버에 요청 (100ms + 원본 처리 시간)
   ↓
5. 엣지 서버 → 원본 서버: GET /image.png (Cache Miss인 경우)
   ↓
6. 원본 서버 → 엣지 서버: image.png 전달
   ↓
7. 엣지 서버: 캐싱 (TTL만큼 저장) + 사용자에게 전달
   ↓
8. 다음 사용자 (도쿄) → 도쿄 엣지 서버: GET /image.png
   → Cache Hit → 즉시 반환 (10ms)
```

### Cache Hierarchy (캐시 계층)

```
Browser Cache (브라우저)
     ↓
Edge Server (엣지 서버)
     ↓
Origin Shield (오리진 실드, 선택)
     ↓
Origin Server (원본 서버)
```

**Origin Shield**: 원본 서버 앞에 추가 캐시 계층

**왜 Origin Shield가 필요한가?**

엣지 서버가 100개이고 모두 Cache Miss가 발생하면:
- 100개 엣지 → 원본 서버에 동시 요청
- 원본 서버는 같은 파일을 100번 전송 (Thundering Herd 문제)

Origin Shield를 두면:
- 100개 엣지 → Origin Shield에 요청
- Origin Shield → 원본 서버에 1번만 요청
- Origin Shield → 100개 엣지로 전달
- 원본 서버 부하 99% 감소

## 트레이드오프

| 장점 | 단점 |
|------|------|
| 빠른 콘텐츠 전달 (레이턴시 감소) | 비용 발생 (트래픽 요금) |
| 원본 서버 부하 감소 | 캐시 일관성 문제 (TTL 관리 복잡) |
| 고가용성 (분산 구조로 SPOF 제거) | 첫 요청은 느림 (Cache Miss) |
| DDoS 방어 효과 | 실시간 업데이트가 필요한 콘텐츠는 부적합 |
| 대역폭 비용 절감 | 사용자별 개인화 콘텐츠는 캐싱 불가 |

**비용 트레이드오프**:
- CDN 비용 vs 원본 서버 대역폭 비용
- 대부분의 경우 CDN이 저렴 (캐싱으로 원본 서버 트래픽 90% 이상 감소)
- 특히 글로벌 서비스는 CDN 필수 (각 리전마다 서버 구축하는 것보다 훨씬 저렴)

## 사용 사례

### 1. 이미지 호스팅 (Static Assets)

**문제**: 블로그에 이미지가 1000장, 각 100KB → 총 100MB
- 월 방문자 10만 명 × 100MB = 10TB 대역폭
- 원본 서버 대역폭 비용: $1000/월

**CDN 사용 후**:
- 캐시 히트율 95% → 원본 트래픽 0.5TB
- 원본 서버 비용: $50/월
- CDN 비용: $100/월
- 총 비용: $150/월 (85% 절감)

### 2. 동영상 스트리밍

**문제**: 1GB 영화를 100만 명이 시청
- 원본 서버: 1GB × 100만 = 1PB 전송 (불가능)

**CDN 사용**:
- 각 엣지 서버가 1번만 원본에서 가져옴
- 100개 엣지 × 1GB = 100GB만 원본 전송
- 99.99% 트래픽 감소

**추가 효과**:
- Adaptive Bitrate Streaming: 네트워크 속도에 맞게 화질 자동 조절
- 엣지 서버에서 처리하여 끊김 없는 재생

### 3. API 응답 캐싱

**예시**: 날씨 API
```http
GET /weather?city=Seoul
Cache-Control: public, max-age=300  // 5분 캐싱
```

**효과**:
- 5분에 1000명이 서울 날씨 조회
- CDN 없으면: 원본 서버 1000번 DB 조회
- CDN 있으면: 원본 서버 1번 DB 조회, 나머지 999번은 캐시에서 제공

**주의사항**:
- 사용자별 다른 응답은 캐싱 금지 (`Cache-Control: private`)
- 민감한 정보는 캐싱 금지 (`Cache-Control: no-store`)

### 4. 소프트웨어 배포

**예시**: npm, Docker Hub, GitHub Releases

**문제**: 인기 패키지가 초당 1000건 다운로드
- 원본 서버 대역폭 부족

**CDN 사용**:
- 전 세계 엣지에 캐싱
- 각 지역 사용자는 가까운 엣지에서 다운로드
- 원본 서버는 각 엣지당 1번만 전송

### 5. 이벤트 트래픽 대응

**예시**: 신제품 출시, 티켓 판매 오픈

**문제**: 평소 1000 RPS → 이벤트 시 10만 RPS
- 원본 서버 증설 필요 (비용 급증)

**CDN 사용**:
- Push 방식으로 정적 콘텐츠 미리 배포
- 동적 콘텐츠도 짧은 TTL로 캐싱
- 엣지 서버가 트래픽 분산하여 원본 서버 부하 최소화

## 면접 예상 질문

- Q: CDN이 왜 빠른가요?
  - A: CDN은 콘텐츠를 사용자와 지리적으로 가까운 엣지 서버에 캐싱하여 제공하기 때문에 빠릅니다. 예를 들어 뉴욕 사용자가 서울의 원본 서버에서 파일을 받으면 물리적 거리로 인해 200-300ms가 걸리지만, 뉴욕 엣지 서버에서 받으면 10-20ms로 단축됩니다. 또한 엣지 서버에 캐싱된 콘텐츠는 디스크나 메모리에서 바로 제공하므로 원본 서버의 데이터베이스 조회, 애플리케이션 처리 과정이 생략되어 응답 속도가 훨씬 빠릅니다. 추가로 엣지 서버가 Gzip 압축, 이미지 최적화를 자동으로 수행하여 전송 데이터 크기를 줄이는 것도 속도 향상에 기여합니다.

- Q: Pull 방식과 Push 방식의 차이는 무엇인가요?
  - A: Pull 방식은 사용자가 요청할 때 엣지 서버가 원본 서버에서 콘텐츠를 가져와 캐싱하는 방식입니다. 자동으로 동작하고 실제 요청된 콘텐츠만 캐싱하여 공간 효율적이지만, 첫 요청은 Cache Miss로 느립니다. Push 방식은 개발자가 CDN API를 통해 미리 모든 엣지 서버에 콘텐츠를 배포하는 방식입니다. 첫 요청부터 빠르고 대규모 이벤트 대비에 유용하지만, 수동 배포가 필요하고 사용되지 않는 콘텐츠도 저장되어 공간 낭비가 있습니다. 일반적으로는 Pull 방식을 사용하고, 전 세계 동시 접속이 예상되는 신제품 출시나 라이브 이벤트처럼 첫 요청부터 빠른 속도가 중요한 경우에만 Push 방식을 선택합니다.

- Q: TTL은 어떻게 설정해야 하나요?
  - A: TTL은 콘텐츠의 변경 빈도와 실시간성 요구사항을 고려하여 설정합니다. 거의 변경되지 않는 로고, 폰트, 라이브러리는 1년으로 길게 설정하여 캐시 히트율을 최대화합니다. CSS, JavaScript는 배포 시 파일명에 버전을 포함시키고 (예: app.v2.js) 1일-1주로 설정합니다. HTML은 자주 업데이트되므로 1분-1시간으로 짧게 설정하고, API 응답은 실시간성에 따라 1초-1분으로 설정합니다. 사용자별 콘텐츠나 민감한 정보는 Cache-Control: private 또는 no-store로 캐싱을 금지합니다. TTL이 너무 길면 콘텐츠 업데이트가 반영되지 않고, 너무 짧으면 캐시 히트율이 낮아져 원본 서버 부하가 증가하므로 균형을 맞춰야 합니다. 파일이 변경되었는데 TTL이 남아있다면 파일명을 변경하는 Cache Busting 기법을 사용합니다.

- Q: CDN은 정적 콘텐츠만 캐싱할 수 있나요?
  - A: 아닙니다. 동적 콘텐츠도 조건에 맞으면 캐싱할 수 있습니다. API 응답처럼 동일한 요청이 반복되는 경우, 짧은 TTL(1분)로 캐싱하면 효과적입니다. 예를 들어 상품 목록 API를 1분에 1만 명이 요청하면, 1분 TTL로 캐싱하여 원본 서버는 1분에 1번만 처리하면 됩니다. 하지만 사용자별로 다른 응답을 반환하는 개인화 콘텐츠(마이페이지, 추천 상품)는 Cache-Control: private로 브라우저만 캐싱하거나, Vary 헤더를 사용하여 사용자별로 별도 캐시 키를 만들어야 합니다. 또한 GraphQL API처럼 요청마다 쿼리가 다른 경우는 캐시 키 관리가 복잡하여 Edge Computing을 활용하거나 캐싱을 포기하는 것이 나을 수 있습니다. 결론적으로 CDN은 정적뿐 아니라 동적 콘텐츠도 캐싱 가능하지만, 콘텐츠 특성에 맞게 전략을 수립해야 합니다.

- Q: Origin Shield는 무엇이며 왜 필요한가요?
  - A: Origin Shield는 원본 서버 앞에 추가되는 중앙 캐시 계층으로, 여러 엣지 서버의 요청을 집약하여 원본 서버 부하를 줄입니다. 엣지 서버가 100개이고 모두 Cache Miss가 발생하면 100개 엣지가 동시에 원본 서버로 요청을 보내는 Thundering Herd 문제가 발생합니다. Origin Shield를 두면 100개 엣지는 Origin Shield로 요청하고, Origin Shield가 원본 서버에 1번만 요청한 후 100개 엣지로 전달하여 원본 서버 부하를 99% 감소시킵니다. 특히 대용량 파일이나 처리 비용이 높은 동적 콘텐츠의 경우 효과적입니다. 또한 Origin Shield는 원본 서버와 가까운 위치에 배치되어 Origin Shield와 원본 서버 간 레이턴시를 최소화합니다. 단, Origin Shield가 추가 홉이 되므로 엣지에서 Origin Shield까지의 레이턴시는 증가할 수 있지만, 원본 서버 보호 효과가 더 크기 때문에 대규모 트래픽 환경에서는 권장됩니다.

- Q: CDN을 사용할 때 주의해야 할 점은 무엇인가요?
  - A: 첫째, 캐시 일관성 문제를 고려해야 합니다. TTL이 긴 콘텐츠를 업데이트하면 엣지 서버에 오래된 버전이 남아있을 수 있으므로, 파일명에 버전을 포함하거나 CDN Purge API로 캐시를 수동 무효화해야 합니다. 둘째, 사용자별 개인화 콘텐츠는 캐싱하면 안 됩니다. Cache-Control: private로 설정하여 CDN이 캐싱하지 않도록 해야 합니다. 셋째, HTTPS를 사용할 때 인증서 설정이 필요합니다. CDN이 제공하는 인증서를 사용하거나, 커스텀 도메인에 자체 인증서를 업로드해야 합니다. 넷째, 민감한 정보가 캐싱되지 않도록 주의해야 합니다. Authorization 헤더가 있는 요청은 기본적으로 캐싱되지 않지만, 실수로 URL에 토큰을 포함하면 캐싱되어 보안 문제가 발생할 수 있습니다. 다섯째, 비용을 모니터링해야 합니다. 예상치 못한 트래픽 급증이나 DDoS 공격으로 CDN 비용이 폭증할 수 있으므로, 알림 설정과 비용 한도를 설정해야 합니다.

## 연관 문서

- [HTTP/HTTPS](./http-https.md) - CDN은 HTTP 캐싱 메커니즘을 기반으로 동작
- [DNS](./dns.md) - GeoDNS를 통해 가장 가까운 엣지 서버로 라우팅
- [Load Balancing](./load-balancing.md) - CDN 엣지 서버 간 트래픽 분산
- [TCP/IP](./tcp-ip.md) - 네트워크 레이턴시와 CDN 성능 최적화 이해

## 참고 자료

- Cloudflare CDN Documentation
- AWS CloudFront Documentation
- Akamai CDN Best Practices
- "High Performance Browser Networking" - Ilya Grigorik
- MDN Web Docs: HTTP Caching
