# TCP/IP

**난이도: [2] 입문**

> 인터넷 통신의 핵심 프로토콜 스택으로, 4계층 구조와 신뢰성 있는 데이터 전송을 제공

## 왜 알아야 하는가?

- **네트워크의 근간**: 모든 인터넷 통신의 기반이 되는 핵심 프로토콜
- **문제 해결**: 네트워크 장애 분석 및 성능 튜닝의 기초 지식
- **프로토콜 이해**: HTTP, WebSocket 등 상위 프로토콜의 동작 원리 이해에 필수
- **시스템 설계**: 대규모 시스템의 네트워크 아키텍처 설계 시 필수
- **실무 활용**: 타임아웃 설정, 연결 풀 관리, 성능 최적화 등에 직접 활용

## 핵심 개념

- TCP/IP 4계층: 애플리케이션, 트랜스포트, 인터넷, 네트워크 인터페이스 계층으로 구성
- TCP vs UDP: 신뢰성 보장(TCP) vs 속도 우선(UDP)의 트레이드오프
- 3-way/4-way handshake: 연결 수립과 종료를 위한 양방향 확인 프로토콜
- 흐름 제어: 수신자의 처리 속도에 맞춰 전송 속도 조절
- 혼잡 제어: 네트워크 상황에 맞춰 전송량 조절로 전체 네트워크 효율 최적화

## 쉽게 이해하기

**TCP는 등기우편, UDP는 전단지 배포**에 비유할 수 있습니다.

등기우편(TCP)은 받는 사람이 수령 확인 서명을 해야 배송이 완료됩니다. 우편물이 분실되면 재발송하고, 순서대로 도착하는 것을 보장합니다. 반면 전단지 배포(UDP)는 일단 뿌리고 받았는지 확인하지 않습니다. 빠르지만 도착을 보장하지 않습니다.

예를 들어, 중요한 계약서는 등기우편(TCP)으로 보내야 하지만, 홍보 전단지는 일반 배포(UDP)로 충분합니다. 영상 스트리밍도 프레임 몇 개 손실되어도 괜찮으니 UDP로 빠르게 전송하는 것이 더 낫습니다.

## 상세 설명

### TCP/IP 4계층

| 계층 | 역할 | 프로토콜 예시 | 데이터 단위 |
|------|------|--------------|------------|
| 애플리케이션 | 사용자와 직접 상호작용 | HTTP, DNS, FTP | 메시지 |
| 트랜스포트 | 프로세스 간 통신, 신뢰성 보장 | TCP, UDP | 세그먼트 |
| 인터넷 | 패킷 라우팅, 주소 지정 | IP, ICMP | 패킷 |
| 네트워크 인터페이스 | 물리적 네트워크 전송 | Ethernet, Wi-Fi | 프레임 |

**왜 4계층으로 나누는가?**

계층을 나누면 각 계층이 자신의 책임만 집중할 수 있습니다. 예를 들어 HTTP는 "웹 통신을 어떻게 할까?"만 고민하고, TCP는 "신뢰성을 어떻게 보장할까?"만 고민합니다. 이렇게 하면:
- **관심사의 분리**: 각 계층은 독립적으로 발전 가능
- **재사용성**: 같은 TCP를 HTTP, FTP 등 여러 애플리케이션이 공유
- **유지보수성**: 한 계층의 변경이 다른 계층에 영향을 주지 않음

OSI 7계층과의 차이는 TCP/IP가 실용성을 중시한다는 점입니다. 실제 인터넷은 OSI 7계층이 아닌 TCP/IP 4계층으로 동작합니다.

### TCP vs UDP

| 비교 항목 | TCP | UDP |
|----------|-----|-----|
| 연결 | 연결 지향 (Connection-oriented) | 비연결 지향 (Connectionless) |
| 신뢰성 | 보장 (재전송, 순서 보장) | 보장 안 함 |
| 속도 | 상대적으로 느림 | 빠름 |
| 헤더 크기 | 20-60 bytes | 8 bytes |
| 사용 예시 | HTTP, FTP, 이메일 | DNS, 실시간 영상/음성 |

**왜 TCP는 신뢰성이 있는가?**

TCP는 다음 3가지 메커니즘으로 신뢰성을 보장합니다:

1. **순서 번호 (Sequence Number)**: 각 바이트에 번호를 매겨 순서가 뒤바뀌어도 재정렬 가능
2. **확인 응답 (ACK)**: 수신자가 "N번까지 받았어요"라고 알려줌
3. **재전송 (Retransmission)**: ACK를 못 받으면 타임아웃 후 재전송

**왜 UDP는 빠른가?**

UDP는 연결 수립, ACK 대기, 재전송이 없기 때문입니다. 헤더도 8바이트로 최소화되어 오버헤드가 적습니다. 대신 패킷이 손실되어도 복구하지 않습니다.

**언제 UDP를 사용하나?**

- **실시간 스트리밍**: 1초 전 영상 프레임을 재전송받아봤자 이미 늦음. 손실 감수하고 빠르게 전송
- **DNS 조회**: 간단한 요청-응답이라 재전송 로직을 애플리케이션에서 직접 구현하는 것이 효율적
- **온라인 게임**: 100ms 전 위치 정보는 의미 없음. 최신 상태를 빠르게 전송하는 것이 중요

### 3-way Handshake (연결 수립)

```
Client                Server
  |                     |
  |------ SYN --------->|  1. Client: "연결 요청합니다" (ISN=100)
  |                     |
  |<--- SYN-ACK --------|  2. Server: "수락합니다" (ISN=300, ACK=101)
  |                     |
  |------ ACK --------->|  3. Client: "확인했습니다" (ACK=301)
  |                     |
  |==== 연결 수립 완료 ====|
```

**왜 3단계인가? 2단계로는 안 되나?**

2-way로는 서버가 자신의 응답(SYN-ACK)이 클라이언트에 도착했는지 확인할 수 없습니다.

만약 2-way만 하면:
1. Client가 SYN 전송
2. Server가 SYN-ACK 전송하고 연결 수립 완료로 간주
3. 그런데 SYN-ACK가 유실되면?
   - Server: "연결 수립됨. 데이터 대기 중" (리소스 할당)
   - Client: "응답이 안 오네? 타임아웃" (연결 실패)
   - 결과: 서버만 연결 수립 상태로 리소스 낭비 (Half-Open 문제)

3번째 ACK를 통해 서버는 "클라이언트가 내 응답을 받았구나"를 확인할 수 있습니다.

**왜 4-way가 아닌가?**

3단계로 이미 양방향 통신 확인이 완료됩니다:
- 1단계(SYN): Client → Server 경로 확인
- 2단계(SYN-ACK): Server → Client 경로 확인
- 3단계(ACK): Server의 SYN이 Client에 도착했음을 확인

4단계는 불필요한 오버헤드입니다.

**ISN (Initial Sequence Number)이 랜덤인 이유는?**

만약 ISN을 항상 0부터 시작하면, 이전 연결의 지연된 패킷이 새 연결에서 유효한 패킷으로 오인될 수 있습니다. 랜덤 ISN을 사용하면 이런 충돌 확률을 극도로 낮출 수 있습니다.

### 4-way Handshake (연결 종료)

```
Client                Server
  |                     |
  |------ FIN --------->|  1. Client: "다 보냈어요, 종료할게요"
  |                     |
  |<----- ACK ----------|  2. Server: "알겠습니다" (아직 보낼 데이터 있을 수 있음)
  |                     |
  |<----- FIN ----------|  3. Server: "저도 다 보냈어요"
  |                     |
  |------ ACK --------->|  4. Client: "확인했습니다"
  |                     |
  |  (TIME_WAIT 2MSL)   |
  |                     |
  |==== 연결 종료 완료 ====|
```

**왜 4단계인가? 3단계로는 안 되나?**

연결 수립은 SYN과 ACK를 하나로 합쳐 SYN-ACK로 보낼 수 있지만, 종료는 합칠 수 없습니다.

**왜냐하면** 서버가 FIN을 받았어도 아직 보낼 데이터가 남아있을 수 있기 때문입니다:
1. Client FIN 수신: "클라이언트는 더 안 보낸다는군"
2. 즉시 ACK: "알겠어. 근데 나는 아직 보낼 데이터 있어"
3. 데이터 전송 완료 후 FIN: "이제 나도 다 보냈어"
4. Client ACK: "확인"

만약 2단계(ACK+FIN 동시)로 줄이면, 서버가 보내던 데이터를 중간에 강제 종료해야 합니다.

**TIME_WAIT이 필요한 이유는?**

Client가 마지막 ACK를 보내고 바로 종료하면:
- 마지막 ACK가 유실될 경우, Server는 FIN을 재전송
- 그런데 Client는 이미 종료되어 "잘못된 포트"라는 RST 응답 전송
- Server는 정상 종료가 아닌 오류 종료로 처리됨

TIME_WAIT (2*MSL, 보통 1-4분)동안 대기하면:
- Server의 FIN 재전송을 받아도 ACK 재전송 가능
- 이전 연결의 지연 패킷이 새 연결에 영향주는 것 방지

### 흐름 제어 (Flow Control)

**문제**: 송신자가 빠르고 수신자가 느리면?

수신자의 버퍼가 넘쳐서 패킷을 버릴 수 밖에 없습니다. 그러면 재전송이 발생하고 오히려 전체 효율이 떨어집니다.

**해결책: Sliding Window**

수신자가 자신의 남은 버퍼 크기(Window Size)를 송신자에게 알려줍니다.

```
Receiver Buffer: [____####] (Window Size = 4KB)
Sender: "4KB 이하로만 보내야겠구나"
```

**왜 이렇게 하는가?**

송신자가 수신자의 처리 속도에 맞춰 전송하면:
- 불필요한 재전송 감소
- 수신자 버퍼 오버플로우 방지
- 전체 전송 효율 향상

**Zero Window일 때는?**

수신자 버퍼가 꽉 차면 Window Size = 0을 알려줍니다. 송신자는 전송을 멈추고, 주기적으로 "지금 받을 수 있어?"라고 묻는 탐색 패킷(Window Probe)을 보냅니다.

### 혼잡 제어 (Congestion Control)

**문제**: 네트워크가 혼잡하면?

중간 라우터의 큐가 넘쳐서 패킷을 버립니다. 모든 송신자가 동시에 재전송하면 혼잡이 더 심해지는 악순환이 발생합니다.

**해결책: AIMD + Slow Start + Fast Recovery**

#### 1. Slow Start

연결 초기에는 네트워크 상태를 모르니까, 조심스럽게 시작합니다:
- 처음: 1 MSS (Maximum Segment Size)
- ACK 받으면: 2 MSS
- ACK 받으면: 4 MSS
- 지수적으로 증가 (1 → 2 → 4 → 8 → 16...)

**왜 지수적으로 증가하나?**

선형 증가는 최적 속도에 도달하는데 너무 오래 걸립니다. 네트워크가 충분히 여유로울 수 있으므로, 빠르게 탐색하는 것이 효율적입니다.

#### 2. Congestion Avoidance (혼잡 회피)

임계값(ssthresh)에 도달하면 선형 증가로 전환:
- ACK 받으면: +1 MSS
- 천천히 증가하면서 한계점 탐색

**왜 선형으로 전환하나?**

임계값 근처는 혼잡이 발생할 수 있는 구간이므로, 조심스럽게 증가시켜야 합니다. 지수적으로 계속 증가하면 순식간에 혼잡 상태가 됩니다.

#### 3. Fast Retransmit & Fast Recovery

중복 ACK 3번 받으면 (패킷 손실로 판단):
- 타임아웃 기다리지 않고 즉시 재전송
- ssthresh를 현재 윈도우의 절반으로 설정
- Slow Start 대신 Congestion Avoidance부터 시작

**왜 타임아웃을 기다리지 않나?**

중복 ACK가 오는 것은 일부 패킷만 손실되고 네트워크는 여전히 동작 중이라는 의미입니다. 타임아웃까지 기다리면 전송 속도가 급격히 떨어집니다.

**왜 절반으로 줄이나?**

전체를 버리기에는 아깝고 (네트워크가 완전히 죽은 것은 아님), 그대로 유지하기에는 혼잡 신호가 있으므로, 절반으로 줄여서 안전 마진을 확보합니다.

## 동작 원리

### TCP 세그먼트 구조

```
0                   15 16                  31
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Source Port     |    Dest Port      | 출발지/목적지 포트
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|              Sequence Number              | 순서 번호
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Acknowledgment Number           | 확인 응답 번호
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Offset|Rsv|Flags|       Window Size       | 플래그, 윈도우 크기
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Checksum         |   Urgent Pointer  | 체크섬, 긴급 포인터
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                 Options                   | 옵션
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Data                     | 데이터
```

주요 플래그:
- **SYN**: 연결 수립 요청
- **ACK**: 확인 응답
- **FIN**: 연결 종료
- **RST**: 연결 강제 종료 (오류 발생)
- **PSH**: 버퍼링 없이 즉시 전달
- **URG**: 긴급 데이터

## 트레이드오프

| TCP 장점 | TCP 단점 |
|---------|---------|
| 데이터 정확성 보장 (재전송, 순서 보장) | 오버헤드로 인한 속도 저하 (헤더, ACK 등) |
| 흐름/혼잡 제어로 네트워크 효율 최적화 | 실시간 스트리밍에는 부적합 (재전송 지연) |
| 안정적인 파일 전송, HTTP 통신에 적합 | 연결 수립/종료 과정 필요 (지연 발생) |

| UDP 장점 | UDP 단점 |
|---------|---------|
| 빠른 전송 속도 (오버헤드 최소) | 신뢰성 보장 없음 (패킷 손실, 순서 뒤바뀜) |
| 실시간 스트리밍, 게임에 적합 | 흐름/혼잡 제어 없음 (네트워크 부담) |
| 간단한 구조로 구현 쉬움 | 애플리케이션에서 직접 신뢰성 구현 필요 |

**결론**:
- 정확성이 중요하면 TCP (파일 전송, 웹, 이메일)
- 속도가 중요하면 UDP (실시간 영상, 음성, 게임)
- 최근에는 QUIC (UDP 기반 + TCP의 신뢰성 기능)이 등장

## 면접 예상 질문

- Q: TCP 3-way handshake가 필요한 이유는 무엇인가요?
  - A: 양방향 통신이 모두 가능함을 확인하기 위해서입니다. 2-way만 하면 서버가 자신의 SYN-ACK가 클라이언트에 도착했는지 확인할 수 없습니다. 만약 SYN-ACK가 유실되면 서버는 연결이 수립되었다고 생각하지만 클라이언트는 타임아웃 상태가 되어, 서버 리소스만 낭비되는 Half-Open 문제가 발생합니다. 3번째 ACK를 통해 서버는 클라이언트가 준비되었음을 확인하고 안전하게 연결을 수립할 수 있습니다.

- Q: 왜 연결 종료는 4-way handshake인가요?
  - A: 연결 수립과 달리 종료는 ACK와 FIN을 합칠 수 없기 때문입니다. 서버가 클라이언트의 FIN을 받았어도 아직 보낼 데이터가 남아있을 수 있습니다. 따라서 일단 ACK로 "FIN 받았어"를 알리고, 데이터 전송을 마친 후 별도로 FIN을 보내야 합니다. 만약 ACK와 FIN을 동시에 보내면 서버가 전송 중이던 데이터를 강제로 종료해야 하는 문제가 발생합니다.

- Q: TCP와 UDP의 차이점과 각각 어떤 상황에 사용하나요?
  - A: TCP는 연결 지향적이고 신뢰성을 보장합니다. 3-way handshake로 연결을 수립하고, ACK/재전송으로 패킷 손실을 복구하며, 순서 번호로 순서를 보장합니다. 따라서 정확성이 중요한 파일 전송, HTTP 통신, 이메일에 사용합니다. 반면 UDP는 비연결형이고 빠릅니다. 헤더가 8바이트로 작고 연결 수립이 없어 오버헤드가 적지만, 신뢰성은 보장하지 않습니다. 따라서 실시간 영상 스트리밍, 온라인 게임처럼 속도가 중요하고 일부 패킷 손실은 감수할 수 있는 경우에 사용합니다. DNS 조회처럼 간단한 요청-응답도 UDP를 사용합니다.

- Q: 흐름 제어와 혼잡 제어의 차이는 무엇인가요?
  - A: 흐름 제어는 수신자의 처리 능력을 고려하고, 혼잡 제어는 네트워크 전체 상황을 고려합니다. 흐름 제어는 수신자가 자신의 남은 버퍼 크기(Window Size)를 송신자에게 알려서, 송신자가 수신자의 처리 속도에 맞춰 전송하도록 합니다. 이를 통해 수신자 버퍼 오버플로우를 방지합니다. 반면 혼잡 제어는 중간 라우터의 큐 오버플로우를 방지합니다. Slow Start로 조심스럽게 전송량을 늘리고, 패킷 손실이 감지되면 전송량을 줄여서 네트워크 혼잡을 완화합니다. 즉, 흐름 제어는 "상대방이 받을 수 있나?"를 확인하고, 혼잡 제어는 "네트워크가 전달할 수 있나?"를 확인합니다.

- Q: TIME_WAIT 상태는 왜 필요한가요?
  - A: TIME_WAIT는 연결 종료 시 발생할 수 있는 두 가지 문제를 방지합니다. 첫째, 클라이언트가 보낸 마지막 ACK가 유실되면 서버는 FIN을 재전송합니다. 이때 클라이언트가 이미 종료되었다면 RST 응답이 가서 서버가 오류 종료로 처리됩니다. TIME_WAIT 상태로 2*MSL(보통 1-4분) 동안 대기하면 재전송된 FIN을 받아 ACK를 다시 보낼 수 있습니다. 둘째, 이전 연결의 지연된 패킷이 같은 포트를 사용하는 새 연결에 영향주는 것을 방지합니다. TIME_WAIT 동안 해당 포트를 재사용하지 않으면 오래된 패킷이 모두 사라질 때까지 기다릴 수 있습니다.

- Q: Slow Start에서 왜 지수적으로 증가하다가 선형으로 전환하나요?
  - A: 초기에는 네트워크 상태를 모르므로 지수적으로 빠르게 증가시켜 최적 속도를 탐색합니다. 1 → 2 → 4 → 8처럼 증가하면 선형 증가보다 훨씬 빠르게 적정 전송량에 도달할 수 있습니다. 하지만 임계값(ssthresh) 근처에서는 혼잡이 발생할 가능성이 있으므로, 선형 증가(+1 MSS)로 전환하여 조심스럽게 한계점을 탐색합니다. 만약 임계값 이후에도 지수적으로 증가하면 순식간에 네트워크가 혼잡해져 대량 패킷 손실이 발생합니다. 따라서 빠른 탐색과 안정적인 운영의 균형을 맞추기 위해 두 단계로 나눕니다.

## 연관 문서

- [HTTP/HTTPS](./http-https.md) - HTTP는 TCP 위에서 동작하며 신뢰성 있는 전송 보장
- [WebSocket](./websocket.md) - WebSocket도 TCP 연결 기반의 양방향 통신
- [DNS](./dns.md) - DNS는 주로 UDP를 사용하며 필요 시 TCP로 폴백
- [Load Balancing](./load-balancing.md) - L4 로드밸런서는 TCP/UDP 포트 기반 분산

## 참고 자료

- RFC 793: Transmission Control Protocol
- RFC 768: User Datagram Protocol
- RFC 2581: TCP Congestion Control
- Computer Networking: A Top-Down Approach (Kurose, Ross)
