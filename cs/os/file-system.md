# 파일시스템 (File System)

> 운영체제가 저장 장치에서 파일을 조직화하고 관리하는 방법과 구조

## 핵심 개념

- **파일시스템**: 데이터를 저장, 조직, 검색하기 위한 계층적 구조와 규칙
- **inode**: 파일의 메타데이터를 저장하는 자료구조 (Unix/Linux)
- **저널링**: 시스템 장애 시 데이터 무결성을 보장하는 기법
- **블록**: 파일시스템이 데이터를 읽고 쓰는 최소 단위

## 쉽게 이해하기

파일시스템은 **도서관의 분류 체계**와 같습니다.

```
도서관                    파일시스템
─────────────────────────────────────
서가 번호              →  디렉토리 경로
도서 카드(메타정보)    →  inode
실제 책 내용           →  데이터 블록
카탈로그 시스템        →  디렉토리 엔트리
```

책을 찾을 때 카탈로그에서 위치를 확인하듯이, 파일시스템도 inode를 통해 실제 데이터 위치를 찾습니다.

## 상세 설명

### 파일시스템 구조

```
┌─────────────────────────────────────────────────────────┐
│                     Boot Block                          │
│              (부팅에 필요한 정보)                         │
├─────────────────────────────────────────────────────────┤
│                    Super Block                          │
│    (파일시스템 크기, 블록 수, inode 수 등 메타정보)        │
├─────────────────────────────────────────────────────────┤
│                    inode Table                          │
│         (각 파일의 메타데이터 저장)                       │
├─────────────────────────────────────────────────────────┤
│                    Data Blocks                          │
│              (실제 파일 데이터 저장)                      │
└─────────────────────────────────────────────────────────┘
```

**왜 이렇게 나누는가?**
- 메타데이터와 실제 데이터를 분리하여 검색 효율성 향상
- 슈퍼블록에서 전체 파일시스템 상태를 빠르게 파악 가능
- inode 테이블로 파일 위치를 O(1)에 접근

### inode 구조

```
┌─────────────────────────────────────┐
│            inode                    │
├─────────────────────────────────────┤
│  파일 타입 (일반/디렉토리/심볼릭링크) │
│  권한 (rwxrwxrwx)                   │
│  소유자 (UID/GID)                   │
│  파일 크기                          │
│  타임스탬프 (atime, mtime, ctime)   │
│  링크 카운트                        │
│  데이터 블록 포인터                  │
│    ├─ 직접 포인터 (12개)            │
│    ├─ 단일 간접 포인터              │
│    ├─ 이중 간접 포인터              │
│    └─ 삼중 간접 포인터              │
└─────────────────────────────────────┘
```

**왜 간접 포인터를 사용하는가?**
- 직접 포인터만으로는 작은 파일만 표현 가능
- 간접 포인터로 대용량 파일 지원 (TB 단위까지)
- 작은 파일은 직접 포인터로 빠르게 접근

### 파일 접근 과정

```
사용자: open("/home/user/file.txt")

1. 루트(/) 디렉토리의 inode 조회 (inode 2)
   └─ home의 inode 번호 획득

2. home 디렉토리의 inode 조회
   └─ user의 inode 번호 획득

3. user 디렉토리의 inode 조회
   └─ file.txt의 inode 번호 획득

4. file.txt의 inode 조회
   └─ 데이터 블록 포인터로 실제 데이터 접근
```

### 저널링 (Journaling)

```
일반 쓰기 작업:
┌─────────┐    ┌─────────┐    ┌─────────┐
│ 메타데이터│ → │  데이터  │ → │  완료   │
│   수정   │    │   쓰기  │    │        │
└─────────┘    └─────────┘    └─────────┘
                   ↑
              장애 발생 시
            데이터 불일치!

저널링 쓰기 작업:
┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐
│ 저널에  │ → │  실제   │ → │ 저널에  │ → │  완료   │
│ 기록    │    │  쓰기   │    │ 커밋    │    │        │
└─────────┘    └─────────┘    └─────────┘    └─────────┘
     ↑              ↑
장애 발생 시     장애 발생 시
저널로 복구     저널로 롤백
```

**왜 저널링을 사용하는가?**
- 갑작스러운 전원 차단, 시스템 충돌 시 데이터 보호
- fsck(파일시스템 검사) 시간 대폭 단축
- 트랜잭션 단위로 일관성 보장

## 주요 파일시스템 비교

| 파일시스템 | OS | 최대 파일 크기 | 최대 볼륨 크기 | 특징 |
|-----------|-----|--------------|--------------|------|
| **ext4** | Linux | 16TB | 1EB | 저널링, 익스텐트 기반 |
| **XFS** | Linux | 8EB | 8EB | 대용량 파일 최적화 |
| **Btrfs** | Linux | 16EB | 16EB | CoW, 스냅샷, 체크섬 |
| **NTFS** | Windows | 16EB | 256TB | ACL, 압축, 암호화 |
| **APFS** | macOS/iOS | 8EB | - | CoW, 스냅샷, 암호화 |

### ext4의 주요 특징

```
익스텐트(Extent) 기반 할당:
─────────────────────────────
기존 블록 맵핑 (ext2/3):
  블록 1 → 위치 100
  블록 2 → 위치 101
  블록 3 → 위치 102
  ... (블록마다 매핑 필요)

익스텐트 (ext4):
  시작 블록: 100, 길이: 1000
  (연속된 블록을 하나의 단위로 관리)

→ 대용량 파일의 메타데이터 오버헤드 감소
→ 연속 읽기/쓰기 성능 향상
```

## 하드링크 vs 심볼릭링크

```
원본 파일: file.txt (inode: 12345)

하드링크 생성: ln file.txt hardlink
─────────────────────────────────────
file.txt ──┐
           ├──→ inode 12345 → 데이터 블록
hardlink ──┘

- 같은 inode를 가리킴
- 원본 삭제해도 데이터 유지 (링크 카운트 > 0)
- 다른 파일시스템에 생성 불가

심볼릭링크 생성: ln -s file.txt symlink
─────────────────────────────────────
file.txt → inode 12345 → 데이터 블록
symlink  → inode 67890 → "file.txt" (경로 문자열)

- 새로운 inode 생성
- 원본 삭제 시 "dangling link" 발생
- 다른 파일시스템에도 생성 가능
```

## 트레이드오프

| 장점 | 단점 |
|------|------|
| 계층적 구조로 직관적 관리 | inode 고갈 시 공간 남아도 파일 생성 불가 |
| 메타데이터 분리로 빠른 검색 | 파일시스템마다 호환성 이슈 |
| 저널링으로 데이터 안정성 확보 | 저널링 오버헤드 (쓰기 성능 저하) |
| 권한 시스템으로 보안 강화 | 단편화로 성능 저하 가능 |

## 면접 예상 질문

### Q: inode가 무엇이고 왜 필요한가요?

A: inode는 파일의 메타데이터(권한, 크기, 소유자, 데이터 블록 위치 등)를 저장하는 자료구조입니다. **파일 이름과 실제 데이터를 분리**하기 위해 필요합니다. 이로 인해:
- 같은 데이터를 여러 이름(하드링크)으로 참조 가능
- 파일 이름 변경 시 데이터 이동 없이 디렉토리 엔트리만 수정
- 메타데이터 접근과 데이터 접근을 분리하여 효율적 캐싱 가능

### Q: 저널링 파일시스템의 동작 원리를 설명해주세요.

A: 저널링은 **Write-Ahead Logging** 방식입니다. 실제 데이터 변경 전에 "이러한 변경을 할 예정"이라는 정보를 저널 영역에 먼저 기록합니다.
- 장애 발생 시 저널을 확인하여 미완료 작업을 롤백하거나 재실행
- 전체 디스크 검사(fsck) 없이 저널만 확인하면 되므로 복구 시간 단축
- 데이터베이스의 트랜잭션 로그와 동일한 원리

### Q: 하드링크와 심볼릭링크의 차이점은?

A: **하드링크**는 동일한 inode를 가리키는 또 다른 디렉토리 엔트리입니다. 원본과 동등한 지위를 가지며, 모든 하드링크가 삭제되어야 데이터가 삭제됩니다.

**심볼릭링크**는 별도의 inode를 가지며, 원본 파일의 경로 문자열을 저장합니다. 원본이 삭제되면 "dangling link"가 되어 무효화됩니다.

하드링크는 같은 파일시스템 내에서만, 심볼릭링크는 다른 파일시스템도 참조 가능합니다.

### Q: "No space left on device" 에러가 발생했는데 df로 확인하면 공간이 남아있습니다. 원인이 무엇일까요?

A: inode 고갈일 가능성이 높습니다. 파일시스템 생성 시 inode 수가 고정되는데, 작은 파일이 매우 많으면 데이터 블록 공간이 남아도 inode가 먼저 소진될 수 있습니다. `df -i` 명령으로 inode 사용량을 확인할 수 있습니다.

## 실습 명령어

```bash
# 파일시스템 정보 확인
df -Th

# inode 사용량 확인
df -i

# 파일의 inode 정보 확인
stat filename
ls -i filename

# 하드링크 생성
ln original hardlink

# 심볼릭링크 생성
ln -s original symlink

# 파일시스템 타입 확인
file -s /dev/sda1

# 저널 상태 확인 (ext4)
dumpe2fs /dev/sda1 | grep -i journal
```

## 참고 자료

- [Linux Kernel Documentation - Filesystems](https://www.kernel.org/doc/html/latest/filesystems/)
- [ext4 Data Structures and Algorithms](https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout)
- Operating System Concepts (Silberschatz)
