# CPU 스케줄링 (CPU Scheduling)

> `[3] 중급` · 선수 지식: [프로세스와 스레드](./process-vs-thread.md)

> CPU 시간을 여러 프로세스에 효율적으로 배분하는 운영체제의 핵심 기능

`#스케줄링` `#Scheduling` `#CPU스케줄링` `#CPUScheduling` `#선점` `#Preemptive` `#비선점` `#NonPreemptive` `#FCFS` `#SJF` `#RoundRobin` `#라운드로빈` `#우선순위` `#Priority` `#멀티레벨큐` `#MultiLevelQueue` `#컨텍스트스위칭` `#ContextSwitch` `#타임슬라이스` `#TimeSlice` `#퀀텀` `#Quantum` `#처리량` `#Throughput` `#응답시간` `#ResponseTime` `#대기시간` `#WaitingTime` `#반환시간` `#TurnaroundTime`

## 왜 알아야 하는가?

CPU는 한 번에 하나의 프로세스만 실행할 수 있습니다. 여러 프로세스가 동시에 실행되는 것처럼 보이는 것은 스케줄링 덕분입니다. 스케줄링 알고리즘에 따라 시스템의 응답성, 처리량, 공정성이 달라집니다. 백엔드 개발자라면 왜 특정 프로세스가 느린지, 어떻게 우선순위를 조정하는지 이해해야 합니다.

## 핵심 개념

- **스케줄링**: 어떤 프로세스에게 CPU를 할당할지 결정하는 것
- **선점 (Preemptive)**: 실행 중인 프로세스를 강제로 중단하고 다른 프로세스 실행
- **비선점 (Non-Preemptive)**: 프로세스가 자발적으로 CPU를 반납할 때까지 대기
- **컨텍스트 스위칭**: 현재 프로세스 상태를 저장하고 다른 프로세스 상태를 복원
- **타임 슬라이스 (Time Slice)**: 프로세스가 CPU를 사용할 수 있는 최대 시간

## 쉽게 이해하기

**CPU 스케줄링**을 은행 창구에 비유할 수 있습니다.

- **CPU = 창구 직원**: 한 번에 한 고객만 응대
- **프로세스 = 고객**: 업무 처리 대기
- **스케줄러 = 번호표 시스템**: 누구를 먼저 처리할지 결정

**스케줄링 방식**:
- **FCFS (선착순)**: 먼저 온 고객부터 처리
- **SJF (최단 작업)**: 업무가 간단한 고객 먼저
- **Round Robin**: 5분씩 번갈아 처리, 안 끝나면 다시 줄 서기
- **우선순위**: VIP 고객 먼저 처리

## 상세 설명

### 프로세스 상태와 스케줄링

```
                    ┌─────────┐
         생성       │  New    │
                    └────┬────┘
                         │ admit
                         ▼
┌─────────┐  dispatch ┌─────────┐  timeout/interrupt
│  Ready  │◄─────────►│ Running │──────────┐
│  Queue  │           └────┬────┘          │
└────┬────┘                │               │
     │                     │ exit          │
     │                     ▼               │
     │               ┌─────────┐           │
     │               │Terminated│          │
     │               └─────────┘           │
     │                                     │
     │  I/O 완료      ┌─────────┐  I/O 요청│
     └───────────────│ Waiting │◄──────────┘
                     └─────────┘
```

### 스케줄링 성능 지표

| 지표 | 설명 | 목표 |
|------|------|------|
| **CPU 이용률** | CPU가 일하는 시간 비율 | 높을수록 좋음 |
| **처리량 (Throughput)** | 단위 시간당 완료된 프로세스 수 | 높을수록 좋음 |
| **대기 시간 (Waiting Time)** | Ready Queue에서 기다린 시간 | 낮을수록 좋음 |
| **응답 시간 (Response Time)** | 요청 후 첫 응답까지 시간 | 낮을수록 좋음 |
| **반환 시간 (Turnaround Time)** | 제출~완료까지 총 시간 | 낮을수록 좋음 |

### 비선점 스케줄링 (Non-Preemptive)

#### FCFS (First Come First Served)

**특징**: 먼저 도착한 프로세스 먼저 실행, 가장 단순

```
도착 순서: P1(24ms) → P2(3ms) → P3(3ms)

실행 순서:
|-------- P1 (24ms) --------|-- P2 --|-- P3 --|
0                          24      27       30

대기 시간: P1=0, P2=24, P3=27 → 평균 17ms
```

**문제: Convoy Effect (호위 효과)**
- 긴 프로세스 뒤에 짧은 프로세스들이 오래 기다림
- 평균 대기 시간 증가

#### SJF (Shortest Job First)

**특징**: 실행 시간이 가장 짧은 프로세스 먼저 실행

```
도착 순서: P1(24ms), P2(3ms), P3(3ms) (동시 도착 가정)

실행 순서:
|-- P2 --|-- P3 --|-------- P1 (24ms) --------|
0        3        6                           30

대기 시간: P1=6, P2=0, P3=3 → 평균 3ms (최적!)
```

**장점**: 평균 대기 시간 최소화 (이론적 최적)
**단점**:
- 실행 시간을 미리 알기 어려움
- **기아 현상 (Starvation)**: 긴 프로세스가 계속 밀림

### 선점 스케줄링 (Preemptive)

#### Round Robin (RR)

**특징**: 각 프로세스에 동일한 시간(Time Quantum)을 할당, 시간 초과 시 다음 프로세스로

```
Time Quantum = 4ms
프로세스: P1(10ms), P2(4ms), P3(6ms)

실행 순서:
|P1|P2|P3|P1|P3|P1|
 4  4  4  4  2  2

P1: 0-4, 12-16, 18-20 (완료)
P2: 4-8 (완료)
P3: 8-12, 16-18 (완료)
```

**타임 퀀텀 선택**:
- **너무 작으면**: 컨텍스트 스위칭 오버헤드 증가
- **너무 크면**: FCFS와 유사해짐, 응답 시간 증가
- **일반적**: 10~100ms

**장점**: 응답 시간 보장, 공정성
**단점**: 컨텍스트 스위칭 오버헤드

#### SRTF (Shortest Remaining Time First)

**특징**: SJF의 선점 버전, 남은 시간이 가장 짧은 프로세스 실행

```
시간 0: P1(7ms) 도착 → P1 실행
시간 2: P2(4ms) 도착 → P2가 더 짧음 → P1 중단, P2 실행
시간 4: P3(1ms) 도착 → P3가 더 짧음 → P2 중단, P3 실행
...
```

**장점**: 평균 대기 시간 최소화
**단점**: 기아 현상, 잦은 컨텍스트 스위칭

#### 우선순위 스케줄링 (Priority Scheduling)

**특징**: 각 프로세스에 우선순위 부여, 높은 우선순위 먼저 실행

```
프로세스: P1(우선순위 3), P2(우선순위 1), P3(우선순위 2)
(숫자가 낮을수록 높은 우선순위)

실행 순서: P2 → P3 → P1
```

**문제: 기아 현상 (Starvation)**
- 낮은 우선순위 프로세스가 영원히 실행되지 않음

**해결: 에이징 (Aging)**
- 대기 시간이 길어질수록 우선순위 증가

```
시간 경과에 따른 우선순위 변화:
P1: 3 → 2 → 1 (점점 높아짐)
```

#### 다단계 큐 (Multi-Level Queue)

**특징**: 프로세스 유형별로 다른 큐와 알고리즘 적용

```
┌─────────────────────────────────────┐
│ 시스템 프로세스 (최고 우선순위)      │ ← Round Robin
├─────────────────────────────────────┤
│ 대화형 프로세스                      │ ← Round Robin
├─────────────────────────────────────┤
│ 배치 프로세스 (최저 우선순위)        │ ← FCFS
└─────────────────────────────────────┘
```

#### 다단계 피드백 큐 (Multi-Level Feedback Queue)

**특징**: 프로세스가 큐 간 이동 가능, 가장 범용적

```
┌─────────────────────────────────────┐
│ Q0: 퀀텀 8ms (최고 우선순위)         │
│     시간 초과 시 → Q1로 이동         │
├─────────────────────────────────────┤
│ Q1: 퀀텀 16ms                        │
│     시간 초과 시 → Q2로 이동         │
├─────────────────────────────────────┤
│ Q2: FCFS (최저 우선순위)             │
└─────────────────────────────────────┘
```

**동작**:
1. 새 프로세스는 Q0에서 시작
2. CPU 집중적(오래 걸리는) 프로세스는 아래 큐로 이동
3. I/O 집중적(짧은) 프로세스는 위 큐에 유지
4. 대기가 길어지면 위 큐로 승격 (에이징)

### 컨텍스트 스위칭 (Context Switching)

**정의**: 현재 프로세스 상태를 저장하고 다른 프로세스 상태를 복원하는 과정

```
┌─────────────────────────────────────────────────┐
│ 프로세스 A 실행 중                              │
│ → 인터럽트/타임아웃 발생                        │
├─────────────────────────────────────────────────┤
│ 1. 프로세스 A의 PCB 저장                        │
│    - 레지스터 값                                │
│    - 프로그램 카운터                            │
│    - 스택 포인터                                │
├─────────────────────────────────────────────────┤
│ 2. 프로세스 B의 PCB 복원                        │
│    - 레지스터 값                                │
│    - 프로그램 카운터                            │
│    - 스택 포인터                                │
├─────────────────────────────────────────────────┤
│ 프로세스 B 실행 시작                            │
└─────────────────────────────────────────────────┘
```

**비용**:
- 직접 비용: PCB 저장/복원 (수 마이크로초)
- 간접 비용: 캐시 무효화 (Cache Pollution)

### Linux의 CFS (Completely Fair Scheduler)

**특징**: 모든 프로세스에 공정한 CPU 시간 배분

```
가상 실행 시간 (vruntime)
- 실제 실행 시간 / 가중치
- vruntime이 가장 작은 프로세스 선택

Red-Black Tree로 관리
- 삽입/삭제: O(log N)
- 최솟값 선택: O(1)
```

## 트레이드오프

| 알고리즘 | 장점 | 단점 | 적합한 상황 |
|---------|------|------|------------|
| FCFS | 단순, 공정 | Convoy Effect | 배치 시스템 |
| SJF | 최적 대기 시간 | 기아, 예측 어려움 | 실행 시간 예측 가능 시 |
| Round Robin | 응답 시간 보장 | 컨텍스트 스위칭 | 대화형 시스템 |
| Priority | 중요 작업 우선 | 기아 | 실시간 시스템 |
| MLFQ | 범용적 | 복잡 | 범용 OS |

## 면접 예상 질문

### Q: 선점과 비선점 스케줄링의 차이는?

A: **비선점**은 프로세스가 자발적으로 CPU를 반납할 때까지 기다리고, **선점**은 OS가 강제로 CPU를 뺏을 수 있습니다. **왜 선점이 필요한가?** 비선점은 긴 프로세스가 CPU를 독점하면 다른 프로세스가 무한 대기합니다. 선점은 타이머 인터럽트로 시간 제한을 두어 공정성과 응답성을 보장합니다. **단점**: 선점은 컨텍스트 스위칭 오버헤드가 발생합니다.

### Q: Round Robin의 타임 퀀텀을 어떻게 설정하나요?

A: **너무 작으면** (1ms) 컨텍스트 스위칭이 너무 자주 발생해 오버헤드가 커집니다. **너무 크면** (1초) FCFS와 유사해져 응답 시간이 길어집니다. **일반적으로** 10~100ms로 설정하며, 컨텍스트 스위칭 시간의 1% 미만이 되도록 합니다. **현대 OS**: Linux CFS는 스케줄링 지연 시간(타겟 레이턴시)을 기반으로 동적 조정합니다.

### Q: 기아 현상이란 무엇이고 어떻게 해결하나요?

A: **기아 현상**은 특정 프로세스가 CPU를 영원히 할당받지 못하는 상황입니다. 우선순위 스케줄링에서 낮은 우선순위 프로세스, SJF에서 긴 프로세스가 피해자가 됩니다. **해결책: 에이징(Aging)** - 대기 시간이 길어질수록 우선순위를 점진적으로 높입니다. 예: 1초마다 우선순위 +1. 결국 가장 낮은 우선순위 프로세스도 실행됩니다.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [프로세스와 스레드](./process-vs-thread.md) | 선수 지식 | [2] 입문 |
| [동기화](./synchronization.md) | 프로세스 간 조율 | [3] 중급 |

## 참고 자료

- Operating System Concepts (공룡책) - Silberschatz
- [Linux CFS Scheduler](https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html)
