# 메모리 관리 (Memory Management)

> 운영체제가 메인 메모리를 효율적으로 관리하고, 프로세스에게 메모리 공간을 할당/회수하는 기법

## 핵심 개념

- **가상 메모리**: 물리 메모리보다 큰 주소 공간을 프로세스에게 제공하는 기법
- **페이징**: 메모리를 고정 크기 블록(페이지)으로 분할하여 관리
- **세그멘테이션**: 논리적 단위(코드, 데이터, 스택)로 메모리를 분할
- **페이지 교체**: 메모리가 부족할 때 어떤 페이지를 swap out할지 결정하는 알고리즘
- **메모리 단편화**: 메모리 공간이 비효율적으로 분산되는 현상

## 쉽게 이해하기

**메모리 관리**를 도서관 시스템에 비유할 수 있습니다.

### 가상 메모리 = 도서관 대출 시스템

도서관에 있는 모든 책을 집에 가져올 수는 없습니다. 하지만 도서관 카드만 있으면 마치 모든 책이 내 것인 것처럼 필요할 때마다 빌려볼 수 있죠.

컴퓨터도 마찬가지입니다. 8GB RAM을 가진 컴퓨터에서 16GB짜리 프로그램을 실행할 수 있는 이유는, 당장 필요한 부분만 메모리에 올리고 나머지는 하드디스크(창고)에 보관하기 때문입니다.

### 페이징 = 책을 챕터별로 대출

100페이지짜리 책을 읽을 때, 1장을 읽는 동안 나머지 9개 장은 굳이 들고 있을 필요가 없습니다.

- **페이지**: 책의 각 챕터 (일정한 크기로 나눈 조각)
- **프레임**: 내 책상 위 공간 (책을 놓을 수 있는 자리)
- **페이지 폴트**: "2장 읽고 싶은데 책상에 없네? 창고에서 가져와야지" (디스크에서 로드)

### 페이지 교체 = 책상 정리

책상 위 공간(메모리)이 꽉 찼는데 새 책(페이지)을 올려야 한다면?

| 전략 | 비유 |
|------|------|
| FIFO | "가장 오래 전에 올려놓은 책 치우기" |
| LRU | "가장 오랫동안 안 읽은 책 치우기" (보통 가장 효율적) |
| LFU | "총 읽은 횟수가 가장 적은 책 치우기" |

### 스레싱 = 계속 창고 왔다갔다

책상이 너무 작아서 책을 펼치자마자 다른 책이 필요해지고, 그걸 가져오면 또 다른 책이 필요한 상황. 결국 공부는 못 하고 창고 왔다갔다만 하는 것이 **스레싱**입니다.

## 상세 설명

### 물리 메모리 vs 가상 메모리

| 구분 | 물리 메모리 | 가상 메모리 |
|------|------------|------------|
| 정의 | 실제 RAM 하드웨어 | OS가 제공하는 추상화된 메모리 공간 |
| 크기 | 하드웨어 제한 | 이론적으로 무제한 (디스크 활용) |
| 주소 | 물리 주소 | 논리 주소 (가상 주소) |
| 접근 | 직접 접근 | MMU를 통한 주소 변환 필요 |

### 페이징 (Paging)

메모리를 **고정 크기의 블록**으로 나누어 관리하는 기법

- **페이지 (Page)**: 가상 메모리의 고정 크기 블록 (보통 4KB)
- **프레임 (Frame)**: 물리 메모리의 고정 크기 블록
- **페이지 테이블**: 가상 주소 → 물리 주소 매핑 정보 저장

```
가상 주소 구조 (32비트 기준):
+----------------+------------------+
|   페이지 번호   |   페이지 오프셋   |
|    (20비트)    |     (12비트)     |
+----------------+------------------+
```

**장점**
- 외부 단편화 없음
- 메모리 할당/해제가 간단

**단점**
- 내부 단편화 발생 가능 (마지막 페이지)
- 페이지 테이블 오버헤드

### 세그멘테이션 (Segmentation)

메모리를 **논리적 단위**로 나누어 관리하는 기법

| 세그먼트 | 설명 |
|---------|------|
| Code | 실행 코드 영역 |
| Data | 전역 변수, 정적 변수 |
| Heap | 동적 메모리 할당 영역 |
| Stack | 함수 호출, 지역 변수 |

**장점**
- 논리적 구조와 일치
- 세그먼트 단위 보호/공유 가능

**단점**
- 외부 단편화 발생
- 가변 크기로 관리 복잡

### 페이지드 세그멘테이션 (Paged Segmentation)

세그멘테이션과 페이징을 결합한 방식

```
[가상 주소]
+------------+-----------+------------+
| 세그먼트 번호 | 페이지 번호 | 오프셋     |
+------------+-----------+------------+
      ↓
[세그먼트 테이블] → [페이지 테이블] → [물리 주소]
```

### 메모리 단편화 (Fragmentation)

**내부 단편화 (Internal Fragmentation)**
- 할당된 메모리 블록 내부의 낭비 공간
- 고정 크기 할당 시 발생 (페이징)
- 예: 4KB 페이지에 3KB만 사용

**외부 단편화 (External Fragmentation)**
- 할당/해제 반복으로 메모리가 조각화
- 가변 크기 할당 시 발생 (세그멘테이션)
- 전체 여유 공간은 충분하나 연속 공간 부족

## 동작 원리

### 주소 변환 과정 (Paging)

```
┌─────────────────────────────────────────────────────────────┐
│                        CPU                                  │
│   가상 주소: [페이지 번호 | 오프셋]                            │
└─────────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                        TLB                                  │
│              (Translation Lookaside Buffer)                 │
│                    캐시 히트? ─────────────────────┐         │
└─────────────────────────────────────────────────────────────┘
         │ Miss                                     │ Hit
         ▼                                          │
┌─────────────────────────────────────────────────────────────┐
│                   페이지 테이블                              │
│   페이지 번호 → 프레임 번호 조회                              │
│   (Page Table Base Register 사용)                           │
└─────────────────────────────────────────────────────────────┘
         │                                          │
         ▼                                          ▼
┌─────────────────────────────────────────────────────────────┐
│                      물리 주소                              │
│            [프레임 번호 | 오프셋] → 실제 메모리 접근          │
└─────────────────────────────────────────────────────────────┘
```

### 페이지 폴트 처리 과정

```
1. CPU가 가상 주소 접근
2. 페이지 테이블에서 해당 페이지의 valid bit 확인
3. valid bit = 0 (페이지 폴트 발생!)
4. OS 인터럽트 핸들러 호출
5. 디스크에서 해당 페이지 찾기
6. 빈 프레임에 페이지 적재 (없으면 페이지 교체)
7. 페이지 테이블 갱신
8. 중단된 명령어 재실행
```

### 페이지 교체 알고리즘

| 알고리즘 | 설명 | 특징 |
|---------|------|------|
| **FIFO** | 가장 먼저 들어온 페이지 교체 | 구현 간단, Belady's Anomaly 발생 가능 |
| **LRU** | 가장 오래 사용되지 않은 페이지 교체 | 성능 우수, 구현 복잡 |
| **LFU** | 가장 적게 사용된 페이지 교체 | 최근 적재된 페이지에 불리 |
| **Optimal** | 가장 오랫동안 사용되지 않을 페이지 교체 | 이론적 최적, 구현 불가 |
| **Clock** | FIFO + 참조 비트 활용 (Second Chance) | LRU 근사, 효율적 |

**LRU 구현 방식**

```java
// LinkedHashMap을 활용한 LRU 캐시
public class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LRUCache(int capacity) {
        // accessOrder=true: 접근 순서 기반 정렬
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity;
    }
}
```

### 스레싱 (Thrashing)

- **정의**: 페이지 폴트가 과도하게 발생하여 CPU가 실제 작업보다 페이지 교체에 더 많은 시간을 소비하는 현상
- **원인**: 프로세스에 할당된 프레임 수 부족
- **해결책**:
  - Working Set 모델: 프로세스가 필요한 최소 프레임 수 보장
  - Page Fault Frequency (PFF): 페이지 폴트 빈도 기반 프레임 할당

```
CPU 사용률
    │
    │     ╱╲
    │    ╱  ╲
    │   ╱    ╲_____ 스레싱
    │  ╱
    │ ╱
    └──────────────────→ 다중 프로그래밍 정도
```

## 예제 코드

### 메모리 영역 확인 (Linux)

```bash
# 프로세스의 메모리 맵 확인
cat /proc/[PID]/maps

# 출력 예시
# 주소범위             권한  오프셋  장치  inode  경로
# 00400000-00452000   r-xp  00000000 08:01 123456 /bin/bash  (Code)
# 00651000-00652000   r--p  00051000 08:01 123456 /bin/bash  (Data)
# 00652000-0065b000   rw-p  00052000 08:01 123456 /bin/bash  (Data)
# 7f8a1c000000-7f8a1c021000 rw-p (Heap)
# 7ffee8dfb000-7ffee8e1c000 rw-p [stack]
```

### Java 메모리 영역

```java
public class MemoryExample {
    // Method Area (메서드 영역) - 클래스 정보, static 변수
    private static final int CONSTANT = 100;
    private static int staticVar = 10;

    // Heap (힙) - 객체, 인스턴스 변수
    private String instanceVar = "Hello";

    public void method() {
        // Stack (스택) - 지역 변수, 매개변수, 리턴 주소
        int localVar = 20;

        // Heap에 객체 생성, Stack에 참조 저장
        Object obj = new Object();

        // Stack에 primitive 저장
        int[] arr = new int[10]; // 배열 객체는 Heap, 참조는 Stack
    }
}
```

### JVM 메모리 구조

```
┌─────────────────────────────────────────────────────────────┐
│                        JVM Memory                           │
├─────────────────────────────────────────────────────────────┤
│  Method Area (메서드 영역)                                    │
│  - 클래스 메타데이터, static 변수, 상수 풀                      │
├─────────────────────────────────────────────────────────────┤
│  Heap (힙)                                                  │
│  ┌────────────────────┬────────────────────────────────┐    │
│  │   Young Generation │      Old Generation            │    │
│  │  ┌─────┬─────────┐ │                                │    │
│  │  │ Eden│ Survivor│ │      (Tenured)                 │    │
│  │  └─────┴─────────┘ │                                │    │
│  └────────────────────┴────────────────────────────────┘    │
├─────────────────────────────────────────────────────────────┤
│  Stack (스택) - 스레드별 생성                                  │
│  - 지역 변수, 매개변수, 리턴 주소                               │
├─────────────────────────────────────────────────────────────┤
│  PC Register - 스레드별 생성                                  │
├─────────────────────────────────────────────────────────────┤
│  Native Method Stack - 네이티브 메서드 호출 시 사용             │
└─────────────────────────────────────────────────────────────┘
```

## 면접 예상 질문

### Q: 가상 메모리란 무엇이고, 왜 사용하나요?

**A**: 가상 메모리는 물리 메모리의 크기와 관계없이 프로세스에게 독립적인 주소 공간을 제공하는 메모리 관리 기법입니다.

**사용 이유**:
1. **메모리 추상화**: 각 프로세스가 전체 메모리를 독점하는 것처럼 동작
2. **메모리 보호**: 프로세스 간 메모리 영역 침범 방지
3. **메모리 확장**: 디스크를 활용하여 물리 메모리보다 큰 프로그램 실행 가능
4. **메모리 공유**: 공유 라이브러리를 여러 프로세스가 공유 가능

**동작 방식**: MMU(Memory Management Unit)가 가상 주소를 물리 주소로 변환하며, 필요한 페이지만 물리 메모리에 적재하고 나머지는 디스크(Swap 영역)에 저장합니다.

---

### Q: 페이징과 세그멘테이션의 차이점은 무엇인가요?

**A**:

| 구분 | 페이징 | 세그멘테이션 |
|------|--------|-------------|
| 분할 단위 | 고정 크기 (Page) | 가변 크기 (Segment) |
| 분할 기준 | 물리적 (크기 기준) | 논리적 (용도 기준) |
| 단편화 | 내부 단편화 | 외부 단편화 |
| 테이블 | 페이지 테이블 | 세그먼트 테이블 |
| 주소 구조 | (페이지 번호, 오프셋) | (세그먼트 번호, 오프셋) |

현대 운영체제는 대부분 **페이징**을 기본으로 사용하며, 일부 시스템에서 세그멘테이션과 결합한 **페이지드 세그멘테이션**을 사용합니다. 페이징이 선호되는 이유는 고정 크기로 관리가 단순하고, 외부 단편화가 발생하지 않기 때문입니다.

---

### Q: 페이지 폴트가 발생하면 어떤 과정이 일어나나요?

**A**: 페이지 폴트는 접근하려는 페이지가 물리 메모리에 없을 때 발생합니다.

**처리 과정**:
1. **트랩 발생**: CPU가 페이지 폴트 인터럽트 발생
2. **유효성 검사**: OS가 해당 접근이 valid한지 확인 (잘못된 접근이면 프로세스 종료)
3. **빈 프레임 확보**:
   - 빈 프레임이 있으면 사용
   - 없으면 **페이지 교체 알고리즘**으로 victim 페이지 선택
   - victim이 수정되었으면(dirty bit=1) 디스크에 먼저 기록
4. **페이지 적재**: 디스크에서 해당 페이지를 빈 프레임에 로드
5. **테이블 갱신**: 페이지 테이블의 valid bit을 1로 설정
6. **명령어 재실행**: 중단된 명령어부터 다시 실행

**성능 영향**: 페이지 폴트는 디스크 I/O를 수반하므로 매우 느림 (약 10ms). 페이지 폴트율이 높아지면 **스레싱**이 발생하여 시스템 성능이 급격히 저하됩니다.

## 참고 자료

- Operating System Concepts (Silberschatz)
- Modern Operating Systems (Tanenbaum)
- [Linux Memory Management](https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html)
