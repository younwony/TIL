# IPC (Inter-Process Communication)

> `[3] 중급` · 선수 지식: [프로세스와 스레드](./process-vs-thread.md)

> 프로세스 간에 데이터를 교환하는 메커니즘

`#IPC` `#InterProcessCommunication` `#프로세스간통신` `#파이프` `#Pipe` `#NamedPipe` `#FIFO` `#메시지큐` `#MessageQueue` `#공유메모리` `#SharedMemory` `#소켓` `#Socket` `#시그널` `#Signal` `#세마포어` `#Semaphore` `#mmap` `#Unix도메인소켓` `#UnixDomainSocket` `#프로듀서컨슈머` `#ProducerConsumer`

## 왜 알아야 하는가?

프로세스는 독립된 메모리 공간을 가지므로 직접 데이터를 공유할 수 없습니다. 하지만 현대 시스템에서는 프로세스 간 협력이 필수입니다. 웹 서버와 DB, 마이크로서비스 간 통신 등 모두 IPC를 기반으로 합니다. 백엔드 개발자라면 다양한 IPC 방법의 특성을 이해하고 적절히 선택할 수 있어야 합니다.

## 핵심 개념

- **IPC (Inter-Process Communication)**: 프로세스 간 데이터 교환 메커니즘
- **파이프 (Pipe)**: 단방향 데이터 스트림
- **공유 메모리 (Shared Memory)**: 여러 프로세스가 같은 메모리 영역 접근
- **메시지 큐 (Message Queue)**: 메시지 단위로 비동기 통신
- **소켓 (Socket)**: 네트워크 기반 통신, 다른 머신과도 통신 가능

## 쉽게 이해하기

**IPC**를 사무실 내 부서 간 소통에 비유할 수 있습니다.

- **파이프**: 한 방향으로만 서류 전달하는 튜브
- **공유 메모리**: 공용 화이트보드에 메모 남기기
- **메시지 큐**: 공용 우편함에 편지 넣기
- **소켓**: 전화 통화 (양방향, 원격 가능)
- **시그널**: 비상벨 (긴급 알림)

## 상세 설명

### IPC 방법 비교

| 방법 | 통신 방향 | 관계 | 속도 | 복잡도 | 적합한 상황 |
|------|----------|------|------|--------|------------|
| 파이프 | 단방향 | 부모-자식 | 빠름 | 낮음 | 간단한 데이터 전달 |
| Named Pipe | 단방향 | 무관 | 빠름 | 낮음 | 관계없는 프로세스 |
| 공유 메모리 | 양방향 | 무관 | 가장 빠름 | 높음 | 대용량 데이터 |
| 메시지 큐 | 양방향 | 무관 | 중간 | 중간 | 비동기 메시지 |
| 소켓 | 양방향 | 무관/원격 | 느림 | 중간 | 네트워크 통신 |
| 시그널 | 단방향 | 무관 | 매우 빠름 | 낮음 | 이벤트 알림 |

### 파이프 (Pipe)

**특징**: 부모-자식 프로세스 간 단방향 통신

```
┌─────────────┐  데이터  ┌─────────────┐
│   부모      │ ───────► │   자식      │
│  프로세스   │  (파이프) │  프로세스   │
└─────────────┘          └─────────────┘
     쓰기 끝                 읽기 끝
```

```c
// C 파이프 예시
int fd[2];
pipe(fd);  // fd[0]: 읽기, fd[1]: 쓰기

if (fork() == 0) {
    // 자식 프로세스
    close(fd[1]);  // 쓰기 끝 닫기
    read(fd[0], buffer, size);
} else {
    // 부모 프로세스
    close(fd[0]);  // 읽기 끝 닫기
    write(fd[1], "Hello", 5);
}
```

**셸에서의 파이프**:
```bash
ls -l | grep ".txt" | wc -l
# ls의 출력 → grep의 입력 → wc의 입력
```

### Named Pipe (FIFO)

**특징**: 파일 시스템에 존재, 관계없는 프로세스 간 통신

```bash
# 생성
mkfifo /tmp/myfifo

# 프로세스 A (쓰기)
echo "Hello" > /tmp/myfifo

# 프로세스 B (읽기)
cat /tmp/myfifo
```

### 공유 메모리 (Shared Memory)

**특징**: 가장 빠른 IPC, 여러 프로세스가 같은 메모리 영역 접근

```
┌─────────────┐          ┌─────────────┐
│  프로세스 A │          │  프로세스 B │
│             │          │             │
│   가상메모리 │          │   가상메모리 │
│      │      │          │      │      │
└──────┼──────┘          └──────┼──────┘
       │                        │
       └────────┬───────────────┘
                │
         ┌──────▼──────┐
         │  공유 메모리  │
         │  (물리 메모리) │
         └─────────────┘
```

```c
// POSIX 공유 메모리
int fd = shm_open("/myshm", O_CREAT | O_RDWR, 0666);
ftruncate(fd, SIZE);
void* ptr = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

// 데이터 쓰기
sprintf(ptr, "Hello from process A");

// 다른 프로세스에서 읽기
printf("Message: %s\n", (char*)ptr);
```

**주의**: 동기화 필요 (세마포어/뮤텍스)

### 메시지 큐 (Message Queue)

**특징**: 메시지 단위 비동기 통신, 우선순위 지원

```
프로세스 A         메시지 큐         프로세스 B
    │                                   │
    │  ┌─────────────────┐              │
    ├──►│ [msg1][msg2][msg3] │◄─────────┤
    │  └─────────────────┘              │
    │      (FIFO 또는 우선순위)          │
```

```c
// POSIX 메시지 큐
mqd_t mq = mq_open("/myqueue", O_CREAT | O_RDWR, 0666, NULL);

// 전송
mq_send(mq, "Hello", 6, 0);

// 수신
char buffer[256];
mq_receive(mq, buffer, 256, NULL);
```

### 소켓 (Socket)

**특징**: 네트워크 통신의 기반, 다른 머신과도 통신 가능

**종류**:

| 유형 | 프로토콜 | 특징 |
|------|---------|------|
| TCP 소켓 | TCP/IP | 신뢰성, 연결 지향 |
| UDP 소켓 | UDP/IP | 비연결, 빠름 |
| Unix 도메인 소켓 | 로컬 | 같은 머신, 빠름 |

```
┌─────────────┐                    ┌─────────────┐
│   서버      │◄───────────────────│   클라이언트 │
│  socket()   │                    │  socket()   │
│  bind()     │                    │             │
│  listen()   │                    │  connect()  │
│  accept()   │◄───── 연결 ────────│             │
│  read()     │◄───── 데이터 ──────│  write()    │
│  write()    │────── 데이터 ─────►│  read()     │
│  close()    │                    │  close()    │
└─────────────┘                    └─────────────┘
```

### 시그널 (Signal)

**특징**: 프로세스에 이벤트 알림, 데이터 전달 불가

| 시그널 | 번호 | 설명 |
|--------|------|------|
| SIGINT | 2 | Ctrl+C 인터럽트 |
| SIGKILL | 9 | 강제 종료 (무시 불가) |
| SIGTERM | 15 | 정상 종료 요청 |
| SIGCHLD | 17 | 자식 프로세스 종료 |
| SIGUSR1/2 | 10/12 | 사용자 정의 |

```c
// 시그널 핸들러 등록
void handler(int sig) {
    printf("Received signal %d\n", sig);
}

signal(SIGUSR1, handler);

// 시그널 전송
kill(pid, SIGUSR1);
```

```bash
# 셸에서 시그널 전송
kill -9 1234      # SIGKILL
kill -TERM 1234   # SIGTERM
```

## 트레이드오프

| 방법 | 장점 | 단점 |
|------|------|------|
| 파이프 | 단순, 커널 관리 | 단방향, 부모-자식만 |
| 공유 메모리 | 가장 빠름 | 동기화 필요, 복잡 |
| 메시지 큐 | 비동기, 우선순위 | 메시지 크기 제한 |
| 소켓 | 범용, 네트워크 | 오버헤드 |
| 시그널 | 간단한 알림 | 데이터 전달 불가 |

## 면접 예상 질문

### Q: 공유 메모리가 가장 빠른 이유는?

A: 공유 메모리는 **커널을 거치지 않고** 직접 메모리에 접근합니다. 파이프나 메시지 큐는 데이터를 커널 버퍼에 복사하고 다시 사용자 공간으로 복사하는 **2번의 복사**가 필요하지만, 공유 메모리는 **복사 없이** 같은 물리 메모리를 직접 읽고 씁니다. **단점**: 동기화를 직접 구현해야 합니다 (세마포어, 뮤텍스).

### Q: 파이프와 소켓의 차이는?

A: **파이프**는 같은 머신의 부모-자식 프로세스 간 단방향 통신입니다. **소켓**은 네트워크를 통해 다른 머신과도 양방향 통신이 가능합니다. **성능**: 같은 머신에서는 파이프가 더 빠르고, Unix 도메인 소켓이 그 다음입니다. **사용처**: 단순한 파이프라인은 파이프, 서버-클라이언트 구조는 소켓을 사용합니다.

### Q: 시그널은 언제 사용하나요?

A: **이벤트 알림**에 사용합니다. 데이터 전달은 불가능하고, "이 이벤트가 발생했다"만 알립니다. **예시**: SIGTERM으로 Graceful Shutdown 요청, SIGCHLD로 자식 프로세스 종료 감지, SIGUSR1으로 로그 레벨 변경 등. **주의**: 시그널 핸들러는 비동기로 실행되므로 async-signal-safe 함수만 사용해야 합니다.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [프로세스와 스레드](./process-vs-thread.md) | 선수 지식 | [2] 입문 |
| [동기화](./synchronization.md) | 공유 메모리 사용 시 | [3] 중급 |

## 참고 자료

- Advanced Programming in the UNIX Environment - W. Richard Stevens
- The Linux Programming Interface - Michael Kerrisk
