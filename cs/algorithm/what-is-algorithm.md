# 알고리즘이란

> `[1] 정의` · 선수 지식 없음

> 알고리즘은 **주어진 문제를 해결하기 위한 명확하고 유한한 단계의 절차**이다.

`#알고리즘` `#Algorithm` `#문제해결` `#ProblemSolving` `#코딩테스트` `#CodingTest` `#자료구조` `#DataStructure` `#효율성` `#Efficiency` `#절차` `#Procedure` `#컴퓨터과학` `#CS` `#프로그래밍` `#Programming` `#입력` `#출력` `#정확성` `#유한성` `#명확성` `#의사코드` `#Pseudocode` `#플로우차트` `#Flowchart` `#복잡도` `#최적화` `#Optimization`

## 왜 알아야 하는가?

- **실무**: 같은 기능도 알고리즘에 따라 성능이 천 배 이상 차이난다. "왜 이 코드가 느린가?"에 대한 답은 알고리즘 분석에서 시작한다.
- **면접**: 모든 기술 면접에서 알고리즘 문제가 출제된다. 알고리즘적 사고력은 개발자의 기본 역량으로 간주된다.
- **기반 지식**: 정렬, 탐색, 자료구조 선택 등 모든 CS 주제의 기반이 된다. 알고리즘을 모르면 "왜 HashMap이 빠른가?"를 설명할 수 없다.

## 핵심 개념

- **입력(Input)**: 알고리즘이 처리할 데이터 (0개 이상)
- **출력(Output)**: 알고리즘이 생성하는 결과 (1개 이상)
- **명확성(Definiteness)**: 각 단계가 모호하지 않고 명확해야 함
- **유한성(Finiteness)**: 유한한 단계 후 반드시 종료되어야 함
- **효과성(Effectiveness)**: 각 단계가 실행 가능해야 함

## 쉽게 이해하기

**알고리즘**을 **요리 레시피**에 비유할 수 있습니다.

라면을 끓이는 레시피를 생각해보세요:
1. 물 550ml를 냄비에 넣는다 (입력)
2. 물이 끓으면 면과 스프를 넣는다 (단계)
3. 4분 30초 동안 끓인다 (유한성)
4. 완성된 라면을 그릇에 담는다 (출력)

이 레시피는:
- **명확함**: "물이 끓으면"이라는 조건이 명확
- **유한함**: 4분 30초 후 종료
- **실행 가능**: 누구나 따라할 수 있음

프로그래밍에서 알고리즘도 마찬가지입니다. 컴퓨터가 따라할 수 있는 명확한 레시피를 작성하는 것이죠.

## 상세 설명

### 알고리즘의 조건

알고리즘이 되려면 5가지 조건을 만족해야 합니다:

| 조건 | 설명 | 위반 예시 |
|------|------|----------|
| 입력 | 외부에서 0개 이상의 데이터 제공 | - |
| 출력 | 1개 이상의 결과 생성 | 아무것도 반환하지 않는 함수 |
| 명확성 | 각 단계가 모호하지 않음 | "적당히 섞는다" |
| 유한성 | 유한한 단계 후 종료 | 무한 루프 |
| 효과성 | 모든 단계가 실행 가능 | "0으로 나눈다" |

**왜 이 조건들이 필요한가?**

컴퓨터는 사람처럼 "대충", "적당히"를 이해하지 못합니다. 모든 단계가 명확하고, 반드시 끝나며, 실행 가능해야 컴퓨터가 처리할 수 있습니다.

### 알고리즘 vs 프로그램

| 구분 | 알고리즘 | 프로그램 |
|------|----------|----------|
| 정의 | 문제 해결 절차 | 알고리즘을 코드로 구현한 것 |
| 표현 | 자연어, 의사코드, 순서도 | 프로그래밍 언어 |
| 실행 | 직접 실행 불가 | 컴퓨터에서 실행 가능 |
| 예시 | "두 수 중 큰 값 반환" | `return Math.max(a, b);` |

**왜 구분해야 하는가?**

알고리즘은 언어에 독립적인 **아이디어**이고, 프로그램은 특정 언어로 작성된 **구현**입니다. 좋은 알고리즘을 먼저 설계한 후 프로그램으로 옮겨야 합니다.

### 알고리즘의 표현 방법

#### 1. 자연어 (Natural Language)

```
1. 배열의 첫 번째 원소를 최댓값으로 설정한다
2. 배열을 순회하면서 현재 원소가 최댓값보다 크면 최댓값을 갱신한다
3. 최댓값을 반환한다
```

**장점**: 이해하기 쉬움
**단점**: 모호할 수 있음

#### 2. 의사코드 (Pseudocode)

```
function findMax(array):
    max = array[0]
    for each element in array:
        if element > max:
            max = element
    return max
```

**장점**: 명확하면서도 언어 독립적
**단점**: 표준화된 문법이 없음

#### 3. 순서도 (Flowchart)

```
┌─────────┐
│  시작   │
└────┬────┘
     ▼
┌─────────────┐
│ max = arr[0]│
└──────┬──────┘
       ▼
   ┌───────┐    아니오
   │ 다음   ├──────────┐
   │ 원소?  │          │
   └───┬───┘          │
       │ 예           │
       ▼              │
  ┌─────────┐         │
  │원소>max?│         │
  └────┬────┘         │
       │ 예           │
       ▼              │
  ┌─────────┐         │
  │max=원소 │         │
  └────┬────┘         │
       └──────────────┤
                      ▼
               ┌───────────┐
               │ max 반환  │
               └───────────┘
```

**장점**: 흐름을 시각적으로 파악 가능
**단점**: 복잡한 알고리즘 표현이 어려움

### 좋은 알고리즘의 기준

| 기준 | 설명 | 예시 |
|------|------|------|
| **정확성** | 올바른 결과를 반환 | 모든 테스트 케이스 통과 |
| **효율성** | 시간/공간을 적게 사용 | O(N) vs O(N²) |
| **가독성** | 이해하기 쉬움 | 명확한 변수명, 주석 |
| **재사용성** | 다른 문제에도 적용 가능 | 범용적인 정렬 함수 |

**왜 효율성이 중요한가?**

```
데이터 1만 개 처리 시:
- O(N) 알고리즘: 1만 번 연산 → 즉시 완료
- O(N²) 알고리즘: 1억 번 연산 → 수 초 소요
- O(2^N) 알고리즘: 사실상 불가능
```

데이터가 커질수록 알고리즘 선택이 성능에 결정적 영향을 미칩니다.

## 알고리즘의 분류

### 설계 기법에 따른 분류

| 기법 | 설명 | 대표 알고리즘 |
|------|------|--------------|
| **분할 정복** | 문제를 작은 문제로 나누어 해결 | 병합 정렬, 퀵 정렬 |
| **동적 프로그래밍** | 작은 문제의 답을 저장하여 재사용 | 피보나치, 배낭 문제 |
| **그리디** | 매 순간 최적의 선택 | 거스름돈, 프림 알고리즘 |
| **백트래킹** | 가능성 없는 경로 가지치기 | N-Queen, 미로 탐색 |
| **브루트포스** | 모든 경우의 수 탐색 | 순열 생성 |

### 문제 유형에 따른 분류

| 유형 | 설명 | 예시 |
|------|------|------|
| **정렬** | 데이터를 특정 순서로 배열 | 버블, 퀵, 병합 정렬 |
| **탐색** | 원하는 데이터 찾기 | 이진 탐색, DFS, BFS |
| **그래프** | 정점과 간선 문제 | 최단 경로, MST |
| **문자열** | 문자열 처리 | KMP, 라빈-카프 |

## 예제: 최댓값 찾기 알고리즘

### 문제
배열에서 가장 큰 값을 찾아라.

### 의사코드
```
function findMax(array):
    if array is empty:
        return error

    max = array[0]

    for i = 1 to array.length - 1:
        if array[i] > max:
            max = array[i]

    return max
```

### Java 구현

```java
public class MaxFinder {

    public static int findMax(int[] array) {
        if (array == null || array.length == 0) {
            throw new IllegalArgumentException("배열이 비어있습니다");
        }

        int max = array[0];  // 첫 번째 원소를 최댓값으로 설정

        for (int i = 1; i < array.length; i++) {
            if (array[i] > max) {
                max = array[i];  // 더 큰 값 발견 시 갱신
            }
        }

        return max;
    }

    public static void main(String[] args) {
        int[] numbers = {3, 7, 2, 9, 1, 5};
        System.out.println(findMax(numbers));  // 출력: 9
    }
}
```

### 분석

- **시간복잡도**: O(N) - 배열을 한 번 순회
- **공간복잡도**: O(1) - 추가 메모리 사용 없음
- **정확성**: 모든 원소를 확인하므로 최댓값을 반드시 찾음

## 면접 예상 질문

### Q1: 알고리즘과 자료구조의 관계는?

A: 알고리즘은 **문제를 해결하는 방법**이고, 자료구조는 **데이터를 저장하는 방식**입니다. 둘은 밀접하게 연관되어 있습니다.

**왜냐하면** 같은 알고리즘이라도 자료구조에 따라 성능이 달라지기 때문입니다. 예를 들어:
- 탐색: 배열 O(N) vs 해시테이블 O(1)
- 삽입: 배열 O(N) vs 연결리스트 O(1)

**따라서** 문제에 적합한 자료구조를 선택하는 것이 효율적인 알고리즘 구현의 핵심입니다.

### Q2: 알고리즘의 효율성은 어떻게 측정하나요?

A: **시간복잡도**와 **공간복잡도**로 측정합니다.

- **시간복잡도**: 입력 크기에 따른 연산 횟수 (Big-O 표기법)
- **공간복잡도**: 입력 크기에 따른 메모리 사용량

**왜 Big-O를 사용하나?** 실제 실행 시간은 하드웨어에 따라 다르지만, Big-O는 **입력 크기 증가에 따른 성능 변화 추세**를 나타내므로 하드웨어 독립적인 비교가 가능합니다.

### Q3: 좋은 알고리즘을 설계하는 방법은?

A: 다음 단계를 따릅니다:

1. **문제 이해**: 입력, 출력, 제약조건 파악
2. **예시 분석**: 작은 예시로 패턴 발견
3. **브루트포스**: 가장 단순한 방법 먼저 생각
4. **최적화**: 불필요한 연산 제거, 적합한 자료구조 선택
5. **검증**: 엣지 케이스, 시간/공간복잡도 확인

**왜 브루트포스부터 시작하나?** 일단 동작하는 해결책을 만든 후 최적화하는 것이 효율적입니다. 처음부터 최적화하려다 문제를 잘못 이해하는 경우가 많습니다.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [시간/공간 복잡도](./time-complexity.md) | 알고리즘 효율성 분석 (TODO) | [1] 정의 |
| [Sort](./sort.md) | 대표적인 알고리즘 유형 | [2] 입문 |
| [Search](./search.md) | 대표적인 알고리즘 유형 | [2] 입문 |
| [자료구조란](../data-structure/what-is-data-structure.md) | 알고리즘과 함께 학습 (TODO) | [1] 정의 |

## 참고 자료

- [Introduction to Algorithms (CLRS)](https://mitpress.mit.edu/books/introduction-algorithms-third-edition) - 알고리즘 바이블
- [Big-O Cheat Sheet](https://www.bigocheatsheet.com/) - 복잡도 참고 자료
- [Visualgo](https://visualgo.net/) - 알고리즘 시각화
