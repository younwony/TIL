# 그리디 알고리즘 (Greedy Algorithm)

> `[3] 중급` · 선수 지식: [알고리즘이란](./what-is-algorithm.md), [시간 복잡도](./time-complexity.md)

> 매 순간 최적의 선택을 하여 전체 최적해를 찾는 알고리즘 설계 기법

`#그리디` `#Greedy` `#탐욕알고리즘` `#GreedyAlgorithm` `#최적부분구조` `#OptimalSubstructure` `#탐욕선택속성` `#GreedyChoice` `#다익스트라` `#Dijkstra` `#크루스칼` `#Kruskal` `#프림` `#Prim` `#활동선택` `#ActivitySelection` `#허프만` `#Huffman` `#동전교환` `#CoinChange`

## 왜 알아야 하는가?

그리디는 구현이 간단하고 효율적입니다. 최적해를 보장하는 경우에 매우 강력하며, 코딩 테스트에서 자주 출제됩니다. 단, 그리디가 최적해를 보장하는지 증명할 수 있어야 합니다.

## 핵심 개념

- **탐욕 선택 속성**: 현재 최선의 선택이 전체 최적해에 포함됨
- **최적 부분 구조**: 부분 문제의 최적해가 전체 최적해를 구성
- **지역 최적 → 전역 최적**: 매 순간의 최선이 전체의 최선이 됨

## 쉽게 이해하기

**그리디**를 뷔페에서 음식 담기에 비유할 수 있습니다.

가장 맛있어 보이는 음식부터 담는다:
- 매 순간 가장 좋아 보이는 선택
- 뒤돌아보지 않음 (이미 담은 건 변경 불가)
- 대부분 만족스러운 결과 (항상 최적은 아닐 수 있음)

## 상세 설명

### 그리디 vs DP vs 완전 탐색

| 기법 | 선택 방식 | 최적해 보장 | 시간 복잡도 |
|------|----------|------------|------------|
| 완전 탐색 | 모든 경우 | O | 높음 |
| DP | 부분 문제 저장 | O | 중간 |
| 그리디 | 매 순간 최선 | △ (조건 필요) | 낮음 |

### 예시 1: 동전 교환

**그리디가 최적인 경우** (한국 동전: 500, 100, 50, 10원):

```
거스름돈 1260원:
500원 × 2 = 1000원 (남은 260원)
100원 × 2 = 200원 (남은 60원)
50원 × 1 = 50원 (남은 10원)
10원 × 1 = 10원 (남은 0원)
→ 총 6개 (최적)
```

**그리디가 최적이 아닌 경우** (동전: 1, 3, 4원):

```
거스름돈 6원:
그리디: 4 + 1 + 1 = 3개
최적: 3 + 3 = 2개  ← DP 필요
```

### 예시 2: 활동 선택 문제 (Activity Selection)

```
활동: (시작, 종료)
A: (1, 4)
B: (3, 5)
C: (0, 6)
D: (5, 7)
E: (3, 9)
F: (5, 9)
G: (6, 10)
H: (8, 11)

그리디: 종료 시간이 빠른 순으로 선택
1. A (1-4) 선택
2. B (3-5) 충돌 → 스킵
3. C (0-6) 충돌 → 스킵
4. D (5-7) 선택
5. ...
6. H (8-11) 선택

결과: A, D, H (최대 3개)
```

```java
int activitySelection(int[][] activities) {
    // 종료 시간 기준 정렬
    Arrays.sort(activities, (a, b) -> a[1] - b[1]);

    int count = 1;
    int lastEnd = activities[0][1];

    for (int i = 1; i < activities.length; i++) {
        if (activities[i][0] >= lastEnd) {
            count++;
            lastEnd = activities[i][1];
        }
    }
    return count;
}
```

### 예시 3: 허프만 코딩 (Huffman Coding)

빈도가 높은 문자에 짧은 코드 할당:

```
문자 빈도: a:5, b:9, c:12, d:13, e:16, f:45

그리디: 가장 작은 두 노드를 계속 합침
1. a(5) + b(9) = 14
2. c(12) + d(13) = 25
3. 14 + e(16) = 30
4. 25 + 30 = 55
5. f(45) + 55 = 100

결과 코드:
f: 0, c: 100, d: 101, a: 1100, b: 1101, e: 111
```

### 그리디 적용 가능 조건

1. **탐욕 선택 속성**: 현재 최선의 선택이 최종 최적해에 포함됨
2. **최적 부분 구조**: 부분 문제의 최적해로 전체 최적해 구성 가능

## 트레이드오프

| 장점 | 단점 |
|------|------|
| 구현 간단 | 항상 최적해 보장 X |
| 효율적 | 증명 필요 |
| 직관적 | 반례 찾기 어려움 |

## 면접 예상 질문

### Q: 그리디 알고리즘이 최적해를 보장하는 조건은?

A: **두 가지 조건**이 필요합니다. (1) **탐욕 선택 속성**: 현재 최선의 선택이 최종 최적해에 반드시 포함 (2) **최적 부분 구조**: 부분 문제의 최적해가 전체 최적해를 구성. **증명 방법**: "그리디 선택을 포함한 최적해가 존재함"을 증명하거나, "그리디 선택을 다른 선택으로 바꿔도 더 나빠지지 않음"을 보여야 합니다.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [분할 정복](./divide-and-conquer.md) | 알고리즘 설계 기법 | [3] 중급 |
| [백트래킹](./backtracking.md) | 알고리즘 설계 기법 | [3] 중급 |

## 참고 자료

- Introduction to Algorithms (CLRS)
- [Greedy Algorithms - GeeksforGeeks](https://www.geeksforgeeks.org/greedy-algorithms/)
