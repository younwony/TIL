# HTTPS와 TLS

> HTTPS는 HTTP 통신을 TLS/SSL로 암호화하여 기밀성, 무결성, 인증을 보장하는 프로토콜

## 핵심 개념

- **HTTPS**: HTTP + TLS/SSL, 443 포트 사용
- **TLS (Transport Layer Security)**: 전송 계층 보안 프로토콜, SSL의 후속 버전
- **핸드셰이크**: 클라이언트와 서버가 암호화 방식과 키를 협상하는 과정
- **인증서**: 서버의 공개키와 신원 정보를 담은 디지털 문서, CA가 서명
- **PKI (Public Key Infrastructure)**: 인증서 기반 신뢰 체계

## 쉽게 이해하기

**HTTPS**를 등기우편에 비유할 수 있습니다.

일반 HTTP는 엽서로 편지를 보내는 것과 같습니다. 배달 과정에서 누구나 내용을 읽을 수 있고(도청), 내용을 바꿀 수도 있으며(변조), 가짜 발신인으로 보낼 수도 있습니다(위장).

HTTPS는:
- **암호화된 봉투**: 편지를 암호화하여 봉투에 넣음 (기밀성). 받는 사람만 열쇠(개인키)로 열 수 있음.
- **봉인**: 봉투에 봉인 스티커를 붙임 (무결성). 누군가 뜯어보면 봉인이 깨져서 변조를 탐지.
- **신분증**: 발신인의 신분증 사본을 동봉 (인증). 정부(CA)가 발급한 신분증이므로 신뢰 가능.

**TLS 핸드셰이크**는 두 사람이 암호를 정하는 과정입니다.

"우리 어떤 암호 체계 쓸까?"(암호 스위트 협상) → "내 공개키야"(인증서 전달) → "이 공개키로 비밀 키를 암호화해서 보낼게"(키 교환) → "앞으로 이 비밀 키로 대화하자"(암호화 통신 시작).

**인증서**는 정부가 발급한 신분증입니다.

은행에서 본인 확인 시 신분증을 보여주면, 은행 직원은 정부를 신뢰하기 때문에 신분증을 믿습니다. 마찬가지로 서버가 인증서를 보여주면, 브라우저는 CA(인증 기관)를 신뢰하기 때문에 인증서를 믿습니다. CA의 서명이 있어야 위조 불가능합니다.

## 상세 설명

### HTTPS의 필요성

**왜 HTTP는 안전하지 않은가?**

HTTP는 평문으로 데이터를 전송하므로 다음 공격에 취약합니다:

1. **도청 (Eavesdropping)**: 네트워크 경로의 누구나 패킷을 읽을 수 있음
   - 공용 Wi-Fi에서 로그인 시 비밀번호 유출
   - ISP, 중간 라우터가 트래픽 감시

2. **변조 (Tampering)**: 중간자가 패킷 내용을 수정
   - 광고 삽입, 악성 스크립트 주입
   - 송금 금액 변경

3. **위장 (Impersonation)**: 가짜 서버가 정상 서버인 척
   - 피싱 사이트가 은행 사이트로 위장
   - DNS 스푸핑, ARP 스푸핑

**HTTPS는 어떻게 해결하는가?**

1. **기밀성 (Confidentiality)**: 대칭키 암호화(AES)로 데이터 암호화
2. **무결성 (Integrity)**: HMAC으로 변조 탐지
3. **인증 (Authentication)**: 인증서로 서버 신원 확인

### TLS/SSL

**SSL vs TLS**:
- **SSL (Secure Sockets Layer)**: Netscape가 개발 (SSL 1.0, 2.0, 3.0)
- **TLS (Transport Layer Security)**: IETF가 SSL 3.0을 기반으로 표준화
  - TLS 1.0 (1999) ≈ SSL 3.1
  - TLS 1.1 (2006)
  - TLS 1.2 (2008) ← 현재 주로 사용
  - TLS 1.3 (2018) ← 최신, 성능 개선

**왜 SSL이라는 용어를 여전히 사용하는가?**

역사적 이유로 "SSL 인증서", "SSL/TLS"라고 부르지만, 실제로는 모두 TLS를 사용합니다. SSL 3.0 이하는 취약점이 발견되어 더 이상 사용하지 않습니다.

### TLS 1.2 핸드셰이크

**전체 흐름**:

```
Client                                Server
  |                                     |
  |------- (1) ClientHello ----------->|
  |  - TLS 버전                         |
  |  - 지원하는 암호 스위트 목록         |
  |  - 랜덤 값 (Client Random)          |
  |                                     |
  |<------ (2) ServerHello ------------|
  |  - 선택한 TLS 버전                  |
  |  - 선택한 암호 스위트                |
  |  - 랜덤 값 (Server Random)          |
  |                                     |
  |<------ (3) Certificate ------------|
  |  - 서버 인증서 (공개키 포함)         |
  |                                     |
  |<------ (4) ServerHelloDone --------|
  |                                     |
  |------- (5) ClientKeyExchange ------>|
  |  - Pre-Master Secret (서버 공개키로 암호화) |
  |                                     |
  |------- (6) ChangeCipherSpec ------->|
  |  - "이제부터 암호화 통신 시작"       |
  |                                     |
  |------- (7) Finished --------------->|
  |  - 핸드셰이크 메시지 해시 (검증용)   |
  |                                     |
  |<------ (8) ChangeCipherSpec --------|
  |<------ (9) Finished ----------------|
  |                                     |
  |======= 암호화된 HTTP 통신 시작 ======|
```

**단계별 상세 설명**:

**1) ClientHello**:
클라이언트가 지원하는 암호 스위트(Cipher Suite) 목록을 전송합니다.

```
암호 스위트 예: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
- ECDHE: 키 교환 알고리즘 (Elliptic Curve Diffie-Hellman Ephemeral)
- RSA: 인증 알고리즘 (서버 인증서)
- AES_128_GCM: 대칭키 암호화 알고리즘
- SHA256: 해시 알고리즘 (무결성 검증)
```

**왜 여러 개를 보내는가?**

서버가 모든 암호 스위트를 지원하지 않을 수 있으므로, 클라이언트는 지원 목록을 보내고 서버가 선택합니다. 우선순위가 높은 순서로 나열하여 가장 강력한 암호화를 협상합니다.

**2-4) ServerHello, Certificate, ServerHelloDone**:
서버가 암호 스위트를 선택하고, 인증서를 전송합니다.

**왜 인증서를 전송하는가?**

클라이언트가 서버의 공개키를 안전하게 받기 위해서입니다. 인증서가 없으면 중간자가 자신의 공개키를 보낼 수 있습니다(Man-in-the-Middle). 인증서는 CA가 서명하므로 위조 불가능합니다.

**5) ClientKeyExchange**:
클라이언트가 `Pre-Master Secret` (48바이트 랜덤 값)을 생성하여 서버의 공개키로 암호화해서 전송합니다.

**왜 Pre-Master Secret을 만드는가?**

클라이언트와 서버가 같은 대칭키를 공유해야 암호화 통신이 가능합니다. Pre-Master Secret을 기반으로 양측이 동일한 Master Secret을 계산합니다:

```
Master Secret = PRF(Pre-Master Secret, "master secret", Client Random + Server Random)
```

**왜 Client/Server Random도 사용하는가?**

재전송 공격(Replay Attack)을 방어하기 위해서입니다. 매 연결마다 다른 랜덤 값을 사용하므로, 이전 통신을 재사용할 수 없습니다.

**6-7) ChangeCipherSpec, Finished**:
클라이언트가 "이제부터 암호화 시작"을 알리고, 핸드셰이크 메시지의 해시 값을 보냅니다.

**왜 Finished 메시지를 보내는가?**

핸드셰이크 과정이 변조되지 않았는지 검증하기 위해서입니다. 모든 핸드셰이크 메시지를 해시하여 암호화된 값을 보내면, 서버가 동일하게 계산하여 비교합니다. 중간자가 암호 스위트를 약한 것으로 변조했다면 해시 값이 다르므로 탐지됩니다.

**8-9) 서버도 동일하게 응답**

**10) 암호화된 HTTP 통신 시작**

### TLS 1.3 핸드셰이크 (개선)

**TLS 1.2의 문제점**:
- 핸드셰이크에 2-RTT(Round-Trip Time) 필요 → 느림
- 취약한 암호 스위트 지원 (하위 호환성) → 다운그레이드 공격 가능

**TLS 1.3 개선사항**:

```
Client                                Server
  |                                     |
  |------- (1) ClientHello ----------->|
  |  - 지원 암호 스위트                  |
  |  - 키 교환 파라미터 (미리 전송!)     |
  |                                     |
  |<------ (2) ServerHello ------------|
  |<------ Certificate -----------------|
  |<------ Finished --------------------|
  |  (암호화된 통신 즉시 시작 가능!)     |
  |                                     |
  |------- Finished ------------------->|
  |                                     |
  |======= 1-RTT로 단축! ================|
```

**왜 빨라졌는가?**

TLS 1.2는 ClientHello → ServerHello → ClientKeyExchange로 2번 왕복해야 했지만, TLS 1.3은 ClientHello에 키 교환 파라미터를 미리 포함하여 1번 왕복으로 완료합니다.

**0-RTT (세션 재개 시)**:
이전에 연결했던 서버라면 저장된 키로 즉시 데이터 전송 가능 (핸드셰이크 생략).

**추가 개선**:
- 취약한 암호 스위트 제거 (RC4, MD5, SHA-1 등)
- Forward Secrecy 강제 (Ephemeral 키 교환만 허용)

### 인증서

**구조**:

```
인증서 (Certificate)
├── 버전 (v3)
├── 일련번호 (Serial Number)
├── 서명 알고리즘 (SHA256-RSA)
├── 발급자 (Issuer): CN=Let's Encrypt Authority X3
├── 유효기간 (Validity)
│   ├── Not Before: 2024-01-01
│   └── Not After: 2024-04-01
├── 주체 (Subject): CN=example.com
├── 공개키 (Public Key)
│   ├── 알고리즘: RSA
│   ├── 키 길이: 2048비트
│   └── 공개키 값: 30 82 01 0A...
├── 확장 (Extensions)
│   ├── Subject Alternative Name: example.com, www.example.com
│   ├── Key Usage: Digital Signature, Key Encipherment
│   └── Extended Key Usage: TLS Web Server Authentication
└── 서명 (Signature): CA의 개인키로 서명한 값
```

**왜 CA 서명이 필요한가?**

누구나 인증서를 만들 수 있지만, CA의 서명이 없으면 브라우저가 신뢰하지 않습니다. CA는 인증서 발급 전 도메인 소유권을 확인하므로, CA 서명이 있다는 것은 도메인 소유자가 맞다는 증거입니다.

**검증 과정**:

```java
1. 브라우저가 서버 인증서 수신
2. 인증서의 발급자(Issuer) 확인: "Let's Encrypt"
3. 브라우저에 내장된 신뢰하는 CA 목록 확인
4. Let's Encrypt의 공개키로 서버 인증서의 서명 검증
   - 서명 = Encrypt(Hash(인증서 내용), CA 개인키)
   - Decrypt(서명, CA 공개키) == Hash(인증서 내용) ?
5. 검증 성공 → 인증서의 공개키를 신뢰
6. 도메인 일치 확인: 인증서의 CN/SAN == 접속 도메인?
7. 유효기간 확인: Not Before <= 현재 < Not After?
```

**왜 이 방식이 안전한가?**

CA의 개인키는 CA만 가지고 있으므로, 공격자가 위조 인증서를 만들어도 CA 서명을 만들 수 없습니다. CA 공개키로 서명이 검증되면 CA가 발급한 것이 확실합니다.

### PKI (Public Key Infrastructure)

**인증서 체인**:

```
Root CA (최상위 인증 기관)
  ↓ 서명
Intermediate CA (중간 인증 기관)
  ↓ 서명
End-entity Certificate (서버 인증서)
```

**왜 중간 CA를 사용하는가?**

Root CA의 개인키가 유출되면 전체 신뢰 체계가 무너지므로, Root CA는 오프라인에 보관합니다. 일상적인 인증서 발급은 Intermediate CA가 수행하고, Intermediate CA가 손상되면 Root CA가 해당 인증서를 폐기(Revocation)할 수 있습니다.

**인증서 폐기 (Revocation)**:

1. **CRL (Certificate Revocation List)**: 폐기된 인증서 목록
   - 브라우저가 주기적으로 다운로드
   - 단점: 목록이 크고, 실시간 반영 어려움

2. **OCSP (Online Certificate Status Protocol)**: 실시간 확인
   - 브라우저가 CA에게 "이 인증서 유효해?" 질의
   - 단점: CA 서버 부하, 프라이버시 이슈 (CA가 사용자 방문 사이트 파악)

3. **OCSP Stapling**: 서버가 OCSP 응답을 미리 받아서 클라이언트에 전달
   - CA 부하 감소, 프라이버시 개선

**자체 서명 인증서 (Self-Signed Certificate)**:

개인키로 자기 자신의 인증서에 서명한 것. CA 서명이 없어 브라우저가 경고 표시.

**언제 사용하는가?**
- 개발/테스트 환경
- 내부 네트워크 (외부 접근 불필요)

**왜 운영 환경에서는 사용하지 않는가?**

브라우저가 신뢰하지 않아 사용자에게 보안 경고가 표시됩니다. 사용자가 경고를 무시하는 습관이 생기면 실제 피싱 사이트 방문 시에도 무시하여 위험합니다.

### HTTPS 동작 과정 요약

```
1. DNS 조회: example.com → 93.184.216.34

2. TCP 3-way Handshake (443 포트)
   SYN → SYN-ACK → ACK

3. TLS Handshake
   - 암호 스위트 협상
   - 인증서 검증
   - 세션 키 생성

4. 암호화된 HTTP 요청/응답
   GET /index.html
   (AES-GCM으로 암호화)

5. 연결 종료
   TLS Alert (close_notify)
   TCP 4-way Handshake
```

## 트레이드오프

### HTTP vs HTTPS

| 구분 | HTTP | HTTPS |
|------|------|-------|
| 보안 | 없음 (평문 전송) | 암호화 (도청 방지) |
| 포트 | 80 | 443 |
| 성능 | 빠름 | 느림 (핸드셰이크 오버헤드) |
| SEO | 낮은 순위 | 높은 순위 (Google 우대) |
| 비용 | 무료 | 인증서 비용 (Let's Encrypt는 무료) |

**결론**: 모든 웹사이트는 HTTPS를 사용해야 합니다. 성능 차이는 미미하고(TLS 1.3, HTTP/2), 보안 이점이 훨씬 큽니다.

### TLS 1.2 vs TLS 1.3

| 구분 | TLS 1.2 | TLS 1.3 |
|------|---------|---------|
| 핸드셰이크 | 2-RTT | 1-RTT (50% 감소) |
| 세션 재개 | Session ID/Ticket | 0-RTT (즉시 데이터 전송) |
| 암호 스위트 | 37개 (취약한 것 포함) | 5개 (강력한 것만) |
| Forward Secrecy | 선택 사항 | 필수 |
| 보안 | 다운그레이드 공격 가능 | 방어 강화 |

**결론**: TLS 1.3 사용 권장. 더 빠르고 안전합니다.

### DV vs OV vs EV 인증서

| 타입 | 검증 수준 | 발급 시간 | 브라우저 표시 | 용도 |
|------|----------|----------|--------------|------|
| DV (Domain Validation) | 도메인 소유권만 | 즉시 | 자물쇠 아이콘 | 일반 웹사이트 |
| OV (Organization Validation) | 도메인 + 조직 검증 | 1-3일 | 자물쇠 + 조직명 (클릭 시) | 기업 사이트 |
| EV (Extended Validation) | 도메인 + 조직 + 법적 실체 | 1-2주 | ~~주소창 녹색~~ (제거됨) | 금융, 전자상거래 |

**왜 EV 인증서의 녹색 표시가 제거되었나?**

피싱 사이트도 EV 인증서를 취득하는 사례가 발생하여, 사용자가 녹색 표시만 믿고 안심하는 것이 위험하다고 판단되었습니다(Chrome 77부터 제거).

## 면접 예상 질문

- Q: HTTPS는 어떻게 도청, 변조, 위장을 방어하나요?
  - A: **도청 방어(기밀성)**: 대칭키 암호화(AES)로 데이터를 암호화하여 중간자가 읽을 수 없습니다. **변조 방어(무결성)**: HMAC(Hash-based Message Authentication Code)으로 데이터의 해시 값을 계산하여 전송하므로, 데이터가 변조되면 해시 값이 달라져 탐지됩니다. **위장 방어(인증)**: CA가 서명한 인증서로 서버의 신원을 확인합니다. CA의 공개키로 인증서 서명을 검증하여 위조 불가능함을 보장합니다.

- Q: TLS 핸드셰이크에서 왜 대칭키와 비대칭키를 함께 사용하나요?
  - A: 비대칭키(RSA)는 안전하지만 느리고, 대칭키(AES)는 빠르지만 키 배포가 어렵기 때문입니다. **해결**: TLS 핸드셰이크에서 비대칭키로 대칭키를 안전하게 전달하고, 이후 실제 데이터는 대칭키로 암호화합니다. **구체적으로**: 서버의 공개키(인증서)로 Pre-Master Secret을 암호화하여 전달하고, 양측이 이를 기반으로 동일한 세션 키를 생성합니다. 이렇게 보안(비대칭키)과 성능(대칭키)을 모두 달성합니다.

- Q: 인증서는 무엇이며, CA는 왜 필요한가요?
  - A: 인증서는 서버의 공개키와 신원 정보를 담은 디지털 문서입니다. **왜 필요한가?** 중간자 공격을 방어하기 위해서입니다. 인증서가 없으면 공격자가 자신의 공개키를 보내도 클라이언트가 구분할 수 없습니다. **CA의 역할**: 인증 기관(CA)이 인증서에 서명하여 위조를 방지합니다. 브라우저는 CA의 공개키(신뢰하는 CA 목록에 내장)로 인증서 서명을 검증하여, CA가 발급한 정품 인증서임을 확인합니다. CA는 인증서 발급 전 도메인 소유권을 검증하므로, CA 서명이 있다는 것은 도메인 소유자가 맞다는 증거입니다.

- Q: TLS 1.3이 TLS 1.2보다 빠른 이유는 무엇인가요?
  - A: 핸드셰이크를 2-RTT에서 1-RTT로 줄였기 때문입니다. **어떻게?** TLS 1.2는 ClientHello로 지원 암호 스위트를 보내고, ServerHello로 선택 결과를 받은 후, ClientKeyExchange로 키 교환 파라미터를 보내야 했습니다(2번 왕복). TLS 1.3은 ClientHello에 키 교환 파라미터를 미리 포함하여 1번 왕복으로 완료합니다. **추가 개선**: 세션 재개 시 0-RTT로 즉시 데이터 전송 가능. **보안도 강화**: 취약한 암호 스위트를 제거하고 Forward Secrecy를 필수로 적용했습니다.

- Q: Forward Secrecy는 무엇이며, 왜 중요한가요?
  - A: Forward Secrecy(전방향 안전성)는 서버의 개인키가 유출되어도 과거 통신을 복호화할 수 없도록 보장하는 속성입니다. **어떻게 달성하는가?** Ephemeral(임시) 키 교환 알고리즘(DHE, ECDHE)을 사용합니다. 매 세션마다 새로운 키 쌍을 생성하고 핸드셰이크 후 즉시 폐기하므로, 특정 세션의 키가 유출되어도 다른 세션은 안전합니다. **왜 중요한가?** 서버의 개인키는 장기간 사용되므로 유출 위험이 있습니다. Forward Secrecy가 없으면 공격자가 과거 암호화 통신을 저장해두었다가 미래에 키가 유출되면 모든 통신을 복호화할 수 있습니다. TLS 1.3은 Forward Secrecy를 필수로 적용합니다.

- Q: 자체 서명 인증서(Self-Signed Certificate)와 CA 서명 인증서의 차이는 무엇인가요?
  - A: 자체 서명 인증서는 자기 자신의 개인키로 서명한 인증서이고, CA 서명 인증서는 신뢰하는 인증 기관(CA)의 개인키로 서명한 인증서입니다. **차이점**: 브라우저는 CA 서명 인증서만 신뢰합니다. **왜?** 브라우저는 신뢰하는 CA 목록을 내장하고 있지만, 개인이 생성한 CA는 알지 못하기 때문입니다. **자체 서명 인증서 사용 시**: 브라우저가 "연결이 비공개로 설정되지 않음" 경고를 표시합니다. **용도**: 개발/테스트 환경이나 내부 네트워크에서만 사용하고, 운영 환경에서는 Let's Encrypt 같은 CA에서 무료로 발급받은 인증서를 사용해야 합니다.

## 참고 자료

- [RFC 8446 - TLS 1.3](https://datatracker.ietf.org/doc/html/rfc8446)
- [RFC 5246 - TLS 1.2](https://datatracker.ietf.org/doc/html/rfc5246)
- [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/)
- [Let's Encrypt - Free SSL/TLS Certificates](https://letsencrypt.org/)
- [SSL Labs Server Test](https://www.ssllabs.com/ssltest/)
