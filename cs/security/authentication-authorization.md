# 인증과 인가

> [2] 입문 · 선수 지식: 없음

> 인증(Authentication)은 "당신이 누구인가?"를 확인하고, 인가(Authorization)는 "당신이 무엇을 할 수 있는가?"를 결정하는 보안 메커니즘

`#인증` `#인가` `#Authentication` `#Authorization` `#로그인` `#Login` `#세션` `#Session` `#토큰` `#Token` `#RBAC` `#ABAC` `#권한관리` `#AccessControl` `#Stateful` `#Stateless` `#MFA` `#2FA` `#RefreshToken` `#AccessToken` `#SessionID` `#Cookie` `#역할기반` `#속성기반` `#로그아웃` `#세션하이재킹` `#비밀번호` `#Password` `#신원확인` `#권한위임`

## 왜 알아야 하는가?

- **실무**: 모든 웹 애플리케이션은 사용자 로그인과 권한 관리를 구현해야 합니다. 인증/인가를 제대로 이해하지 못하면 보안 취약점이 발생하거나, 일반 사용자가 관리자 기능에 접근하는 등의 심각한 문제가 생깁니다.
- **면접**: "세션과 토큰의 차이", "JWT를 사용하는 이유", "RBAC와 ABAC의 차이"는 백엔드 개발자 면접의 단골 질문입니다. 보안 설계 능력을 확인하는 핵심 주제입니다.
- **기반 지식**: OAuth, JWT, HTTPS 등 다른 보안 기술을 이해하는 기반이 됩니다. 인증/인가의 기본 개념 없이는 복잡한 보안 프로토콜을 이해할 수 없습니다.

## 핵심 개념

- **인증(Authentication)**: 사용자의 신원을 확인하는 과정 (로그인)
- **인가(Authorization)**: 인증된 사용자가 특정 리소스에 접근할 권한이 있는지 확인하는 과정
- **세션 기반 인증**: 서버가 사용자 상태를 저장하여 관리 (Stateful)
- **토큰 기반 인증**: 서버가 상태를 저장하지 않고 토큰으로 검증 (Stateless)
- **권한 관리(RBAC/ABAC)**: 역할 또는 속성 기반으로 접근 제어

## 쉽게 이해하기

**인증과 인가**를 놀이공원 입장에 비유할 수 있습니다.

- **인증**: 놀이공원 입구에서 티켓을 확인하는 것. "당신이 티켓을 구매한 사람이 맞나요?"
- **인가**: 각 놀이기구 앞에서 키 제한을 확인하는 것. "당신은 이 놀이기구를 탈 수 있나요?"

예를 들어, 어린이가 티켓을 가지고 있다면 **인증은 통과**합니다. 하지만 키가 120cm 미만이라면 롤러코스터는 **인가에서 거부**됩니다.

또 다른 예시:
- **세션 기반**: 놀이공원 입장 시 팔찌를 받고, 팔찌를 보여주면 재입장 가능. 직원이 팔찌 번호로 입장 기록을 확인.
- **토큰 기반**: 입장권에 이름, 유효기간, 이용 가능 시설이 모두 적혀 있음. 직원은 입장권만 보고 판단 가능.

## 상세 설명

### 인증 (Authentication)

**왜 필요한가?**

시스템은 요청을 보내는 사용자가 실제로 누구인지 확인해야 합니다. 왜냐하면 익명의 요청을 모두 허용하면 데이터 유출, 무단 수정 등의 보안 문제가 발생하기 때문입니다.

**인증 방법**:
1. **비밀번호 기반**: ID + Password 확인
2. **토큰 기반**: JWT, OAuth 토큰 검증
3. **생체 인증**: 지문, 얼굴 인식
4. **2FA (Two-Factor Authentication)**: 비밀번호 + OTP

**왜 다양한 방법이 필요한가?**
비밀번호만으로는 탈취, 추측 공격에 취약합니다. 따라서 여러 인증 수단을 조합(MFA)하면 보안성이 기하급수적으로 높아집니다.

### 인가 (Authorization)

**왜 인증만으로는 부족한가?**

사용자가 누구인지 확인했다고 해서 모든 리소스에 접근을 허용하면 안 됩니다. 왜냐하면 일반 사용자가 관리자 기능에 접근하거나, 다른 사용자의 개인정보를 조회하는 것을 막아야 하기 때문입니다.

**인가 방식**:
1. **RBAC (Role-Based Access Control)**: 역할 기반
   - 사용자에게 역할(ADMIN, USER, GUEST)을 부여
   - 역할별로 권한(READ, WRITE, DELETE) 정의
   - 예: ADMIN은 모든 권한, USER는 READ/WRITE만 가능

2. **ABAC (Attribute-Based Access Control)**: 속성 기반
   - 사용자 속성, 리소스 속성, 환경 조건을 조합하여 판단
   - 예: "부서가 인사팀이고, 근무시간이며, VPN 접속인 경우 직원 정보 조회 허용"

**왜 RBAC와 ABAC가 나뉘는가?**
- RBAC는 간단하고 관리가 쉬워 대부분의 시스템에 적합합니다.
- ABAC는 복잡한 규칙이 필요한 경우 유연하게 대응할 수 있지만, 관리 복잡도가 높습니다.

### 세션 기반 인증

**동작 방식**:
1. 사용자가 로그인 (ID + Password)
2. 서버가 세션 생성 및 메모리/DB에 저장
3. 클라이언트에 Session ID를 쿠키로 전달
4. 이후 요청 시 Session ID를 쿠키로 전송
5. 서버가 Session ID로 세션 저장소 조회하여 사용자 확인

**왜 이렇게 하는가?**

서버가 사용자 상태를 직접 관리하므로 세션을 즉시 무효화할 수 있습니다. 예를 들어 사용자가 로그아웃하거나 비밀번호를 변경하면 서버에서 해당 세션을 삭제하여 즉시 접근을 차단할 수 있습니다.

**장점**:
- 서버에서 세션을 제어 가능 (강제 로그아웃, 동시 접속 제한)
- 민감한 정보를 서버에만 저장 (클라이언트에 노출 없음)

**단점**:
- 서버 메모리/스토리지 사용 (사용자 수 증가 시 부담)
- 수평 확장 시 세션 공유 필요 (Redis, Sticky Session 등)

### 토큰 기반 인증

**동작 방식**:
1. 사용자가 로그인 (ID + Password)
2. 서버가 JWT 토큰 생성 (사용자 정보 + 서명)
3. 클라이언트가 토큰을 로컬 스토리지/쿠키에 저장
4. 이후 요청 시 Authorization 헤더에 토큰 포함
5. 서버가 토큰의 서명을 검증하여 사용자 확인

**왜 이렇게 하는가?**

서버가 상태를 저장하지 않으므로(Stateless) 수평 확장이 쉽습니다. 왜냐하면 어떤 서버가 요청을 받아도 토큰만 검증하면 되기 때문입니다. 세션처럼 서버 간 세션 공유나 중앙 세션 저장소가 필요 없습니다.

**장점**:
- 서버 메모리 사용 없음 (Stateless)
- 수평 확장 용이 (서버 추가 시 추가 설정 불필요)
- CORS 문제 해결 (쿠키가 아닌 헤더 사용)

**단점**:
- 토큰 무효화 어려움 (토큰 탈취 시 만료 전까지 유효)
- 토큰 크기가 세션 ID보다 큼 (페이로드 포함)
- Refresh Token 관리 필요

**왜 Refresh Token이 필요한가?**

Access Token의 유효기간을 짧게(15분) 설정하면 탈취 위험을 줄이지만, 사용자가 자주 재로그인해야 합니다. Refresh Token(유효기간 7일)을 함께 발급하면 Access Token 만료 시 자동 갱신할 수 있어 UX와 보안을 모두 챙길 수 있습니다.

### 권한 관리 구현

**RBAC 예시**:
```java
public enum Role {
    ADMIN, USER, GUEST
}

public enum Permission {
    READ, WRITE, DELETE
}

public class User {
    private String id;
    private Role role;

    public boolean hasPermission(Permission permission) {
        return switch (role) {
            case ADMIN -> true; // 모든 권한
            case USER -> permission == Permission.READ || permission == Permission.WRITE;
            case GUEST -> permission == Permission.READ;
        };
    }
}
```

**왜 이렇게 설계하는가?**

역할과 권한을 분리하면 역할별로 권한을 일괄 변경할 수 있습니다. 예를 들어 USER 역할의 권한을 수정하면 모든 USER에게 즉시 반영됩니다. 각 사용자별로 권한을 관리하면 수천 명의 사용자 권한을 일일이 수정해야 합니다.

## 트레이드오프

### 세션 vs 토큰

| 구분 | 세션 기반 | 토큰 기반 |
|------|----------|----------|
| 서버 부담 | 높음 (세션 저장소 필요) | 낮음 (Stateless) |
| 확장성 | 어려움 (세션 공유 필요) | 쉬움 (독립적 검증) |
| 보안 제어 | 강함 (즉시 무효화 가능) | 약함 (만료 전까지 유효) |
| 네트워크 오버헤드 | 작음 (Session ID만 전송) | 큼 (전체 토큰 전송) |
| CSRF 취약점 | 있음 (쿠키 자동 전송) | 없음 (헤더 수동 전송) |
| XSS 취약점 | 낮음 (HttpOnly 쿠키) | 높음 (localStorage 사용 시) |

**결론**:
- 세션 기반: 모놀리식, 강력한 세션 제어 필요 시 (관리자 시스템)
- 토큰 기반: MSA, 모바일 앱, 수평 확장 필요 시 (API 서버)

### RBAC vs ABAC

| 구분 | RBAC | ABAC |
|------|------|------|
| 복잡도 | 낮음 | 높음 |
| 유연성 | 제한적 | 매우 유연 |
| 성능 | 빠름 (단순 비교) | 느림 (복잡한 규칙 평가) |
| 관리 난이도 | 쉬움 | 어려움 |
| 적합한 경우 | 일반적인 웹 서비스 | 복잡한 정책이 필요한 엔터프라이즈 |

## 면접 예상 질문

- Q: 인증과 인가의 차이는 무엇인가요?
  - A: 인증(Authentication)은 "당신이 누구인가?"를 확인하는 것이고, 인가(Authorization)는 "당신이 무엇을 할 수 있는가?"를 결정하는 것입니다. **왜냐하면** 사용자가 누구인지 확인한 것과, 그 사용자가 특정 리소스에 접근할 권한이 있는지는 별개의 문제이기 때문입니다. 예를 들어 일반 사용자는 로그인(인증)은 가능하지만, 관리자 페이지 접근(인가)은 거부됩니다.

- Q: 세션 기반과 토큰 기반 인증의 차이는 무엇이며, 각각 언제 사용해야 하나요?
  - A: 세션 기반은 서버가 사용자 상태를 저장(Stateful)하고, 토큰 기반은 저장하지 않습니다(Stateless). **왜 이 차이가 중요한가?** 세션 기반은 서버에서 세션을 즉시 무효화할 수 있어 보안 제어가 강하지만, 수평 확장 시 세션 공유가 필요합니다. 토큰 기반은 수평 확장이 쉽고 MSA에 적합하지만, 토큰 탈취 시 만료 전까지 무효화할 수 없습니다. **따라서** 모놀리식 시스템이나 강력한 세션 제어가 필요하면 세션 기반을, MSA나 모바일 API에서는 토큰 기반을 사용합니다.

- Q: JWT를 사용할 때 왜 Access Token과 Refresh Token을 함께 사용하나요?
  - A: Access Token의 유효기간을 짧게 설정하면 탈취 시 피해를 줄일 수 있지만, 사용자가 자주 재로그인해야 합니다. **왜냐하면** JWT는 Stateless이므로 서버에서 강제로 무효화할 수 없기 때문입니다. Refresh Token(유효기간 7일)을 함께 발급하면 Access Token(유효기간 15분) 만료 시 자동으로 갱신할 수 있어, 보안(짧은 유효기간)과 사용자 경험(재로그인 불필요)을 모두 챙길 수 있습니다.

- Q: RBAC와 ABAC의 차이는 무엇이며, 각각 언제 사용하나요?
  - A: RBAC(Role-Based)는 역할 기반으로 권한을 부여하고, ABAC(Attribute-Based)는 속성 기반으로 권한을 부여합니다. **왜 두 가지가 필요한가?** RBAC는 간단하고 관리가 쉬워 대부분의 시스템에 적합하지만, 복잡한 규칙(예: "부서가 인사팀이고, 근무시간이며, VPN 접속인 경우만 허용")은 표현하기 어렵습니다. ABAC는 이런 복잡한 정책을 유연하게 표현할 수 있지만, 규칙이 복잡해지면 관리와 성능 이슈가 발생합니다. **따라서** 일반 웹 서비스는 RBAC를, 복잡한 정책이 필요한 엔터프라이즈 시스템은 ABAC를 사용합니다.

- Q: 세션 기반 인증에서 수평 확장 시 어떤 문제가 발생하며, 어떻게 해결하나요?
  - A: 서버 A에서 로그인한 사용자가 서버 B로 요청을 보내면 세션을 찾을 수 없어 인증 실패합니다. **왜냐하면** 각 서버가 독립적으로 세션을 메모리에 저장하기 때문입니다. **해결 방법**: 1) Sticky Session: 로드밸런서가 같은 사용자를 같은 서버로 라우팅. 단, 서버 장애 시 세션 손실. 2) 중앙 세션 저장소: Redis 같은 외부 저장소에 세션을 공유. 모든 서버가 동일한 세션 접근 가능. 3) 토큰 기반으로 전환: Stateless이므로 세션 공유 불필요.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [OAuth 2.0과 JWT](./oauth-jwt.md) | OAuth는 인가 프레임워크, JWT는 토큰 기반 인증에 사용되는 포맷 | Advanced |
| [암호화](./cryptography.md) | 비밀번호 해싱(bcrypt), 토큰 서명(HMAC/RSA)에 암호화 기술 사용 | Intermediate |
| [웹 보안](./web-security.md) | 세션 하이재킹, 토큰 탈취 등 인증/인가 관련 공격과 방어 | Intermediate |
| [HTTPS와 TLS](./https-tls.md) | 인증서를 통한 서버 인증, 안전한 통신 채널 제공 | Advanced |

## 참고 자료

- [OAuth 2.0 RFC 6749](https://datatracker.ietf.org/doc/html/rfc6749)
- [JWT RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519)
- [NIST RBAC Model](https://csrc.nist.gov/projects/role-based-access-control)
- [OWASP Authentication Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
