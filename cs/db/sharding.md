# 샤딩 (Sharding)

> `[4] 심화` · 선수 지식: [데이터베이스란](./what-is-database.md), [Index](./index.md), [Transaction](./transaction.md)

> 대용량 데이터를 여러 데이터베이스에 수평 분할하여 저장하는 기법

`#샤딩` `#Sharding` `#수평분할` `#HorizontalPartitioning` `#파티셔닝` `#Partitioning` `#분산DB` `#DistributedDatabase` `#샤드키` `#ShardKey` `#해시샤딩` `#HashSharding` `#범위샤딩` `#RangeSharding` `#스케일아웃` `#ScaleOut` `#로드밸런싱` `#LoadBalancing` `#CAP` `#일관성` `#가용성` `#NoSQL` `#MongoDB` `#MySQL` `#Vitess` `#리샤딩` `#Resharding` `#핫스팟` `#Hotspot`

## 왜 알아야 하는가?

단일 데이터베이스는 용량과 성능에 한계가 있습니다. 수억 건의 데이터를 처리하려면 샤딩이 필수입니다. 대규모 서비스(카카오, 네이버, 쿠팡 등)는 모두 샤딩을 사용합니다. 그러나 잘못된 샤딩은 운영 복잡성을 크게 증가시킵니다.

## 핵심 개념

- **샤드 (Shard)**: 전체 데이터의 일부를 담는 개별 데이터베이스
- **샤드 키 (Shard Key)**: 데이터를 어느 샤드에 저장할지 결정하는 컬럼
- **수평 분할**: 행 단위로 데이터를 나눔 (vs 수직 분할: 열 단위)
- **라우팅**: 쿼리를 적절한 샤드로 전달

## 쉽게 이해하기

**샤딩**을 도서관 분관 시스템에 비유할 수 있습니다.

```
단일 도서관 (샤딩 전):
┌─────────────────────────────┐
│       중앙 도서관            │
│   모든 책 100만 권 보관      │ ← 공간 한계, 혼잡
└─────────────────────────────┘

분관 시스템 (샤딩 후):
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│ 강남 분관   │ │ 강북 분관   │ │ 강서 분관   │
│ 가~나 저자  │ │ 다~바 저자  │ │ 사~하 저자  │
│ 33만 권     │ │ 33만 권     │ │ 34만 권     │
└─────────────┘ └─────────────┘ └─────────────┘
      ↑              ↑              ↑
    샤드1          샤드2          샤드3

샤드 키 = 저자명 첫 글자
```

## 상세 설명

### 샤딩 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                    샤딩 아키텍처                             │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   클라이언트                                                 │
│       ↓                                                      │
│  ┌────────────────────────────────────┐                     │
│  │       샤드 라우터 (Proxy)           │                     │
│  │   - 쿼리 분석                       │                     │
│  │   - 샤드 키로 대상 샤드 결정         │                     │
│  │   - 결과 병합                       │                     │
│  └────────────────────────────────────┘                     │
│       ↓                                                      │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐                   │
│  │ Shard 1  │  │ Shard 2  │  │ Shard 3  │                   │
│  │ user_id  │  │ user_id  │  │ user_id  │                   │
│  │ 1~1000   │  │ 1001~2000│  │ 2001~3000│                   │
│  └──────────┘  └──────────┘  └──────────┘                   │
│                                                              │
│  ┌────────────────────────────────────┐                     │
│  │       설정 저장소 (Config)          │                     │
│  │   - 샤드 매핑 정보                  │                     │
│  │   - 샤드 메타데이터                 │                     │
│  └────────────────────────────────────┘                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 샤딩 전략

#### 1. 해시 샤딩 (Hash Sharding)

```
샤드 키에 해시 함수 적용:

user_id = 12345
shard_number = hash(12345) % 3 = 2

┌──────────────────────────────────────────────────────────┐
│  hash(user_id) % 샤드 수 = 샤드 번호                      │
├──────────────────────────────────────────────────────────┤
│                                                           │
│   user_id: 1    → hash(1) % 3 = 1  → Shard 1             │
│   user_id: 2    → hash(2) % 3 = 2  → Shard 2             │
│   user_id: 3    → hash(3) % 3 = 0  → Shard 0             │
│   user_id: 12345→ hash(12345) % 3 = 2 → Shard 2          │
│                                                           │
└──────────────────────────────────────────────────────────┘

장점: 데이터 균등 분산
단점: 범위 쿼리 어려움, 리샤딩 복잡
```

#### 2. 범위 샤딩 (Range Sharding)

```
샤드 키 값의 범위로 분할:

┌──────────────────────────────────────────────────────────┐
│                    범위 샤딩                              │
├──────────────────────────────────────────────────────────┤
│                                                           │
│   Shard 0: user_id 1 ~ 1,000,000                         │
│   Shard 1: user_id 1,000,001 ~ 2,000,000                 │
│   Shard 2: user_id 2,000,001 ~ 3,000,000                 │
│                                                           │
│   또는 날짜 기반:                                         │
│   Shard 0: 2024년 데이터                                  │
│   Shard 1: 2023년 데이터                                  │
│   Shard 2: 2022년 이전 데이터                             │
│                                                           │
└──────────────────────────────────────────────────────────┘

장점: 범위 쿼리 효율적
단점: 핫스팟 발생 가능 (신규 데이터 집중)
```

#### 3. 디렉토리 샤딩 (Directory Sharding)

```
조회 테이블로 매핑:

┌─────────────┐     ┌───────────────────┐
│ Lookup      │     │ Shards            │
│ Table       │     │                   │
├─────────────┤     ├───────────────────┤
│ key → shard │     │ Shard 0           │
│ A   → 0     │ ──→ │ Shard 1           │
│ B   → 1     │     │ Shard 2           │
│ C   → 2     │     │                   │
│ ...         │     │                   │
└─────────────┘     └───────────────────┘

장점: 유연한 매핑, 샤드 불균형 조정 가능
단점: 조회 테이블이 단일 장애점, 추가 조회 필요
```

### 샤드 키 선택

```
┌─────────────────────────────────────────────────────────────┐
│                    샤드 키 선택 기준                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ✅ 좋은 샤드 키:                                            │
│     ├─ 높은 카디널리티 (다양한 값)                          │
│     ├─ 균등한 분포                                          │
│     ├─ 쿼리에서 자주 사용                                   │
│     └─ 변경되지 않는 값                                     │
│                                                              │
│  ❌ 나쁜 샤드 키:                                            │
│     ├─ 낮은 카디널리티 (성별, 상태 등)                      │
│     ├─ 순차적 증가 값 (timestamp) → 핫스팟                  │
│     ├─ 자주 변경되는 값                                     │
│     └─ 쿼리에서 잘 안 쓰는 값                               │
│                                                              │
│  예시:                                                       │
│  ┌────────────────┬────────────────────────────────────┐    │
│  │ 서비스         │ 좋은 샤드 키                        │    │
│  ├────────────────┼────────────────────────────────────┤    │
│  │ 이커머스       │ user_id, order_id                  │    │
│  │ 소셜 미디어    │ user_id                            │    │
│  │ 채팅           │ room_id, user_id                   │    │
│  │ 로그 시스템    │ tenant_id + date                   │    │
│  └────────────────┴────────────────────────────────────┘    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 크로스 샤드 쿼리

```
문제: 여러 샤드에 걸친 조회

SELECT * FROM orders
WHERE user_id IN (1, 1001, 2001);  -- 각각 다른 샤드

┌─────────────────────────────────────────────────────────────┐
│                  크로스 샤드 쿼리 처리                        │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   1. Scatter-Gather 패턴:                                   │
│                                                              │
│      클라이언트                                              │
│          ↓ 쿼리                                              │
│      ┌───────────────────────┐                              │
│      │    라우터 (Scatter)   │                              │
│      └───────────────────────┘                              │
│       ↓        ↓        ↓                                   │
│   ┌──────┐ ┌──────┐ ┌──────┐                               │
│   │Shard1│ │Shard2│ │Shard3│  ← 병렬 쿼리                   │
│   └──────┘ └──────┘ └──────┘                               │
│       ↓        ↓        ↓                                   │
│      ┌───────────────────────┐                              │
│      │   라우터 (Gather)      │ ← 결과 병합                 │
│      └───────────────────────┘                              │
│          ↓                                                   │
│      클라이언트                                              │
│                                                              │
│   2. 해결책:                                                 │
│      - 샤드 키 포함 쿼리 권장                                │
│      - 자주 함께 조회되는 데이터는 같은 샤드에               │
│      - 집계는 별도 서비스 (OLAP, Elasticsearch)             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 리샤딩 (Resharding)

```
샤드 추가/제거 시 데이터 재분배:

Before (3 shards):
┌──────────┐ ┌──────────┐ ┌──────────┐
│ Shard 0  │ │ Shard 1  │ │ Shard 2  │
│ 33% data │ │ 33% data │ │ 33% data │
└──────────┘ └──────────┘ └──────────┘

After (4 shards) - 재분배 필요:
┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
│ Shard 0  │ │ Shard 1  │ │ Shard 2  │ │ Shard 3  │
│ 25% data │ │ 25% data │ │ 25% data │ │ 25% data │
└──────────┘ └──────────┘ └──────────┘ └──────────┘

리샤딩 전략:
1. 일관된 해싱 (Consistent Hashing) - 영향 최소화
2. 가상 샤드 - 미리 많은 파티션 생성
3. 점진적 마이그레이션 - 트래픽 분산
```

### 샤딩 vs 레플리케이션

| 구분 | 샤딩 | 레플리케이션 |
|------|------|-------------|
| 목적 | 용량/성능 확장 | 가용성/읽기 성능 |
| 데이터 | 분할 저장 | 복제 저장 |
| 쓰기 성능 | 향상 | 동일/저하 |
| 읽기 성능 | 향상 | 향상 |
| 복잡도 | 높음 | 중간 |

## 트레이드오프

| 장점 | 단점 |
|------|------|
| 수평 확장 가능 | 운영 복잡성 증가 |
| 쓰기 성능 향상 | 크로스 샤드 쿼리 어려움 |
| 데이터 지역성 | 트랜잭션 제한 |
| 장애 격리 | 리샤딩 비용 |

## 면접 예상 질문

### Q: 샤드 키를 잘못 선택하면 어떤 문제가 발생하나요?

A: (1) **핫스팟**: 특정 샤드에 트래픽 집중 (예: 순차 ID → 최신 샤드만 쓰기). (2) **데이터 불균형**: 일부 샤드만 데이터 폭증. (3) **크로스 샤드 쿼리 증가**: 샤드 키 없는 쿼리 → 모든 샤드 조회. **해결**: 높은 카디널리티, 균등 분포, 쿼리 패턴 고려. **실제 사례**: 날짜 샤딩 → 오늘 날짜 샤드만 바쁨 → 복합 키 사용.

### Q: 샤딩 없이 대용량 데이터를 처리하는 방법은?

A: (1) **수직 확장**: 더 큰 서버 (한계 있음). (2) **레플리케이션**: 읽기 분산 (쓰기는 해결 안 됨). (3) **테이블 파티셔닝**: 단일 DB 내 파티션 (확장성 한계). (4) **캐싱**: Redis로 읽기 부하 감소. (5) **아카이빙**: 오래된 데이터 별도 저장. **결론**: 진정한 수평 확장은 샤딩이 필수.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [레플리케이션](./replication.md) | 가용성 확보 | [4] 심화 |
| [Transaction](./transaction.md) | 분산 트랜잭션 | [3] 중급 |
| [NoSQL](./nosql.md) | 분산 DB | [4] 심화 |
| [CAP 정리](../system-design/distributed-transaction.md) | 분산 시스템 이론 | [3] 중급 |

## 참고 자료

- [MongoDB Sharding](https://www.mongodb.com/docs/manual/sharding/)
- [Vitess - MySQL Sharding](https://vitess.io/)
- [Designing Data-Intensive Applications](https://dataintensive.net/)
