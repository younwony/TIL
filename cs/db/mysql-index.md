# MySQL 인덱스

> 데이터베이스에서 검색 속도를 향상시키기 위한 자료구조로, MySQL InnoDB는 B+Tree 기반 인덱스를 사용한다.

## 핵심 개념

- **B+Tree 구조**: MySQL InnoDB의 기본 인덱스 자료구조로, 리프 노드에만 실제 데이터(또는 PK)가 저장됨
- **클러스터드 인덱스**: 테이블당 하나만 존재하며, 실제 데이터가 인덱스 순서대로 물리적으로 정렬됨 (PK 기준)
- **세컨더리 인덱스**: 클러스터드 인덱스 외의 모든 인덱스로, 리프 노드에 PK 값을 저장
- **커버링 인덱스**: 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 테이블 접근 없이 처리 가능
- **인덱스 선택도**: 중복도가 낮을수록(Cardinality가 높을수록) 인덱스 효율이 좋음

## 쉽게 이해하기

**인덱스**를 책의 목차와 색인에 비유할 수 있습니다.

### 인덱스 = 책 뒤쪽의 색인(찾아보기)

1000페이지짜리 책에서 "데이터베이스"라는 단어를 찾으려면 어떻게 할까요?

- **인덱스 없이**: 1페이지부터 끝까지 한 장씩 넘기며 찾기 (Full Table Scan)
- **인덱스 있으면**: 책 뒤쪽 색인에서 "데이터베이스 → 42, 156, 289p" 확인 후 바로 이동

**왜 빠른가요?**
- 색인은 **가나다순 정렬** → 이진 탐색 가능 (O(log N))
- 1000페이지 중 10페이지만 확인하면 됨

### 클러스터드 인덱스 = 사전

사전은 단어가 **가나다순으로 정렬**되어 있습니다. "사과"를 찾으면 ㅅ 섹션으로 바로 가서 찾을 수 있죠. 데이터 자체가 정렬된 순서대로 저장되어 있습니다.

**왜 하나만 존재하나요?**
- 데이터 자체를 정렬하기 때문에, 두 가지 기준으로 동시에 정렬 불가
- 책을 가나다순으로도 정렬하고, 출판일순으로도 정렬할 수는 없음

### 세컨더리 인덱스 = 도서관 카드 목록

도서관에서 책을 찾을 때:
1. 카드 목록(세컨더리 인덱스)에서 책 제목 검색 → "청구번호: A-123" 확인
2. 청구번호(PK)로 실제 책장 가서 책 찾기 (한 번 더 조회 필요)

**왜 한 번 더 조회하나요?**
- 세컨더리 인덱스에는 실제 데이터 위치가 아닌 PK만 저장
- PK로 클러스터드 인덱스를 다시 조회해야 실제 데이터 접근

### 복합 인덱스 = 전화번호부

전화번호부는 "성 → 이름" 순서로 정렬되어 있습니다.

- "김" 씨 찾기 → 빠름 (첫 번째 기준)
- "김철수" 찾기 → 빠름 (순서대로 검색)
- "철수" 찾기 → 느림! (이름만으로는 못 찾음, 처음부터 다 봐야 함)

**왜 순서가 중요한가요?**
- 인덱스는 첫 번째 컬럼 기준 정렬 후, 그 안에서 두 번째 컬럼 정렬
- 첫 번째 컬럼 없이는 두 번째 컬럼만으로 검색 불가

| 비유 | 인덱스 개념 |
|------|------------|
| 책의 색인 | 인덱스 기본 개념 |
| 사전 | 클러스터드 인덱스 (데이터가 정렬됨) |
| 도서관 카드 목록 | 세컨더리 인덱스 (PK로 한 번 더 조회) |
| 전화번호부 | 복합 인덱스 (순서 중요) |

---

## 상세 설명

### B+Tree 인덱스 구조

```
                    [Root Node]
                   /     |     \
                  /      |      \
         [Branch]    [Branch]    [Branch]
          /   \        /   \        /   \
       [Leaf]-[Leaf]-[Leaf]-[Leaf]-[Leaf]-[Leaf]
         ↓      ↓      ↓      ↓      ↓      ↓
        Data   Data   Data   Data   Data   Data

    * 리프 노드들은 Linked List로 연결됨 (범위 검색에 유리)
```

**B+Tree 특징:**
- 모든 리프 노드가 같은 레벨에 위치 (균형 트리)
- 리프 노드끼리 연결되어 범위 검색에 효율적
- 검색, 삽입, 삭제 모두 O(log N) 시간복잡도

**왜 B+Tree인가? (다른 자료구조와 비교)**

| 자료구조 | 장점 | 단점 | 왜 DB에 부적합? |
|---------|------|------|----------------|
| Hash | O(1) 검색 | 범위 검색 불가 | > , < , BETWEEN 사용 불가 |
| Binary Tree | 간단 | 편향 시 O(N) | 순차 삽입 시 한쪽으로 치우침 |
| AVL/Red-Black | 균형 유지 | 디스크 I/O 비효율 | 노드마다 디스크 접근 |
| B+Tree | 디스크 I/O 최적화 | 구현 복잡 | ✅ DB에 최적 |

**B+Tree가 디스크 I/O에 효율적인 이유:**
- 하나의 노드에 여러 키 저장 → 한 번 디스크 읽기로 여러 키 비교
- 트리 높이가 낮음 → 적은 디스크 접근으로 검색
- 리프 노드 연결 → 범위 검색 시 순차 접근

---

### 클러스터드 인덱스 (Clustered Index)

InnoDB에서 **테이블 = 클러스터드 인덱스**라고 볼 수 있다.

```
클러스터드 인덱스 구조:

    [PK: 1, 2, 3]          <- Root/Branch 노드
         |
    [Leaf 노드]
    ┌─────────────────────────────────────┐
    │ PK=1 │ name='Kim' │ age=25 │ ...   │  <- 실제 행 데이터
    │ PK=2 │ name='Lee' │ age=30 │ ...   │
    │ PK=3 │ name='Park'│ age=28 │ ...   │
    └─────────────────────────────────────┘
```

**클러스터드 인덱스 선정 기준 (우선순위):**
1. PRIMARY KEY가 있으면 PK를 클러스터드 인덱스로 사용
2. PK가 없으면 NOT NULL인 UNIQUE 인덱스 중 첫 번째를 사용
3. 둘 다 없으면 InnoDB가 내부적으로 6바이트 숨겨진 Row ID 생성

**권장 (O): AUTO_INCREMENT PK 사용**

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,  -- 순차 증가
    name VARCHAR(50),
    ...
);
```

**왜 AUTO_INCREMENT가 좋은가?**
- 순차적으로 증가 → 항상 마지막에 삽입 → 페이지 분할 최소화
- INSERT 성능 우수

**비권장 (X): UUID를 PK로 사용**

```sql
CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,  -- UUID
    name VARCHAR(50),
    ...
);
```

**왜 문제인가?**
- UUID는 랜덤 → 삽입 위치가 무작위 → 페이지 분할 빈번
- 문자열 비교 → 정수 비교보다 느림
- 인덱스 크기 증가 (36바이트 vs 8바이트)

**만약 지키지 않으면?**
- INSERT 성능 50~70% 저하
- 인덱스 크기 4배 이상 증가
- 세컨더리 인덱스에 PK가 저장되므로 모든 인덱스 크기 증가

---

### 세컨더리 인덱스 (Secondary Index)

```
세컨더리 인덱스 (name 컬럼):

    [name 인덱스 트리]
         |
    [Leaf 노드]
    ┌─────────────────┐
    │ 'Kim'  → PK=1   │  <- PK 값을 저장
    │ 'Lee'  → PK=2   │
    │ 'Park' → PK=3   │
    └─────────────────┘
           ↓
    PK로 클러스터드 인덱스 다시 조회 (= "테이블 룩업")
```

**세컨더리 인덱스 조회 과정:**
1. 세컨더리 인덱스에서 조건에 맞는 PK 찾기
2. 찾은 PK로 클러스터드 인덱스 조회 (랜덤 I/O 발생)

**왜 랜덤 I/O가 문제인가?**
- 디스크는 순차 읽기 빠름, 랜덤 읽기 느림
- 많은 행을 조회하면 PK별로 디스크 여기저기 접근
- 이 때문에 **인덱스 범위 검색 후 많은 행을 조회하면 오히려 풀 테이블 스캔보다 느릴 수 있다.**

**언제 풀 스캔이 더 빠른가?**

| 조회 비율 | 권장 방식 | 이유 |
|----------|----------|------|
| ~5% | 인덱스 사용 | 랜덤 I/O가 적음 |
| 5~20% | 상황에 따라 | 옵티마이저 판단 |
| 20%+ | 풀 테이블 스캔 | 순차 I/O가 효율적 |

---

### 복합 인덱스 (Composite Index)

```sql
CREATE INDEX idx_name_age ON users(name, age);
```

```
복합 인덱스 정렬 순서:

    name='Kim', age=25  → PK=1
    name='Kim', age=30  → PK=4
    name='Lee', age=20  → PK=2
    name='Lee', age=35  → PK=3

    * 첫 번째 컬럼(name)으로 먼저 정렬 후, 두 번째 컬럼(age)으로 정렬
```

**복합 인덱스 사용 규칙:**

| 쿼리 | 인덱스 사용 | 이유 |
|------|-----------|------|
| `WHERE name = 'Kim'` | O | 선행 컬럼 사용 |
| `WHERE name = 'Kim' AND age = 25` | O | 순서대로 사용 |
| `WHERE name = 'Kim' AND age > 20` | O | 선행 컬럼 = 후행 컬럼 range |
| `WHERE age = 25` | X | 선행 컬럼 없음 |
| `WHERE age = 25 AND name = 'Kim'` | O | 옵티마이저가 순서 조정 |
| `WHERE name > 'Kim' AND age = 25` | △ | name만 range 사용, age는 필터 |

**왜 선행 컬럼이 중요한가?**
- 복합 인덱스는 첫 번째 컬럼 기준 정렬
- 두 번째 컬럼은 첫 번째 값이 같을 때만 정렬됨
- 전화번호부에서 "김" 없이 "철수"만으로 찾을 수 없는 것과 같음

---

### 커버링 인덱스 (Covering Index)

쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 **테이블 접근 없이** 인덱스만으로 결과 반환.

**권장 (O): 커버링 인덱스 활용**

```sql
-- 인덱스: (name, age)

-- 커버링 인덱스 적용 (테이블 룩업 X)
SELECT name, age FROM users WHERE name = 'Kim';
-- EXPLAIN Extra: Using index
```

**비권장 (X): SELECT * 사용**

```sql
-- 커버링 인덱스 미적용 (테이블 룩업 O)
SELECT * FROM users WHERE name = 'Kim';
```

**왜 커버링 인덱스가 빠른가?**
- 테이블 룩업 없음 → 랜덤 I/O 제거
- 인덱스는 테이블보다 작음 → 캐시 히트율 높음
- 필요한 데이터만 읽음 → I/O 감소

**만약 SELECT * 를 남용하면?**
- 커버링 인덱스 불가 → 항상 테이블 룩업
- 네트워크 대역폭 낭비 (불필요한 컬럼 전송)
- 애플리케이션 메모리 낭비

---

### 인덱스가 사용되지 않는 경우

**비권장 (X): 인덱스를 무력화하는 쿼리**

```sql
-- 1. 인덱스 컬럼에 함수/연산 적용
WHERE YEAR(created_at) = 2024     -- X 인덱스 사용 불가
WHERE created_at >= '2024-01-01'  -- O

-- 2. 암시적 형변환
WHERE phone = 01012345678         -- X (숫자로 비교, 인덱스 안 탐)
WHERE phone = '01012345678'       -- O

-- 3. LIKE 앞부분 와일드카드
WHERE name LIKE '%Kim'            -- X 풀스캔
WHERE name LIKE 'Kim%'            -- O 인덱스 범위 검색

-- 4. NOT, != 연산자
WHERE status != 'DELETED'         -- 대부분 풀스캔 (거의 전체 조회)

-- 5. OR 조건 (각 컬럼에 인덱스 필요)
WHERE name = 'Kim' OR age = 25    -- index merge 또는 풀스캔
```

**왜 인덱스가 안 타는가?**

| 패턴 | 원인 | 해결책 |
|------|------|--------|
| 함수 적용 | 인덱스 값이 변환되어 비교 불가 | 조건 변환 |
| 암시적 형변환 | 컬럼 타입과 값 타입 불일치 | 타입 일치 |
| 앞 와일드카드 | 시작점을 알 수 없음 | Full-text Index |
| NOT, != | 대부분의 데이터 해당 | 긍정 조건으로 변경 |

---

## 실행 계획 (EXPLAIN)

```sql
EXPLAIN SELECT * FROM users WHERE name = 'Kim';
```

**주요 확인 항목:**

| 컬럼 | 설명 | 좋은 값 |
|------|------|---------|
| type | 접근 방식 | const > eq_ref > ref > range > index > ALL |
| key | 사용된 인덱스 | NULL이면 인덱스 미사용 |
| rows | 예상 검색 행 수 | 작을수록 좋음 |
| Extra | 추가 정보 | Using index (커버링), Using filesort (정렬), Using temporary (임시테이블) |

**type 상세 (성능 순):**

| type | 설명 | 예시 | 성능 |
|------|------|------|------|
| const | PK/UNIQUE로 1건 | WHERE id = 1 | 최고 |
| eq_ref | JOIN에서 PK로 1건씩 | 1:1 JOIN | 우수 |
| ref | 인덱스로 여러 건 | WHERE name = 'Kim' | 좋음 |
| range | 인덱스 범위 검색 | WHERE age > 20 | 보통 |
| index | 인덱스 풀 스캔 | 커버링 인덱스 전체 | 나쁨 |
| ALL | 테이블 풀 스캔 | 인덱스 없음 | 최악 |

**Extra 컬럼 해석:**

| Extra | 의미 | 조치 |
|-------|------|------|
| Using index | 커버링 인덱스 | 좋음, 유지 |
| Using where | 인덱스 후 필터링 | 인덱스 개선 고려 |
| Using filesort | 정렬 연산 필요 | ORDER BY 인덱스 추가 |
| Using temporary | 임시 테이블 사용 | GROUP BY 인덱스 추가 |

---

## 인덱스 설계 가이드

### 권장 (O): 인덱스를 생성해야 하는 경우

| 상황 | 이유 |
|------|------|
| WHERE 절에 자주 사용되는 컬럼 | 검색 속도 향상 |
| JOIN 조건에 사용되는 컬럼 | JOIN 성능 향상 |
| ORDER BY, GROUP BY에 사용되는 컬럼 | 정렬/그룹화 비용 제거 |
| Cardinality가 높은 컬럼 (중복 적음) | 선택도 높아 효율적 |

### 비권장 (X): 인덱스를 피해야 하는 경우

| 상황 | 이유 |
|------|------|
| 테이블 데이터가 적은 경우 | 풀스캔이 더 빠를 수 있음 |
| INSERT/UPDATE/DELETE가 빈번한 컬럼 | 인덱스 유지 비용 |
| Cardinality가 낮은 컬럼 | 선택도 낮아 비효율 |
| 거의 조회되지 않는 컬럼 | 인덱스 공간 낭비 |

### 복합 인덱스 컬럼 순서 결정

**권장 순서:**
1. **동등 조건(=)** 컬럼을 앞에
2. **범위 조건(<, >, BETWEEN)** 컬럼을 뒤에
3. **Cardinality가 높은** 컬럼을 앞에
4. **정렬 기준** 컬럼 고려

**왜 이 순서인가?**
- 동등 조건: 정확히 해당 범위로 좁힘
- 범위 조건 후 컬럼: 인덱스 활용 불가 (정렬이 깨짐)

```sql
-- 쿼리: WHERE status = 'ACTIVE' AND created_at > '2024-01-01' ORDER BY created_at

-- 권장 인덱스: (status, created_at)
-- 이유: status(=)로 필터 → created_at(>)로 범위 검색 + 정렬

-- 비권장 인덱스: (created_at, status)
-- 이유: created_at 범위 검색 후 status 인덱스 활용 불가
```

---

## 트레이드오프

### 인덱스 장단점

| 장점 | 단점 |
|------|------|
| SELECT 속도 향상 | INSERT/UPDATE/DELETE 속도 저하 |
| 정렬 비용 감소 | 디스크 공간 사용 |
| JOIN 성능 향상 | 인덱스 유지 비용 |
| 커버링 인덱스 가능 | 잘못된 인덱스는 오히려 악영향 |

### PK 선택

| PK 타입 | 장점 | 단점 | 권장 상황 |
|---------|------|------|----------|
| AUTO_INCREMENT | INSERT 빠름, 크기 작음 | 분산 환경 충돌 | 단일 DB |
| UUID v4 | 분산 환경 유리, 예측 불가 | INSERT 느림, 크기 큼 | 분산 시스템 |
| UUID v7 | 시간 기반 정렬, 분산 유리 | UUID v4보다 예측 가능 | 분산 + 성능 |
| 복합 PK | 자연키 표현 가능 | JOIN 복잡, 인덱스 비대 | 관계 테이블 |

---

## 예제 코드

```sql
-- 테이블 생성
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    age INT,
    status VARCHAR(20) DEFAULT 'ACTIVE',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_name (name),
    INDEX idx_email (email),
    INDEX idx_status_created (status, created_at)
) ENGINE=InnoDB;

-- 인덱스 확인
SHOW INDEX FROM users;

-- 인덱스 추가
CREATE INDEX idx_created_at ON users(created_at);

-- 인덱스 삭제
DROP INDEX idx_created_at ON users;

-- 실행 계획 확인
EXPLAIN SELECT * FROM users WHERE name = 'Kim' AND age > 20;

-- 실행 계획 상세 (JSON 형식)
EXPLAIN FORMAT=JSON SELECT * FROM users WHERE name = 'Kim';

-- 인덱스 힌트 사용 (권장하지 않음, 옵티마이저 신뢰)
SELECT * FROM users USE INDEX (idx_name) WHERE name = 'Kim';
SELECT * FROM users FORCE INDEX (idx_name) WHERE name = 'Kim';
SELECT * FROM users IGNORE INDEX (idx_name) WHERE name = 'Kim';
```

---

## 면접 예상 질문

### Q: 클러스터드 인덱스와 세컨더리 인덱스의 차이점은?

**A:** 클러스터드 인덱스는 테이블당 하나만 존재하며 리프 노드에 실제 행 데이터가 저장됩니다. 세컨더리 인덱스는 여러 개 생성 가능하고 리프 노드에 PK 값이 저장되어 추가적인 테이블 룩업이 필요합니다.

**왜 이렇게 설계되었나?**

| 구분 | 클러스터드 | 세컨더리 |
|------|-----------|----------|
| 데이터 위치 | 리프 노드에 실제 데이터 | PK 값만 저장 |
| 개수 | 테이블당 1개 | 여러 개 가능 |
| 정렬 | 데이터 물리적 정렬 | 논리적 정렬만 |
| 조회 | 바로 데이터 접근 | PK로 다시 조회 |

**만약 세컨더리 인덱스에 데이터 위치(주소)를 저장하면?**
- 클러스터드 인덱스 변경 시 모든 세컨더리 인덱스 갱신 필요
- PK 저장 방식은 클러스터드 변경과 무관

---

### Q: 복합 인덱스에서 컬럼 순서가 중요한 이유는?

**A:** 복합 인덱스는 첫 번째 컬럼으로 정렬 후 두 번째 컬럼으로 정렬되므로, 선행 컬럼이 조건에 없으면 인덱스를 효율적으로 사용할 수 없습니다.

**왜 그런가?**
```
인덱스 (name, age) 정렬 상태:
Kim, 25
Kim, 30
Lee, 20
Lee, 35
Park, 25

age = 25 검색 시:
- name이 없으므로 어디서 시작할지 알 수 없음
- 전체 스캔 필요
```

**만약 순서를 잘못 정하면?**
- 인덱스가 있어도 풀스캔
- 불필요한 디스크 공간 낭비
- INSERT/UPDATE 시 인덱스 유지 비용만 발생

---

### Q: 커버링 인덱스란 무엇이고 왜 성능이 좋은가요?

**A:** 쿼리에 필요한 모든 컬럼이 인덱스에 포함되어 테이블 데이터 페이지에 접근할 필요 없이 인덱스만으로 결과를 반환하는 것입니다.

**왜 빠른가?**

| 일반 인덱스 | 커버링 인덱스 |
|------------|--------------|
| 인덱스 검색 → PK 추출 → 테이블 조회 | 인덱스 검색 → 바로 반환 |
| 랜덤 I/O 발생 | 랜덤 I/O 없음 |
| 테이블 페이지 접근 | 인덱스 페이지만 접근 |

**만약 SELECT *을 사용하면?**
- 모든 컬럼이 인덱스에 없으므로 커버링 불가
- 항상 테이블 룩업 발생
- 성능 수배 저하 가능

---

### Q: 인덱스가 있는데도 풀스캔하는 경우는?

**A:** 옵티마이저가 인덱스보다 풀스캔이 효율적이라고 판단하는 경우입니다.

**언제 발생하는가?**

| 상황 | 이유 |
|------|------|
| 조회 비율 20% 이상 | 랜덤 I/O보다 순차 I/O가 효율적 |
| 테이블 크기 작음 | 인덱스 탐색 오버헤드가 더 큼 |
| 인덱스 컬럼에 함수 적용 | 인덱스 값 비교 불가 |
| 암시적 형변환 | 타입 불일치로 인덱스 사용 불가 |
| 통계 정보 부정확 | ANALYZE TABLE 필요 |

**만약 강제로 인덱스를 사용하면?**
- FORCE INDEX: 옵티마이저 판단 무시
- 오히려 성능 저하 가능
- 통계 갱신 후 옵티마이저 신뢰 권장

---

### Q: UUID를 PK로 사용하면 안 되는 이유는?

**A:** UUID는 랜덤 값이라 클러스터드 인덱스 삽입 시 페이지 분할이 빈번하게 발생합니다.

**왜 문제인가?**

| PK 타입 | 삽입 위치 | 페이지 분할 | INSERT 성능 |
|---------|----------|------------|------------|
| AUTO_INCREMENT | 항상 끝 | 거의 없음 | 빠름 |
| UUID v4 | 랜덤 | 빈번 | 느림 |
| UUID v7 | 시간순 | 적음 | 보통 |

**만약 반드시 UUID를 사용해야 한다면?**
- UUID v7 사용 (시간 기반 정렬)
- BINARY(16)로 저장 (VARCHAR(36)보다 작음)
- 세컨더리 인덱스 최소화 (PK 크기 영향)

---

## 참고 자료

- [MySQL 8.0 Reference Manual - InnoDB Indexes](https://dev.mysql.com/doc/refman/8.0/en/innodb-indexes.html)
- [MySQL 8.0 Reference Manual - EXPLAIN Output Format](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html)
- Real MySQL 8.0 (위키북스)
- High Performance MySQL (O'Reilly)
