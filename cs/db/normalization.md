# Normalization (정규화)

> 데이터 중복을 최소화하고 데이터 무결성을 보장하기 위해 테이블을 체계적으로 분해하는 과정

> `[3] 중급` · 선수 지식: [SQL](./sql.md)

`#정규화` `#Normalization` `#1NF` `#제1정규형` `#FirstNormalForm` `#2NF` `#제2정규형` `#SecondNormalForm` `#3NF` `#제3정규형` `#ThirdNormalForm` `#BCNF` `#보이스코드정규형` `#반정규화` `#Denormalization` `#데이터무결성` `#DataIntegrity` `#DB설계` `#DatabaseDesign` `#함수적종속` `#FunctionalDependency` `#이상현상` `#Anomaly` `#삽입이상` `#갱신이상` `#삭제이상` `#중복제거`

## 왜 알아야 하는가?

정규화는 데이터베이스 설계의 가장 기본이자 핵심입니다. 잘못 설계된 테이블은 데이터 중복, 갱신 이상, 삽입/삭제 이상 등의 문제를 일으켜 유지보수 비용을 기하급수적으로 증가시킵니다. 반대로 과도한 정규화는 JOIN이 많아져 성능 저하를 초래할 수 있습니다. 백엔드 개발자라면 1NF, 2NF, 3NF의 원리를 이해하고, 언제 정규화를 적용하고 언제 반정규화를 선택해야 하는지 판단할 수 있어야 합니다. 이는 확장 가능하고 유지보수하기 쉬운 시스템을 만드는 첫걸음입니다.

## 핵심 개념

- **정규화 (Normalization)**: 중복 제거 및 무결성 향상을 위한 테이블 분해 과정
- **이상 현상 (Anomaly)**: 중복된 데이터로 인해 발생하는 삽입/갱신/삭제 문제
- **함수적 종속성 (Functional Dependency)**: 한 속성이 다른 속성을 고유하게 결정하는 관계
- **정규형 (Normal Form)**: 1NF, 2NF, 3NF, BCNF, 4NF, 5NF 단계
- **반정규화 (Denormalization)**: 성능을 위해 의도적으로 중복을 허용하는 것

## 쉽게 이해하기

**정규화**를 정리정돈에 비유할 수 있습니다.

**정규화 전 (어질러진 방)**:
책상 위에 책, 노트, 펜, 옷, 음식이 뒤섞여 있습니다.
- 필요한 책을 찾기 어려움
- 같은 책이 여러 곳에 흩어져 있음
- 책 정보를 수정하려면 여러 곳을 다 찾아야 함

**정규화 후 (정리된 방)**:
- 책은 책장에 (카테고리별로)
- 옷은 옷장에
- 펜은 필통에
- 음식은 냉장고에

**이상 현상**은 잘못 정리된 상태에서 발생하는 문제입니다:

**삽입 이상**: "새 책을 사고 싶은데, 책장이 가득 차서 책상에 둠 → 나중에 찾기 힘듦"
**갱신 이상**: "같은 책이 책상, 침대, 창문가에 있는데, 한 곳만 최신판으로 교체 → 버전 불일치"
**삭제 이상**: "책을 버렸는데, 그 책의 목차 메모도 함께 사라짐 → 정보 손실"

**반정규화**는 "자주 읽는 책은 책장과 책상 모두에 둠 (빠르게 접근 가능, 대신 중복)"

## 상세 설명

### 이상 현상 (Anomaly)

정규화가 필요한 이유를 이해하기 위해 먼저 이상 현상을 살펴봅니다.

**정규화 전 테이블 예시**:

| 학번 | 학생명 | 학과 | 학과장 | 과목코드 | 과목명 | 성적 |
|-----|-------|------|--------|---------|--------|-----|
| 1001 | 김철수 | 컴퓨터 | 박교수 | CS101 | 자료구조 | A |
| 1001 | 김철수 | 컴퓨터 | 박교수 | CS102 | 알고리즘 | B |
| 1002 | 이영희 | 전자 | 최교수 | EE201 | 회로이론 | A |

#### 1. 삽입 이상 (Insertion Anomaly)

**문제**: 새 학생이 아직 과목을 수강하지 않았다면 등록 불가

```sql
-- 불가능: 과목코드, 과목명, 성적이 NULL이면 삽입 불가
INSERT INTO students VALUES (1003, '박민수', '경영', '정교수', NULL, NULL, NULL);
```

**왜 문제인가?**

학생 정보와 수강 정보가 하나의 테이블에 섞여 있어, 수강 정보 없이는 학생을 등록할 수 없습니다.

#### 2. 갱신 이상 (Update Anomaly)

**문제**: "박교수"가 "김교수"로 변경되면 여러 행을 모두 수정해야 함

```sql
-- 1001 학생의 2개 행을 모두 업데이트해야 함
UPDATE students SET 학과장 = '김교수' WHERE 학과 = '컴퓨터';
-- 만약 일부만 업데이트하면 데이터 불일치 발생
```

**왜 문제인가?**

같은 정보(학과장)가 여러 행에 중복 저장되어, 일부만 수정하면 데이터 불일치가 발생합니다.

#### 3. 삭제 이상 (Deletion Anomaly)

**문제**: 1002 학생이 "회로이론" 수강을 취소하면 학생 정보까지 사라짐

```sql
-- EE201 삭제 시 이영희의 모든 정보가 사라짐
DELETE FROM students WHERE 학번 = 1002 AND 과목코드 = 'EE201';
```

**왜 문제인가?**

원하지 않는 정보까지 함께 삭제됩니다. 수강 정보만 삭제하고 싶은데 학생 정보까지 사라집니다.

### 함수적 종속성 (Functional Dependency)

**정의**: A → B (A가 B를 결정)
- A 값이 정해지면 B 값이 유일하게 결정됨

**예시**:
- 학번 → 학생명, 학과 (학번으로 학생명과 학과를 유일하게 결정)
- 학과 → 학과장 (학과로 학과장을 유일하게 결정)
- 과목코드 → 과목명 (과목코드로 과목명을 유일하게 결정)
- (학번, 과목코드) → 성적 (학번과 과목코드 조합으로 성적을 결정)

**왜 중요한가?**

함수적 종속성을 분석해야 어떻게 테이블을 분해할지 결정할 수 있습니다.

### 정규화 단계

#### 제1정규형 (1NF: First Normal Form)

**조건**: 모든 속성의 값이 원자값(Atomic Value)이어야 함

**비정규형 (X)**:

| 학번 | 학생명 | 수강과목 |
|-----|-------|---------|
| 1001 | 김철수 | 자료구조, 알고리즘, DB |
| 1002 | 이영희 | 회로이론 |

**문제**: 수강과목이 복수 값을 가짐 (원자값 위반)

**1NF 적용 (O)**:

| 학번 | 학생명 | 수강과목 |
|-----|-------|---------|
| 1001 | 김철수 | 자료구조 |
| 1001 | 김철수 | 알고리즘 |
| 1001 | 김철수 | DB |
| 1002 | 이영희 | 회로이론 |

**왜 이렇게 하는가?**

복수 값은 쿼리, 인덱싱, 제약 조건 적용이 어렵습니다. 원자값으로 분리해야 표준 SQL로 처리 가능합니다.

#### 제2정규형 (2NF: Second Normal Form)

**조건**: 1NF + 부분 함수 종속 제거 (모든 비주요 속성이 기본키 전체에 완전 함수 종속)

**1NF 테이블 (X)**:

| 학번 | 과목코드 | 학생명 | 학과 | 과목명 | 성적 |
|-----|---------|-------|------|--------|-----|
| 1001 | CS101 | 김철수 | 컴퓨터 | 자료구조 | A |
| 1001 | CS102 | 김철수 | 컴퓨터 | 알고리즘 | B |

**기본키**: (학번, 과목코드)

**문제**: 부분 함수 종속 존재
- 학번 → 학생명, 학과 (기본키의 일부인 학번만으로 결정)
- 과목코드 → 과목명 (기본키의 일부인 과목코드만으로 결정)

**2NF 적용 (O)**: 3개 테이블로 분해

**학생 테이블**:
| 학번 | 학생명 | 학과 |
|-----|-------|------|
| 1001 | 김철수 | 컴퓨터 |
| 1002 | 이영희 | 전자 |

**과목 테이블**:
| 과목코드 | 과목명 |
|---------|--------|
| CS101 | 자료구조 |
| CS102 | 알고리즘 |

**수강 테이블**:
| 학번 | 과목코드 | 성적 |
|-----|---------|-----|
| 1001 | CS101 | A |
| 1001 | CS102 | B |

**왜 분리하는가?**

부분 함수 종속을 제거하면 갱신 이상이 사라집니다. "자료구조"를 "자료구조론"으로 변경할 때 과목 테이블 1곳만 수정하면 됩니다.

#### 제3정규형 (3NF: Third Normal Form)

**조건**: 2NF + 이행적 함수 종속 제거 (모든 속성이 기본키에만 의존)

**2NF 테이블 (X)**:

학생 테이블:
| 학번 | 학생명 | 학과 | 학과장 |
|-----|-------|------|--------|
| 1001 | 김철수 | 컴퓨터 | 박교수 |
| 1002 | 이영희 | 전자 | 최교수 |

**기본키**: 학번

**함수적 종속성**:
- 학번 → 학과 (O)
- 학과 → 학과장 (O)
- **학번 → 학과장** (이행적 함수 종속 - 학번 → 학과 → 학과장)

**문제**: 학과장은 학번에 직접 종속되지 않고 학과를 거쳐 종속됨

**3NF 적용 (O)**:

**학생 테이블**:
| 학번 | 학생명 | 학과 |
|-----|-------|------|
| 1001 | 김철수 | 컴퓨터 |
| 1002 | 이영희 | 전자 |

**학과 테이블**:
| 학과 | 학과장 |
|------|--------|
| 컴퓨터 | 박교수 |
| 전자 | 최교수 |

**왜 분리하는가?**

학과장 정보가 한 곳에만 저장되어, "박교수"를 "김교수"로 변경할 때 학과 테이블 1곳만 수정하면 됩니다. 갱신 이상 제거.

#### BCNF (Boyce-Codd Normal Form)

**조건**: 3NF + 모든 결정자가 후보키

**3NF이지만 BCNF가 아닌 경우 (X)**:

교수-과목 테이블:
| 교수 | 과목 | 시간 |
|-----|------|------|
| 박교수 | DB | 월1 |
| 최교수 | 알고리즘 | 화1 |
| 박교수 | 자료구조 | 수1 |

**가정**:
- 한 교수는 한 시간에 하나의 과목만 강의
- 한 과목은 한 교수만 강의

**기본키**: (교수, 과목)

**함수적 종속성**:
- (교수, 과목) → 시간
- **시간 → 교수** (문제: 시간이 결정자이지만 후보키가 아님)

**BCNF 적용 (O)**:

**교수-시간 테이블**:
| 시간 | 교수 |
|------|------|
| 월1 | 박교수 |
| 화1 | 최교수 |
| 수1 | 박교수 |

**교수-과목 테이블**:
| 교수 | 과목 |
|-----|------|
| 박교수 | DB |
| 최교수 | 알고리즘 |
| 박교수 | 자료구조 |

**왜 필요한가?**

후보키가 아닌 결정자가 있으면 이상 현상이 발생할 수 있습니다.

### 정규화의 장단점

**장점**:
1. **중복 제거**: 같은 정보를 한 곳에만 저장
2. **갱신 이상 방지**: 한 곳만 수정하면 됨
3. **삽입/삭제 이상 방지**: 독립적으로 정보 관리
4. **저장 공간 절약**: 중복 데이터 감소
5. **데이터 무결성 향상**: 일관성 보장

**단점**:
1. **조회 성능 저하**: JOIN 연산 증가
2. **쿼리 복잡도 증가**: 여러 테이블 조인 필요
3. **인덱스 관리 복잡**: 테이블 수 증가

### 반정규화 (Denormalization)

**정의**: 성능 향상을 위해 의도적으로 중복을 허용하는 것

**언제 사용하나?**

1. **읽기가 매우 빈번하고 쓰기가 적을 때**
2. **JOIN이 성능 병목이 될 때**
3. **실시간 응답이 중요할 때** (통계, 대시보드)

**반정규화 기법**:

#### 1. 컬럼 추가 (파생 컬럼)

**정규화된 상태**:

주문 테이블:
| 주문ID | 사용자ID | 주문일시 |
|-------|---------|----------|
| 1 | 101 | 2024-01-01 |

주문상세 테이블:
| 주문ID | 상품ID | 수량 | 가격 |
|-------|--------|------|------|
| 1 | 1 | 2 | 10000 |
| 1 | 2 | 1 | 20000 |

**조회 시**: 총 금액을 구하려면 GROUP BY + SUM 필요

**반정규화**: 주문 테이블에 총 금액 컬럼 추가

주문 테이블:
| 주문ID | 사용자ID | 주문일시 | **총금액** |
|-------|---------|----------|----------|
| 1 | 101 | 2024-01-01 | **40000** |

**장점**: 주문 목록 조회 시 JOIN 없이 총 금액 확인 가능
**단점**: 주문상세 변경 시 주문 테이블도 함께 업데이트 필요

#### 2. 테이블 통합

**정규화된 상태**:

사용자 테이블 + 사용자상세 테이블 (1:1)

**반정규화**: 하나의 테이블로 통합

**사용자 테이블**:
| 사용자ID | 이름 | 이메일 | 주소 | 전화번호 | 생년월일 |

**장점**: JOIN 제거
**단점**: 테이블 크기 증가, NULL 값 증가 가능

#### 3. 중복 컬럼 추가

**정규화된 상태**:

주문 테이블 → 사용자 테이블 (사용자 이름 조회 시 JOIN 필요)

**반정규화**: 주문 테이블에 사용자 이름 추가

주문 테이블:
| 주문ID | 사용자ID | **사용자명** | 주문일시 |
|-------|---------|------------|----------|
| 1 | 101 | **김철수** | 2024-01-01 |

**장점**: 주문 목록에서 사용자 이름을 바로 확인 (JOIN 불필요)
**단점**: 사용자 이름 변경 시 주문 테이블도 업데이트 필요 (또는 변경 안 함)

**주의**: 이름 변경을 반영하지 않는다면, "주문 당시의 이름"이라는 의미로 사용 가능

#### 4. 집계 테이블 (Summary Table)

**정규화된 상태**:

매일 주문 통계를 조회할 때마다 수백만 건을 집계

**반정규화**: 일별 통계 테이블 생성

**일별통계 테이블**:
| 날짜 | 총주문수 | 총매출 |
|------|---------|--------|
| 2024-01-01 | 1500 | 15000000 |
| 2024-01-02 | 1800 | 18000000 |

**생성 방법**: 배치 작업 (매일 자정에 집계)

**장점**: 대시보드 조회 시 빠른 응답
**단점**: 실시간 데이터 아님 (배치 주기만큼 지연)

### 반정규화 주의사항

**1. 데이터 일관성 관리**

```sql
-- 주문 생성 시 총 금액 계산 및 저장
START TRANSACTION;
INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (1, 1, 2, 10000);
INSERT INTO order_items (order_id, product_id, quantity, price) VALUES (1, 2, 1, 20000);
-- 총 금액 계산 후 주문 테이블 업데이트
UPDATE orders SET total_amount = (SELECT SUM(quantity * price) FROM order_items WHERE order_id = 1) WHERE order_id = 1;
COMMIT;
```

**2. 트리거 활용**

```sql
-- 주문상세 변경 시 자동으로 총 금액 업데이트
CREATE TRIGGER update_order_total
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
BEGIN
    UPDATE orders SET total_amount = (SELECT SUM(quantity * price) FROM order_items WHERE order_id = NEW.order_id) WHERE order_id = NEW.order_id;
END;
```

**3. 변경 불가 데이터만 중복**

- 주문 당시의 상품명, 가격 → 변경되지 않으므로 중복 저장 안전
- 사용자 이름 → 변경 가능하므로 중복 저장 시 주의

## 트레이드오프

| 항목 | 정규화 | 반정규화 |
|------|--------|---------|
| 중복 | 최소화 | 허용 |
| 조회 성능 | 낮음 (JOIN 많음) | 높음 (JOIN 적음) |
| 쓰기 성능 | 높음 | 낮음 (여러 곳 업데이트) |
| 데이터 일관성 | 높음 (한 곳만 관리) | 낮음 (동기화 필요) |
| 저장 공간 | 적음 | 많음 (중복) |
| 쿼리 복잡도 | 높음 | 낮음 |
| 사용처 | OLTP (트랜잭션 많음) | OLAP (분석, 조회 많음) |

**결론**:
- 일반적으로 **3NF까지 정규화**를 권장
- **조회가 빈번하고 성능이 중요한 경우** 선별적으로 반정규화
- 반정규화 시 **데이터 일관성 유지 전략** 필수

## 면접 예상 질문

- Q: 정규화를 왜 하나요?
  - A: 데이터 중복을 제거하고 이상 현상을 방지하기 위해서입니다. **왜냐하면** 같은 정보가 여러 곳에 저장되면 (1) 갱신 이상: 일부만 수정 시 데이터 불일치 (2) 삽입 이상: 불필요한 정보 없이는 삽입 불가 (3) 삭제 이상: 원하지 않는 정보까지 삭제가 발생하기 때문입니다. **예시**: 학생-수강 테이블에서 학과장 정보가 중복 저장되면, 학과장 변경 시 모든 학생 행을 업데이트해야 하고, 하나라도 빠뜨리면 불일치 발생. **따라서** 학과 테이블을 분리하면 한 곳만 수정하면 됩니다.

- Q: 1NF, 2NF, 3NF의 차이를 설명해주세요.
  - A: (1) **1NF**: 모든 속성이 원자값이어야 함. 한 셀에 복수 값 저장 불가. **왜냐하면** 복수 값은 쿼리와 인덱싱이 불가능하기 때문. (2) **2NF**: 1NF + 부분 함수 종속 제거. 기본키가 복합키일 때, 모든 속성이 기본키 전체에 종속되어야 함. **왜냐하면** 기본키 일부에만 종속되면 해당 정보를 별도 테이블로 분리해야 중복이 제거되기 때문. (3) **3NF**: 2NF + 이행적 함수 종속 제거. 모든 속성이 기본키에만 직접 종속. **왜냐하면** A→B→C처럼 간접 종속이 있으면 B 관련 정보를 별도 테이블로 분리해야 갱신 이상이 사라지기 때문.

- Q: 반정규화는 언제 하나요?
  - A: 조회 성능이 매우 중요하고, 읽기가 쓰기보다 압도적으로 많을 때 선별적으로 사용합니다. **왜냐하면** 정규화된 테이블은 JOIN이 많아 조회 성능이 저하될 수 있기 때문입니다. **예시**: (1) 주문 목록에서 주문 총 금액을 자주 조회하는데, 매번 주문상세를 SUM하면 느림 → 주문 테이블에 총 금액 컬럼 추가 (2) 일별 매출 통계 대시보드 → 집계 테이블 생성 (배치). **주의사항**: 반정규화 시 데이터 일관성 유지 전략(트리거, 애플리케이션 로직)이 필수입니다. **트레이드오프**: 조회는 빠르지만, 쓰기 시 여러 곳 업데이트 필요.

- Q: 정규화된 테이블의 조회 성능을 개선하는 방법은?
  - A: 반정규화 외에도 여러 방법이 있습니다. (1) **인덱스 추가**: JOIN에 사용되는 컬럼에 인덱스 생성 (2) **커버링 인덱스**: 조회하는 모든 컬럼을 인덱스에 포함하여 테이블 접근 제거 (3) **뷰(View) 활용**: 복잡한 JOIN을 뷰로 캡슐화 (4) **캐시 활용**: Redis 등에 조회 결과 캐싱 (5) **읽기 전용 복제본**: Master-Slave 구조로 읽기는 Slave에서. **왜 이 방법들이 좋은가?** 정규화의 장점(데이터 일관성)을 유지하면서 성능을 개선할 수 있기 때문입니다. 반정규화는 최후의 수단으로 사용하는 것이 좋습니다.

- Q: 함수적 종속성이 무엇이고 왜 중요한가요?
  - A: A→B는 A 값이 정해지면 B 값이 유일하게 결정되는 관계입니다. **예시**: 학번→학생명 (학번으로 학생명 결정), 학과→학과장 (학과로 학과장 결정). **왜 중요한가?** 정규화 과정에서 테이블을 어떻게 분해할지 결정하는 기준이 되기 때문입니다. **예를 들어**, 2NF는 부분 함수 종속을 제거하고, 3NF는 이행적 함수 종속을 제거합니다. 함수적 종속성을 분석하면 어떤 속성이 어느 테이블에 속해야 할지 알 수 있습니다. **결과**: 중복 제거 및 이상 현상 방지.

## 연관 문서

- [SQL](./sql.md): 정규화된 테이블에서의 JOIN 쿼리
- [Index](./index.md): 정규화 후 성능 최적화를 위한 인덱스
- [Transaction](./transaction.md): 정규화와 트랜잭션 무결성
- [JPA](./jpa.md): ORM에서의 Entity 설계와 정규화

## 참고 자료

- [Database System Concepts - Silberschatz](https://www.db-book.com/)
- [MySQL 공식 문서 - Normalization](https://dev.mysql.com/doc/refman/8.0/en/data-types.html)
- [Wikipedia - Database Normalization](https://en.wikipedia.org/wiki/Database_normalization)
