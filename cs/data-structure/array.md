# 배열 (Array)

> 동일한 타입의 데이터를 연속된 메모리 공간에 저장하는 선형 자료구조

## 핵심 개념

- **연속 메모리 할당**: 데이터들이 메모리상에서 물리적으로 연속된 공간에 저장됨
- **인덱스 기반 O(1) 접근**: 시작 주소 + (인덱스 × 요소 크기)로 즉시 접근 가능
- **고정 크기 (정적 배열)**: 생성 시 크기가 결정되며 변경 불가 (C, Java의 기본 배열)
- **동적 크기 (동적 배열)**: 필요에 따라 자동으로 크기 조정 (ArrayList, Vector, Python list)
- **캐시 친화적**: 연속 메모리 덕분에 CPU 캐시 히트율이 높아 성능 우수

## 쉽게 이해하기

**배열**을 사물함에 비유할 수 있습니다.

학교나 헬스장의 사물함을 떠올려 보세요. 각 사물함에는 1번, 2번, 3번... 번호가 붙어있고, 연속된 벽면에 나란히 배치되어 있습니다.

예를 들어, 7번 사물함에 접근하려면:
- 사물함 시작 위치를 알고 있으므로
- 정확히 7번째 칸으로 바로 이동 가능
- 1번부터 순서대로 찾아갈 필요 없음

하지만 중간에 새 사물함을 끼워넣을 수는 없습니다. 사물함이 이미 고정되어 있기 때문입니다. 마찬가지로 배열도 중간 삽입/삭제가 비효율적입니다.

## 상세 설명

### 연속 메모리 할당

배열의 모든 요소는 메모리상에서 물리적으로 인접한 공간에 저장됩니다.

**왜 이렇게 하는가?**

연속 메모리 할당을 통해 **O(1) 시간에 임의 접근**이 가능하기 때문입니다.

예를 들어, `int arr[5]`가 메모리 주소 1000부터 시작한다면:
- `arr[0]`: 1000
- `arr[1]`: 1004 (int 4바이트)
- `arr[2]`: 1008
- `arr[3]`: 1012
- `arr[4]`: 1016

`arr[3]`에 접근하려면 단순히 `1000 + (3 × 4) = 1012` 주소를 계산하면 됩니다. 이는 **배열 크기와 무관하게 항상 일정한 시간**이 걸립니다.

### 정적 배열 vs 동적 배열

#### 정적 배열 (Static Array)

**특징**:
- 컴파일 타임 또는 선언 시 크기 결정
- 스택 또는 정적 메모리 영역에 할당
- 크기 변경 불가

**예시 (Java)**:
```java
int[] arr = new int[10]; // 크기 10으로 고정
```

**왜 정적 배열을 사용하나?**

- **메모리 효율**: 필요한 크기만 정확히 할당, 추가 오버헤드 없음
- **성능**: 크기 조정 로직이 없어 빠름
- **예측 가능성**: 메모리 사용량을 미리 알 수 있음

**언제 사용하나?**

- 데이터 개수가 명확히 정해진 경우 (예: RGB 색상 [3], 주사위 면 [6])
- 임베디드 시스템처럼 메모리가 제한된 환경

#### 동적 배열 (Dynamic Array)

**특징**:
- 런타임에 크기 자동 조정
- 힙 메모리에 할당
- 용량 초과 시 더 큰 배열 생성 후 복사

**예시 (Java ArrayList)**:
```java
ArrayList<Integer> list = new ArrayList<>(); // 초기 용량 10
list.add(1); // 동적으로 추가 가능
```

**왜 동적 배열을 사용하나?**

- **유연성**: 데이터 개수를 미리 알 수 없을 때 유용
- **편의성**: 크기 관리를 자동으로 해줌

**동작 원리 (크기 조정)**:

1. 현재 용량: 10
2. 11번째 요소 추가 시도
3. 새 배열 생성 (보통 현재 크기의 1.5~2배, Java는 1.5배)
4. 기존 요소 전부 복사 → O(N)
5. 새 요소 추가

**주의사항**:
- 크기 조정 시 O(N) 시간 소요
- 기존 배열 메모리는 가비지 컬렉션 대상
- **평균적으로는 O(1)** (Amortized): 크기 조정이 자주 발생하지 않으므로

### 배열 연산의 시간 복잡도

| 연산 | 시간 복잡도 | 이유 |
|------|------------|------|
| 접근 (Access) | O(1) | 인덱스로 주소 계산 즉시 가능 |
| 탐색 (Search) | O(N) | 최악의 경우 전체 순회 필요 |
| 삽입 (Insert) - 끝 | O(1) (동적 배열 평균) | 마지막 위치에 추가만 하면 됨 |
| 삽입 - 중간/앞 | O(N) | 뒤 요소들을 전부 한 칸씩 이동 |
| 삭제 (Delete) - 끝 | O(1) | 마지막 요소만 제거 |
| 삭제 - 중간/앞 | O(N) | 뒤 요소들을 전부 한 칸씩 앞으로 이동 |

### 배열의 장단점

| 장점 | 단점 |
|------|------|
| **O(1) 접근 속도**: 인덱스만 알면 즉시 접근 | **크기 고정** (정적 배열): 초과 시 확장 불가 |
| **메모리 효율**: 포인터 등 추가 공간 불필요 | **중간 삽입/삭제 비효율**: O(N) 시간 소요 |
| **캐시 친화적**: 연속 메모리로 CPU 캐시 활용 우수 | **메모리 낭비 가능** (동적 배열): 미리 큰 용량 할당 |
| **간단한 구조**: 구현과 사용이 직관적 | **타입 고정**: 동일 타입만 저장 가능 (정적 타입 언어) |

**왜 캐시 친화적인가?**

CPU는 메모리에서 데이터를 읽을 때 주변 데이터도 함께 캐시에 로드합니다 (Spatial Locality). 배열의 연속 메모리 덕분에 `arr[i]`를 읽으면 `arr[i+1]`, `arr[i+2]`도 캐시에 있을 확률이 높아 빠릅니다.

### 다차원 배열

**2차원 배열 (Matrix)**:
```java
int[][] matrix = new int[3][4]; // 3행 4열
```

**메모리 배치**:
- **행 우선 순서 (Row-major)**: C, Java - `[0][0], [0][1], [0][2], [0][3], [1][0]...`
- **열 우선 순서 (Column-major)**: Fortran, MATLAB - `[0][0], [1][0], [2][0], [0][1]...`

**왜 순서가 중요한가?**

캐시 효율 때문입니다. 행 우선 배열을 열 단위로 순회하면 캐시 미스가 많이 발생해 성능이 저하됩니다.

```java
// Good (행 우선 배열에서 행 단위 순회 - 캐시 친화적)
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        sum += matrix[i][j];
    }
}

// Bad (행 우선 배열에서 열 단위 순회 - 캐시 미스 많음)
for (int j = 0; j < cols; j++) {
    for (int i = 0; i < rows; i++) {
        sum += matrix[i][j]; // 메모리상 떨어진 위치 접근
    }
}
```

## 시간 복잡도

| 연산 | 정적 배열 | 동적 배열 (평균) | 동적 배열 (최악) |
|------|----------|-----------------|-----------------|
| Access | O(1) | O(1) | O(1) |
| Search | O(N) | O(N) | O(N) |
| Insert (끝) | - | O(1) | O(N) - 크기 조정 |
| Insert (중간) | - | O(N) | O(N) |
| Delete (끝) | - | O(1) | O(1) |
| Delete (중간) | - | O(N) | O(N) |

## 예제 코드

### 동적 배열 구현 (간단한 버전)

```java
public class DynamicArray {
    private int[] data;
    private int size;      // 현재 저장된 요소 개수
    private int capacity;  // 현재 배열 용량

    public DynamicArray() {
        capacity = 10;
        data = new int[capacity];
        size = 0;
    }

    // O(1) 평균, O(N) 최악 (크기 조정 시)
    public void add(int value) {
        if (size == capacity) {
            resize(); // 용량 초과 시 크기 조정
        }
        data[size++] = value;
    }

    // O(1)
    public int get(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return data[index];
    }

    // O(N) - 기존 요소 복사
    private void resize() {
        capacity *= 2; // 용량 2배 증가
        int[] newData = new int[capacity];

        // 기존 요소 복사
        for (int i = 0; i < size; i++) {
            newData[i] = data[i];
        }

        data = newData; // 새 배열로 교체
    }

    // O(N) - 뒤 요소들을 앞으로 이동
    public void remove(int index) {
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException();
        }

        // 뒤 요소들을 한 칸씩 앞으로 이동
        for (int i = index; i < size - 1; i++) {
            data[i] = data[i + 1];
        }
        size--;
    }
}
```

**왜 2배로 늘리는가?**

- 1.5배, 2배 등 배수로 늘리면 Amortized O(1) 달성
- 너무 크게 늘리면 (예: 10배) 메모리 낭비
- 너무 작게 늘리면 (예: +10) 크기 조정이 자주 발생해 비효율

**Amortized O(1) 분석**:
- N개 요소 추가 시, 크기 조정은 log N번 발생 (1, 2, 4, 8, 16... N)
- 총 복사 횟수: 1 + 2 + 4 + ... + N = 2N - 1
- 평균: (2N - 1) / N ≈ 2 = O(1)

## 트레이드오프

### 배열 vs 연결 리스트

| 기준 | 배열 | 연결 리스트 |
|------|------|------------|
| 접근 속도 | O(1) - 인덱스로 즉시 | O(N) - 순차 탐색 필요 |
| 중간 삽입/삭제 | O(N) - 요소 이동 필요 | O(1) - 포인터만 변경 (위치 알 때) |
| 메모리 효율 | 높음 - 데이터만 저장 | 낮음 - 포인터 추가 공간 |
| 캐시 성능 | 우수 - 연속 메모리 | 나쁨 - 메모리 분산 |
| 크기 조정 | 어려움 (정적) / 비용 있음 (동적) | 쉬움 - 노드 추가만 |

**언제 배열을 사용하나?**

- 인덱스 기반 접근이 많을 때
- 데이터 개수가 고정되거나 예측 가능할 때
- 메모리 효율이 중요할 때
- 순차 접근이 많을 때 (캐시 효율)

**언제 연결 리스트를 사용하나?**

- 중간 삽입/삭제가 빈번할 때
- 데이터 크기가 동적으로 크게 변할 때
- 순차 접근만 필요할 때

## 면접 예상 질문

- Q: 배열의 접근 시간 복잡도가 O(1)인 이유는?
  - A: 배열은 연속된 메모리 공간에 데이터를 저장하므로, 시작 주소와 인덱스만 알면 `시작 주소 + (인덱스 × 요소 크기)`로 즉시 계산할 수 있습니다. 이는 배열 크기와 무관하게 항상 일정한 시간이 걸리므로 O(1)입니다.

- Q: 동적 배열(ArrayList)의 add 연산이 평균 O(1)이지만 최악 O(N)인 이유는?
  - A: 대부분의 경우 마지막 위치에 추가만 하면 되므로 O(1)입니다. 하지만 용량이 꽉 찬 경우, 더 큰 배열을 새로 할당하고 기존 요소를 모두 복사해야 하므로 O(N)이 걸립니다. 다만 크기 조정은 드물게 발생하므로 평균적으로는 O(1)입니다 (Amortized Analysis).

- Q: 배열 중간에 요소를 삽입/삭제하는 시간 복잡도가 O(N)인 이유는?
  - A: 배열은 연속된 메모리 공간을 사용하므로, 중간에 요소를 삽입하려면 그 뒤의 모든 요소를 한 칸씩 뒤로 이동해야 합니다. 삭제도 마찬가지로 뒤 요소들을 앞으로 이동해야 합니다. 최악의 경우 맨 앞 삽입/삭제 시 N개 요소를 모두 이동해야 하므로 O(N)입니다.

- Q: 배열과 연결 리스트 중 언제 무엇을 선택해야 하나?
  - A: 인덱스 기반 접근이 많고 크기가 고정적이면 배열을 선택합니다. 배열은 O(1) 접근과 우수한 캐시 성능을 제공하기 때문입니다. 반면 중간 삽입/삭제가 빈번하고 크기가 동적으로 변한다면 연결 리스트를 선택합니다. 연결 리스트는 포인터만 변경하면 되므로 O(1)에 삽입/삭제가 가능하기 때문입니다.

- Q: 2차원 배열 순회 시 행 우선 vs 열 우선의 성능 차이가 나는 이유는?
  - A: 대부분의 언어(C, Java)는 행 우선 순서로 메모리에 저장합니다. 행 단위로 순회하면 메모리상 연속된 위치를 접근하므로 CPU 캐시 히트율이 높습니다. 하지만 열 단위로 순회하면 메모리상 떨어진 위치를 접근하므로 캐시 미스가 많이 발생해 성능이 저하됩니다. 예를 들어 1000×1000 행렬에서 열 우선 순회는 행 우선보다 수십 배 느릴 수 있습니다.

## 참고 자료

- Introduction to Algorithms (CLRS) - Chapter 2
- [Wikipedia: Array data structure](https://en.wikipedia.org/wiki/Array_data_structure)
- [Dynamic Array Amortized Analysis](https://stackoverflow.com/questions/200384/constant-amortized-time)
- Java ArrayList 소스 코드: [OpenJDK ArrayList.java](https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/ArrayList.java)
