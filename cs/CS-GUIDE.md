# CS 학습 문서 작성 가이드

이 문서는 CS 지식 문서 작성 시 Claude가 참고하는 가이드입니다.

---

## 목차

1. [개요](#개요)
   - [카테고리 구조](#카테고리-구조)
2. [문서 작성 템플릿](#문서-작성-템플릿)
3. [작성 규칙](#작성-규칙)
   - [파일명 규칙](#파일명-규칙)
   - [내용 작성 규칙](#내용-작성-규칙)
   - [전문 용어 설명](#전문-용어-설명)
   - [품질 기준](#품질-기준)
4. [작성 가이드](#작성-가이드)
   - ["왜?" 중심 작성 원칙](#왜-중심-작성-원칙)
   - ["된다 / 안 된다" 작성 가이드](#된다--안-된다-작성-가이드)
   - ["언제 사용하나?" 작성 가이드](#언제-사용하나-작성-가이드)
   - ["주의사항/트레이드오프" 작성 가이드](#주의사항트레이드오프-작성-가이드)
   - ["쉽게 이해하기" 작성 가이드](#쉽게-이해하기-작성-가이드)
   - ["면접 질문" 작성 가이드](#면접-질문-작성-가이드)
   - ["심층 분석" 작성 가이드](#심층-분석-작성-가이드)
   - ["트러블슈팅" 작성 가이드](#트러블슈팅-작성-가이드)
5. [작업 흐름](#작업-흐름)
6. [부록](#부록)
   - [A. 카테고리별 주제 레퍼런스](#a-카테고리별-주제-레퍼런스)
   - [B. "쉽게 이해하기" 비유 모음](#b-쉽게-이해하기-비유-모음)

---

## 개요

### 카테고리 구조

```
cs/
├── network/           # 네트워크
├── os/                # 운영체제
├── db/                # 데이터베이스
├── data-structure/    # 자료구조
├── algorithm/         # 알고리즘
├── system-design/     # 시스템 설계
├── programming/       # 프로그래밍 패러다임 & 원칙
├── security/          # 보안
├── git/               # 버전 관리
├── language/          # 언어별 심화 (Java, Kotlin 등)
├── ai-agent/          # AI 에이전트 (MCP, Skill, Hook 등)
├── automation/        # 업무 자동화 (GAS, n8n 등)
└── trend/             # 최신 트렌드 인덱스
```

---

## 난이도 체계

### 난이도 분류 원칙

난이도는 **3개로 고정하지 않고 유연하게 세분화**할 수 있습니다.

**핵심 원칙:**
1. **카테고리 정의가 최우선** - 각 카테고리는 "~란?" 정의 문서로 시작
2. **선수 지식 기반 순서** - 선수 지식이 없는 것 → 있는 것 순서로 난이도 상승
3. **숫자 기반 레벨** - [1], [2], [3]... 로 학습 순서 표현 (고정된 3단계 아님)

### 기본 난이도 레벨

| 레벨 | 설명 | 예시 |
|------|------|------|
| **[1] 정의/기초** | 카테고리 정의, 선수 지식 없음 | "알고리즘이란?", "자료구조란?" |
| **[2] 입문** | 기본 개념, 간단한 선수 지식 | 배열, 프로세스/스레드, TCP/UDP |
| **[3] 중급** | 실무 핵심, 여러 기초 지식 필요 | 인덱스, HTTP, 정렬 알고리즘 |
| **[4] 심화** | 복잡한 개념, 다중 선수 지식 | MVCC, 분산 시스템, DP |
| **[5+] 전문가** | 필요 시 추가 가능 | - |

> **참고**: 모든 카테고리가 5레벨을 채울 필요 없음. 카테고리 특성에 맞게 유연하게 구성.

### 난이도 표기 형식

문서 제목 바로 아래에 난이도와 선수 지식을 표기:

```markdown
# 주제명

> `[1] 정의` · 선수 지식 없음

> `[2] 입문` · 선수 지식: 없음 또는 [선수 문서](./path.md)

> `[3] 중급` · 선수 지식: [선수 문서명](./path.md)

> `[4] 심화` · 선수 지식: [문서1](./path1.md), [문서2](./path2.md)
```

### 카테고리별 난이도 구성 예시

| 카테고리 | [1] 정의/기초 | [2] 입문 | [3] 중급 | [4] 심화 |
|----------|--------------|----------|----------|----------|
| Algorithm | 알고리즘이란, 복잡도 | 정렬, 탐색 | 그래프, 분할정복 | DP, 그래프 심화 |
| Data Structure | 자료구조란 | 배열, 리스트, 스택/큐 | 트리, 해시, 힙 | 그래프, 고급 트리 |
| AI Agent | AI Agent란, LLM 기초 | MCP, Tool Use | Skill, Hook | Agent SDK |
| OS | OS란 | 프로세스/스레드 | 파일시스템, FD | 메모리 관리, 동기화 |
| Network | 네트워크란, OSI | TCP/UDP | HTTP, DNS | 로드밸런싱, CDN |
| DB | DB란 | SQL 기초 | 인덱스, 트랜잭션 | MVCC, 샤딩 |

---

## 연관 문서 링크

### 연관 문서 섹션 형식

참고 자료 바로 위에 연관 문서 섹션을 추가:

```markdown
## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [문서명](./path.md) | 왜 연관되는지 설명 | Beginner/Intermediate/Advanced |
| [선수 문서](./path.md) | 이 문서의 기초 개념 (선수 지식) | Beginner |
| [후속 문서](./path.md) | 이 문서 이후 학습 추천 | Advanced |

## 참고 자료
...
```

### 연관 문서 유형

| 유형 | 설명 | 예시 |
|------|------|------|
| 선수 지식 | 이 문서를 읽기 전에 알아야 할 내용 | 프로세스 → FD의 선수 지식 |
| 후속 학습 | 이 문서 이후 학습하면 좋은 내용 | 프로세스 → 메모리 관리 |
| 관련 개념 | 함께 알면 좋은 내용 | FD ↔ 파일시스템 |
| 카테고리 간 연결 | 다른 카테고리와의 연관성 | DB 인덱스 ↔ 자료구조 B+Tree |
| 정의 문서 | 카테고리의 기본 정의 | 알고리즘이란 → Sort의 선수 지식 |

---

## 카테고리 README 구조

### README.md 필수 구성 요소

```markdown
# {카테고리명}

{한 줄 설명}

## 학습 로드맵

(ASCII 다이어그램으로 학습 순서 시각화 - [1], [2], [3]... 숫자로 순서 표현)

## 난이도별 목차

### [1] 정의/기초
{카테고리의 정의 문서}

| 문서 | 설명 | 예상 시간 |
|------|------|----------|
| [카테고리란](./definition.md) | 카테고리의 정의와 기초 개념 | 20분 |

### [2] 입문
| 문서 | 설명 | 선수 지식 |
|------|------|----------|
| [문서명](./path.md) | 한 줄 설명 | 카테고리란 |

### [3] 중급
| 문서 | 설명 | 선수 지식 |
|------|------|----------|
| [문서명](./path.md) | 한 줄 설명 | 선수 문서명 |

### [4] 심화
| 문서 | 설명 | 선수 지식 |
|------|------|----------|
| [문서명](./path.md) | 한 줄 설명 | 선수 문서명 |

## 전체 목차

- [문서명](./path.md) - 한 줄 설명
```

> **참고**: 레벨은 필요에 따라 [5], [6]으로 확장 가능. 모든 카테고리가 동일한 레벨 수를 가질 필요 없음.

---

## 문서 작성 템플릿

```markdown
# {주제명}

> `[N] {레벨명}` · 선수 지식: [선수 문서](./path.md) 또는 "없음"

> 한 줄 정의

## 왜 알아야 하는가?

{이 개념을 왜 배워야 하는지 - 실무/면접/시스템 이해 관점에서 설명}

- **실무**: {실무에서 어떻게 활용되는지}
- **면접**: {면접에서 왜 자주 나오는지}
- **기반 지식**: {이 개념이 다른 개념의 기반이 되는 이유}

## 핵심 개념

{주제의 핵심 개념 3-5개를 불릿포인트로 정리}

## 쉽게 이해하기

{비전공자도 이해할 수 있는 실생활 비유나 예시로 개념 설명}

## 상세 설명

### {소주제 1}

{상세 내용}

**왜 이렇게 하는가?**
{이유 설명}

### {소주제 2}

**권장 (O)**: {권장 패턴}
**비권장 (X)**: {비권장 패턴}

**왜?**
{구체적인 이유 - 기술적 근거 포함}

**만약 지키지 않으면?**
{실제 발생 가능한 문제}

## 동작 원리 (해당되는 경우)

{순서도, 다이어그램, 또는 단계별 설명}

## 예제 코드 (해당되는 경우)

```java
// 예제 코드
```

## 트레이드오프 (해당되는 경우)

| 장점 | 단점 |
|------|------|
| {장점 1} | {단점 1} |
| {장점 2} | {단점 2} |

## 트러블슈팅 (해당되는 경우)

### 사례 1: {증상/문제 요약}

#### 증상
{발생한 문제 현상}

#### 원인 분석
{왜 발생했는지 분석}

#### 해결 방법
{구체적인 해결 방법}

#### 예방 조치
{재발 방지를 위한 조치}

## 면접 예상 질문

- Q: {질문 1}
  - A: {답변 - "왜?"에 대한 설명 포함}

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [선수 문서](./path.md) | 선수 지식 | Beginner |
| [관련 문서](./path.md) | 관련 개념 설명 | Intermediate |
| [후속 문서](./path.md) | 심화 학습 | Advanced |

## 참고 자료

- {참고 링크 또는 서적}
```

---

## 작성 규칙

### 파일명 규칙

- kebab-case 사용: `tcp-handshake.md`, `process-vs-thread.md`
- 영문 소문자: `index.md` (O), `Index.md` (X)

### 내용 작성 규칙

| 항목 | 규칙 |
|------|------|
| 핵심 개념 | 3-5개의 불릿포인트로 요약 |
| 쉽게 이해하기 | 실생활 비유, 일상 예시로 개념 설명 (비전공자 대상) |
| 상세 설명 | 개념별 소제목(H3)으로 구분, **"왜?"** 포함 필수 |
| 전문 용어 | 처음 등장 시 괄호로 간략한 설명 추가 |
| 예제 코드 | 언어 명시, 주석으로 설명 추가 |
| 면접 질문 | 실제 면접에서 자주 나오는 질문 2-3개, 답변에 이유 포함 |
| 참고 자료 | 공식 문서, 신뢰할 수 있는 출처 |

### 전문 용어 설명

> 문서를 읽다가 용어를 모르면 다시 찾아봐야 하는 번거로움을 줄이기 위해,
> **전문 용어가 처음 등장할 때 간략한 설명을 함께 표기**한다.

#### 표기 방식

| 방식 | 예시 | 사용 시점 |
|------|------|----------|
| 괄호 설명 | `Stateless (무상태)` | 짧은 설명 (1-5단어) |
| 괄호 상세 | `Breaking Change (기존 클라이언트 코드가 동작하지 않게 만드는 변경)` | 중간 길이 설명 |
| 인용구 블록 | `> Cursor: 현재 위치를 가리키는 포인터` | 긴 설명이 필요한 경우 |
| 테이블 헤더 | `멱등성 (동일 요청 반복 시 결과 동일)` | 표 컬럼명에 설명 추가 |

#### 설명이 필요한 용어 유형

- **영문 약어**: DDoS, CRUD, HATEOAS, MVCC 등
- **기술 용어**: 멱등성, 버스트, 업스트림, 페일오버 등
- **개념어**: Breaking Change, Deprecation, Over-fetching 등
- **알고리즘/패턴명**: Token Bucket, Sliding Window 등

#### 예시

```markdown
# Bad - 용어 설명 없음
Rate Limiting을 위해 Token Bucket 알고리즘을 사용한다.
버스트 트래픽을 허용하면서 평균 속도를 제한할 수 있다.

# Good - 용어 설명 포함
Rate Limiting (단위 시간당 API 요청 수 제한)을 위해
Token Bucket 알고리즘을 사용한다.
버스트 (순간 폭주) 트래픽을 허용하면서 평균 속도를 제한할 수 있다.
```

### 품질 기준

| 항목 | 기준 |
|------|------|
| 정확성 | 공식 문서 및 신뢰할 수 있는 출처 기반 |
| 이해 용이성 | 비전공자도 이해할 수 있는 실생활 비유와 예시 포함 |
| 논리성 | 모든 주장에 "왜?"에 대한 답변 포함 |
| 실용성 | 면접 대비, 실무 적용 가능한 내용 |
| 일관성 | 동일한 템플릿과 스타일 유지 |

---

## 작성 가이드

### 정의 우선 원칙

> **모든 학습은 "이것은 무엇인가?"라는 정의에서 시작한다.**

개념을 설명하기 전에 반드시 **명확한 정의**를 먼저 제시한다.

#### 정의 작성 형식

```markdown
> {개념}은 {핵심 동작/역할}을 위한 {분류/범주}이다.
```

#### 정의 예시

| Bad (모호한 정의) | Good (명확한 정의) |
|-------------------|-------------------|
| 알고리즘은 문제를 푸는 방법이다 | 알고리즘은 **주어진 문제를 해결하기 위한 명확하고 유한한 단계의 절차**이다 |
| 자료구조는 데이터를 저장하는 것이다 | 자료구조는 **데이터를 효율적으로 저장, 관리, 접근하기 위한 체계적인 구조**이다 |
| 프로세스는 실행 중인 프로그램이다 | 프로세스는 **운영체제로부터 자원을 할당받아 실행되는 프로그램의 인스턴스**이다 |

### "왜 알아야 하는가?" 원칙

> **개념을 배우기 전에 "왜 이것을 알아야 하는가?"를 먼저 설명한다.**

학습 동기를 부여하고, 개념의 중요성을 이해시키기 위해 다음 3가지 관점에서 설명:

| 관점 | 설명 | 예시 질문 |
|------|------|----------|
| **실무** | 실제 업무에서 어떻게 활용되는가? | "이걸 모르면 실무에서 어떤 문제가 생기는가?" |
| **면접** | 왜 면접에서 자주 물어보는가? | "면접관은 이 질문으로 무엇을 확인하려 하는가?" |
| **기반 지식** | 다른 개념을 이해하는 데 왜 필요한가? | "이것을 모르면 어떤 개념을 이해할 수 없는가?" |

#### 예시

```markdown
## 왜 알아야 하는가?

- **실무**: 시간복잡도를 모르면 성능 문제의 원인을 파악할 수 없다.
  "왜 이 쿼리가 느린가?"에 대한 답은 O(N²) vs O(N log N)의 차이에서 나온다.
- **면접**: 모든 기술 면접에서 "이 알고리즘의 시간복잡도는?"이라는 질문이 나온다.
  복잡도 분석 능력은 개발자의 기본 역량으로 간주된다.
- **기반 지식**: 정렬, 탐색, 자료구조 선택 등 모든 알고리즘 주제의 기반이 된다.
  복잡도를 모르면 "왜 HashMap이 ArrayList보다 빠른가?"를 설명할 수 없다.
```

### 학습 목표 제시 원칙

> **문서를 읽은 후 "무엇을 할 수 있게 되는가?"를 명시한다.**

학습 목표는 구체적이고 검증 가능해야 한다.

#### 학습 목표 형식

```markdown
## 학습 목표

이 문서를 읽고 나면 다음을 할 수 있습니다:

- [ ] {개념}의 정의를 한 문장으로 설명할 수 있다
- [ ] {A}와 {B}의 차이점 3가지를 설명할 수 있다
- [ ] {상황}에서 {개념}을 적용할 수 있다
- [ ] "{면접 질문}"에 답할 수 있다
```

#### 예시

```markdown
## 학습 목표

이 문서를 읽고 나면 다음을 할 수 있습니다:

- [ ] 시간복잡도의 정의를 한 문장으로 설명할 수 있다
- [ ] O(1), O(N), O(log N), O(N²)의 차이를 그래프로 설명할 수 있다
- [ ] 주어진 코드를 보고 시간복잡도를 분석할 수 있다
- [ ] "이 알고리즘의 시간복잡도가 왜 O(N log N)인가요?"에 답할 수 있다
```

---

### 점진적 설명 원칙

> **단순 → 복잡, 익숙 → 낯선 순서로 설명한다.**

| 순서 | 설명 | 예시 |
|------|------|------|
| 1. 정의 | 무엇인가? | "인덱스란 ~이다" |
| 2. 필요성 | 왜 필요한가? | "인덱스가 없으면 ~" |
| 3. 원리 | 어떻게 작동하는가? | "B+Tree 구조로 ~" |
| 4. 사용법 | 어떻게 사용하는가? | "CREATE INDEX ~" |
| 5. 주의사항 | 무엇을 조심해야 하는가? | "너무 많으면 ~" |
| 6. 심화 | 더 깊이 알면 좋은 것 | "클러스터드 vs 논클러스터드" |

---

### "왜?" 중심 작성 원칙

> **모든 설명은 "왜?"라는 질문에 답할 수 있어야 한다.**

단순히 "이렇게 해라" 또는 "이것은 이렇다"가 아닌, **왜 그런지 이유를 반드시 설명**한다.

| Bad (이유 없음) | Good (이유 포함) |
|----------------|-----------------|
| Entity에서 DTO를 생성하면 안 된다 | Entity에서 DTO를 생성하면 안 된다. **왜냐하면** 도메인 계층이 응용 계층에 의존하게 되어 DIP를 위반하고, DTO 변경 시 Entity까지 재컴파일되기 때문이다 |
| 인덱스를 사용하면 조회가 빨라진다 | 인덱스를 사용하면 조회가 빨라진다. **왜냐하면** B+Tree 구조로 O(log N) 탐색이 가능하고, 풀 테이블 스캔 대신 인덱스 스캔만 하면 되기 때문이다 |
| TCP는 신뢰성이 있다 | TCP는 신뢰성이 있다. **왜냐하면** 3-way handshake로 연결을 수립하고, ACK/재전송 메커니즘으로 패킷 손실을 복구하며, 순서 번호로 순서를 보장하기 때문이다 |

#### 기술적 근거 제시

설명에는 반드시 **기술적 근거**를 포함한다:

| 유형 | 예시 |
|------|------|
| 시간/공간 복잡도 | "O(N)에서 O(log N)으로 개선되기 때문에" |
| 설계 원칙 | "SRP/OCP/DIP를 위반하기 때문에" |
| 메모리/성능 | "메모리 단편화가 발생하기 때문에" |
| 동시성/안전성 | "Race Condition이 발생할 수 있기 때문에" |
| 결합도/응집도 | "높은 결합도로 변경 영향이 전파되기 때문에" |
| 트레이드오프 | "읽기 성능은 좋지만 쓰기 성능이 저하되기 때문에" |

---

### "된다 / 안 된다" 작성 가이드

권장 사항이나 금지 사항을 설명할 때는 반드시 **구체적인 이유**와 **실제 문제 상황**을 함께 제시한다.

#### 작성 형식

```markdown
### {주제}

**권장 (O)**: {권장 패턴}
**비권장 (X)**: {비권장 패턴}

**왜?**
{구체적인 이유 설명 - 기술적 근거 포함}

**만약 지키지 않으면?**
{실제로 발생할 수 있는 문제 상황}

**예외 상황**
{이 규칙을 따르지 않아도 되는 경우가 있다면 명시}
```

---

### "언제 사용하나?" 작성 가이드

기술, 패턴, 알고리즘의 사용 시점을 설명할 때는 **단순 나열이 아닌 이유와 이점까지 포함**한다.

#### 작성 형식

```markdown
### {기술/패턴명}

**언제 사용하나?**
- {상황 1} - 짧은 설명

**왜 이 상황에서 사용하나?**

{상황}에서 {기술/패턴}을 사용하면:
- **이점 1**: {구체적인 이점과 이유}
- **이점 2**: {구체적인 이점과 이유}

**사용하지 않으면?**
{발생할 수 있는 문제}

**실무 예시**
{실제 적용 사례}
```

#### Bad vs Good 예시

| Bad (단순 나열) | Good (이유와 이점 포함) |
|----------------|----------------------|
| 기존 클래스를 수정 없이 다른 인터페이스와 함께 사용할 때 | 기존 클래스를 수정 없이 다른 인터페이스와 함께 사용할 때. **왜?** 기존 코드 수정은 버그 유발 위험이 있고, 외부 라이브러리는 수정 자체가 불가능함. **이점**: OCP 준수, 기존 코드 안정성 유지 |
| 객체 생성 비용이 클 때 | 객체 생성 비용이 클 때. **왜?** DB 조회, 네트워크 요청 등 초기화에 시간이 오래 걸리는 객체를 매번 생성하면 성능 저하. **이점**: 복제는 메모리 복사만으로 빠르게 완료 |

#### 상세 작성 예시

```markdown
### Adapter 패턴

**언제 사용하나?**
- 기존 클래스를 수정 없이 다른 인터페이스와 함께 사용할 때
- 외부 라이브러리를 내부 인터페이스에 맞출 때

**왜 이 상황에서 사용하나?**

"기존 클래스 수정 없이"가 중요한 이유:
- **안정성**: 이미 검증된 코드를 수정하면 새로운 버그 유발 위험
- **불가능**: 외부 라이브러리, 레거시 코드는 수정 자체가 불가능
- **OCP 준수**: 확장에는 열려있고, 수정에는 닫혀있어야 함

**이점**:
- 기존 코드 변경 없이 새로운 인터페이스와 통합
- 클라이언트 코드가 구체적인 구현에 의존하지 않음
- 외부 의존성 교체 시 어댑터만 수정하면 됨

**사용하지 않으면?**
- 인터페이스가 맞지 않아 기존 클래스를 직접 수정 → 버그 위험
- 외부 라이브러리에 직접 의존 → 라이브러리 변경 시 전체 코드 수정

**실무 예시**
- 결제 모듈: 내부 PaymentService 인터페이스 ↔ 외부 PG사 API
- 로깅: 내부 Logger 인터페이스 ↔ Log4j, SLF4J 등 다양한 구현체
```

---

### "주의사항/트레이드오프" 작성 가이드

주의사항, 단점, 트레이드오프를 설명할 때는 **단순 나열이 아닌 왜 문제인지, 어떤 상황에서 문제가 발생하는지** 구체적으로 설명한다.

#### 작성 형식

```markdown
**주의사항**

- **{문제점}**
  - 왜 문제인가: {구체적인 이유}
  - 발생 상황: {언제/어떤 조건에서 발생}
  - 해결 방법: {대안 또는 완화 방법}
```

#### Bad vs Good 예시

| Bad (단순 나열) | Good (근거 포함) |
|----------------|-----------------|
| 전역 상태이므로 테스트하기 어려움 | 전역 상태이므로 테스트하기 어려움. **왜?** 테스트 간 상태가 공유되어 격리 불가. A 테스트에서 설정한 값이 B 테스트에 영향. **해결**: 의존성 주입으로 Mock 교체 가능하게 설계 |
| 멀티스레드 환경에서 동기화 필요 | 멀티스레드 환경에서 동기화 필요. **왜?** 두 스레드가 동시에 `instance == null` 체크 시 인스턴스가 2개 생성될 수 있음. **해결**: DCL(Double-Checked Locking) + volatile 사용 |
| 메모리를 많이 사용함 | 메모리를 많이 사용함. **왜?** 모든 버전을 저장하므로 N개 버전 × 데이터 크기만큼 메모리 필요. 1만 건 데이터의 100개 버전 = 100만 건 저장. **해결**: 주기적 스냅샷 + 델타만 저장 |

#### 상세 작성 예시

```markdown
**주의사항**

- **전역 상태이므로 테스트하기 어려움**
  - 왜 문제인가: Singleton은 애플리케이션 전체에서 하나의 인스턴스를 공유하므로,
    테스트 A에서 변경한 상태가 테스트 B에 영향을 줌 (테스트 격리 실패)
  - 발생 상황: 단위 테스트 병렬 실행 시, 또는 테스트 순서에 따라 결과가 달라지는 경우
  - 해결 방법:
    - 의존성 주입(DI)으로 설계하여 테스트 시 Mock으로 교체
    - 테스트 전/후 상태 초기화 메서드 제공
    - Spring 등 DI 컨테이너 사용 시 @Scope 조절

- **멀티스레드 환경에서 동기화 필요**
  - 왜 문제인가: `if (instance == null)` 체크와 `new Instance()` 사이에
    다른 스레드가 끼어들면 인스턴스가 여러 개 생성됨 (Race Condition)
  - 발생 상황: 애플리케이션 시작 시 여러 스레드가 동시에 getInstance() 호출
  - 해결 방법:
    - DCL(Double-Checked Locking) + volatile 키워드
    - static inner class 방식 (Lazy Holder)
    - enum 방식 (가장 안전)
```

---

### "쉽게 이해하기" 작성 가이드

> 비전공자도 이해할 수 있도록 **실생활 비유**와 **일상 예시**를 활용한다.
> 모든 CS 문서에는 반드시 "쉽게 이해하기" 섹션을 포함해야 한다.

#### 좋은 비유의 조건

| 조건 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 친숙함 | 누구나 아는 일상적인 상황 사용 | 새로운 개념을 익숙한 것에 연결해야 이해가 빠름 |
| 정확성 | 개념의 핵심 특성을 잘 반영 | 잘못된 비유는 오개념을 만듦 |
| 단순함 | 복잡한 비유보다 간단한 비유 선호 | 비유 자체가 복잡하면 본말전도 |
| 확장성 | 비유를 통해 파생 개념도 설명 가능 | 하나의 비유로 여러 개념을 연결 |

#### 작성 형식

```markdown
## 쉽게 이해하기

**{핵심 개념}**을 {비유 대상}에 비유할 수 있습니다.

{비유 설명 - 왜 이 비유가 적절한지 2~3문장}

예를 들어, {구체적인 일상 상황 예시}

{비유의 한계점이 있다면 언급 - "단, 실제로는 ~라는 점이 다릅니다"}
```

#### 작성 예시

```markdown
## 쉽게 이해하기

**트랜잭션**을 은행 송금에 비유할 수 있습니다.

A가 B에게 100만원을 송금할 때, 두 가지 작업이 일어납니다:
1. A 계좌에서 100만원 출금
2. B 계좌에 100만원 입금

이 두 작업은 **반드시 둘 다 성공하거나, 둘 다 취소**되어야 합니다.
만약 1만 성공하고 2가 실패하면? 100만원이 공중에서 사라집니다.

예를 들어, 송금 중 시스템 장애가 발생하면:
- 출금만 되고 입금 안 됨 → 돈 증발 (X)
- 트랜잭션 덕분에 → 출금도 취소되어 원래대로 복구 (O)

이것이 ACID의 원자성(Atomicity)입니다.
"All or Nothing" - 전부 성공하거나, 전부 취소하거나.
```

---

### "면접 질문" 작성 가이드

면접 질문 답변에도 **"왜?"를 포함**하고, **단순 암기가 아닌 이해 기반의 답변**을 작성한다.

#### 작성 형식

```markdown
## 면접 예상 질문

- Q: {질문}
  - A: {답변 - "왜냐하면", "따라서" 등으로 논리적 연결}
```

#### 예시

```markdown
## 면접 예상 질문

- Q: 왜 TCP는 3-way handshake를 사용하나요? 2-way로는 안 되나요?
  - A: 2-way로는 서버가 자신의 응답(SYN-ACK)이 클라이언트에 도착했는지
    확인할 수 없습니다. 만약 SYN-ACK가 유실되면 서버는 연결이 수립되었다고
    생각하지만 클라이언트는 아직 대기 중인 상태가 됩니다.
    3번째 ACK를 통해 양방향 통신이 모두 가능함을 확인할 수 있습니다.
    4-way는 이미 양방향 확인이 완료되어 불필요한 오버헤드입니다.

- Q: 인덱스를 많이 만들면 좋은 거 아닌가요?
  - A: 아닙니다. 인덱스는 조회 성능을 높이지만 쓰기 성능을 저하시킵니다.
    **왜냐하면** INSERT/UPDATE/DELETE 시 인덱스도 함께 갱신해야 하기 때문입니다.
    또한 인덱스는 테이블 크기의 10-20% 추가 공간을 차지합니다.
    **따라서** 자주 조회되는 컬럼, WHERE/JOIN/ORDER BY에 사용되는 컬럼에만
    선별적으로 생성해야 합니다.
```

---

### "심층 분석" 작성 가이드

복잡한 개념에는 다음 구조를 활용한다.

#### 1. 문제 상황 → 해결책 → 이유 구조

```markdown
### 문제 상황
대용량 테이블에서 특정 컬럼 조회 시 풀 테이블 스캔으로 10초 이상 소요

### 해결책
해당 컬럼에 B+Tree 인덱스 생성

### 왜 이 해결책인가?
- B+Tree는 정렬된 구조로 O(log N) 탐색 가능
- 리프 노드가 연결 리스트로 연결되어 범위 검색에 효율적
- 디스크 I/O 최소화 (높이가 보통 3-4로 제한됨)

### 왜 다른 방법이 아닌가?
- Hash 인덱스: 범위 검색 불가 (동등 비교만 가능)
- Full-text 인덱스: 텍스트 검색 전용, 일반 조회에 부적합
- 파티셔닝: 관리 복잡도 증가, 단순 조회에는 과도함
```

#### 2. 트레이드오프 명시

```markdown
### 인덱스 사용의 트레이드오프

| 장점 | 단점 |
|------|------|
| 조회 성능 향상 (O(N) → O(log N)) | INSERT/UPDATE/DELETE 성능 저하 |
| 정렬 비용 절감 | 추가 저장 공간 필요 (테이블의 10-20%) |
| 커버링 인덱스로 테이블 접근 제거 | 인덱스 유지보수 오버헤드 |

**결론**: 조회가 많고 쓰기가 적은 테이블에 적합.
OLTP 시스템에서는 신중하게 적용, OLAP 시스템에서는 적극 활용.
```

#### 3. 단계별 인과 관계

```markdown
### TCP 3-way Handshake가 필요한 이유

**문제**: 신뢰할 수 없는 네트워크에서 양방향 통신 수립

**왜 3단계인가?**

1. **SYN (Client → Server)**
   - 클라이언트가 통신 의사 표시
   - 초기 순서 번호(ISN) 전달
   - 왜? → 서버가 클라이언트의 존재를 확인해야 함

2. **SYN-ACK (Server → Client)**
   - 서버가 요청 수락 + 자신의 ISN 전달
   - 왜? → 클라이언트가 서버의 수신 능력을 확인해야 함
   - 왜 SYN만으로 부족? → 서버→클라이언트 방향 확인 안 됨

3. **ACK (Client → Server)**
   - 클라이언트가 서버의 SYN-ACK 수신 확인
   - 왜? → 서버가 자신의 응답이 도착했음을 알아야 함
   - 왜 2단계로 부족? → 서버는 자신의 응답 도착 여부를 모름

**왜 4단계가 아닌가?**
- 3단계로 양방향 통신 확인 완료
- 추가 단계는 불필요한 오버헤드
```

---

### "트러블슈팅" 작성 가이드

> **실무에서 겪은 문제와 해결 경험을 체계적으로 정리**하여, 같은 문제를 겪을 독자에게 실질적인 도움을 제공한다.

#### 트러블슈팅의 가치

| 관점 | 가치 |
|------|------|
| **실무 적용** | 이론만으로는 알 수 없는 실제 문제 상황과 해결법 제공 |
| **면접 대비** | "실제로 겪은 문제와 해결 경험" 질문에 구체적 사례로 답변 가능 |
| **깊은 이해** | 문제를 해결하는 과정에서 개념을 더 깊이 이해하게 됨 |

#### 작성 형식

```markdown
## 트러블슈팅

### 사례 N: {증상/문제 한 줄 요약}

#### 증상

{에러 메시지, 로그, 현상 등 구체적으로 기술}

```
에러 메시지나 로그가 있다면 코드 블록으로 포함
```

#### 원인 분석

**{관련 지표/상태 확인}** (있다면):

```bash
명령어 또는 확인 방법
```

```
실제 출력값이나 상태
```

**왜 발생하는가?**

1. **{원인 1}**: 설명
2. **{원인 2}**: 설명
3. **결과**: 왜 이것이 문제를 일으키는지

#### 해결 방법

**방법 1: {해결책 이름} (권장/즉시 적용 등)**

```bash
구체적인 명령어나 코드
```

| 옵션/설정 | 값 | 설명 |
|----------|---|------|
| {옵션명} | {값} | {왜 이 값인지} |

**왜 이 방법인가?**
- {이유 1}
- {이유 2}

**방법 2: {다른 해결책}**
{대안 설명}

#### 예방 조치

**1. {예방 조치 1}**
```bash
모니터링/설정 명령어
```

**2. {예방 조치 2}**
{설명}
```

#### 좋은 트러블슈팅 문서의 조건

| 조건 | 설명 | 왜 중요한가? |
|------|------|-------------|
| **재현 가능** | 같은 환경에서 같은 문제를 재현할 수 있어야 함 | 문제 확인과 해결 검증이 가능 |
| **구체적 수치** | 에러 메시지, 로그, 메트릭 등 구체적 데이터 포함 | 추상적 설명보다 신뢰성 높음 |
| **원인 분석** | 단순히 "이렇게 하면 됨"이 아닌 "왜 발생했는지" 분석 | 유사 문제 해결 능력 향상 |
| **다중 해결책** | 가능하다면 여러 해결 방법 제시 | 상황에 맞는 선택 가능 |
| **예방 조치** | 재발 방지를 위한 모니터링, 설정 가이드 | 사후 대응보다 사전 예방 |

#### 트러블슈팅 작성 예시

```markdown
## 트러블슈팅

### 사례 1: Redis 메모리 부족으로 인한 BGSAVE 실패

#### 증상

Redis 서버에서 RDB 스냅샷 저장 시 에러 발생:

```
Can't save in background: fork: Cannot allocate memory
```

#### 원인 분석

**Redis 메모리 상태 확인**:

```bash
redis-cli INFO memory
```

```
used_memory_human:343.42M
total_system_memory_human:1.91G
maxmemory:0
```

**왜 발생하는가?**

1. **fork() 동작**: Redis는 BGSAVE 시 fork()로 자식 프로세스 생성
2. **Copy-on-Write**: fork 직후에는 메모리 공유, 쓰기 시 페이지 복사
3. **Linux 정책**: overcommit_memory=0은 최악의 경우(2배)를 대비
4. **결과**: 실제 필요량보다 많은 메모리를 요구하여 실패

#### 해결 방법

**방법 1: overcommit_memory 변경 (권장)**

```bash
sudo sysctl vm.overcommit_memory=1
```

| 값 | 동작 | 설명 |
|---|------|------|
| 0 | 휴리스틱 | 기본값. 보수적 |
| 1 | 항상 허용 | Redis 권장 |

**왜 이 방법인가?**
- Redis fork는 COW 사용으로 실제 추가 메모리 적음
- Redis 공식 문서 권장 설정

**방법 2: maxmemory 설정**

```bash
redis-cli CONFIG SET maxmemory 512mb
redis-cli CONFIG SET maxmemory-policy allkeys-lru
```

#### 예방 조치

**1. 메모리 모니터링**
```bash
redis-cli INFO memory | grep used_memory_human
```

**2. 알림 설정**
사용량 80% 초과 시 알림 발송
```

#### 트러블슈팅 주제 예시

| 카테고리 | 트러블슈팅 주제 예시 |
|----------|---------------------|
| **DB** | 슬로우 쿼리, 락 타임아웃, 커넥션 풀 고갈, 레플리카 지연 |
| **Redis** | 메모리 부족, 키 폭발, 직렬화 이슈, 클러스터 failover |
| **Network** | 커넥션 타임아웃, DNS 해석 실패, TLS 핸드셰이크 실패 |
| **JVM** | OOM, GC 튜닝, 스레드 데드락, 메모리 누수 |
| **Kafka** | Consumer Lag, 파티션 불균형, 브로커 장애 |
| **K8s** | Pod OOMKilled, ImagePullBackOff, 서비스 디스커버리 |

---

## 문서 품질 체크리스트

문서 작성 후 아래 체크리스트로 품질을 검증한다:

### 필수 항목

- [ ] **정의**: 한 문장으로 명확한 정의가 있는가?
- [ ] **왜 알아야 하는가**: 실무/면접/기반지식 관점에서 필요성이 설명되어 있는가?
- [ ] **쉽게 이해하기**: 비전공자도 이해할 수 있는 비유/예시가 있는가?
- [ ] **왜?**: 모든 설명에 "왜?"에 대한 답이 있는가?
- [ ] **면접 질문**: 실제 면접에서 나올 수 있는 질문과 답변이 있는가?
- [ ] **난이도 표기**: 문서 상단에 난이도와 선수 지식이 명시되어 있는가?

### 권장 항목

- [ ] **학습 목표**: 읽은 후 할 수 있는 것이 명시되어 있는가?
- [ ] **예제 코드**: 개념을 이해하는 데 도움이 되는 코드가 있는가?
- [ ] **트레이드오프**: 장단점이 명확히 설명되어 있는가?
- [ ] **트러블슈팅**: 실무에서 겪을 수 있는 문제와 해결법이 있는가? (해당되는 경우)
- [ ] **연관 문서**: 선수 지식, 관련 개념, 후속 학습 링크가 있는가?
- [ ] **참고 자료**: 공식 문서 또는 신뢰할 수 있는 출처가 있는가?

### 안티패턴 체크

- [ ] 정의 없이 바로 상세 설명으로 들어가지 않았는가?
- [ ] "왜?"에 대한 답 없이 "이렇게 해라"만 있지 않은가?
- [ ] 용어 설명 없이 전문 용어를 사용하지 않았는가?
- [ ] 너무 많은 내용을 한 문서에 담지 않았는가?

---

## 작업 흐름

### 문서 작성 시

1. `cs/{category}/{topic}.md` 파일 생성
2. 템플릿에 맞게 내용 작성 (정의 우선 + 왜? 포함)
3. `cs/{category}/README.md`의 해당 난이도 섹션에 링크 추가
4. `git add` 실행

### README.md 업데이트

새 문서 작성 시 해당 카테고리의 README.md에 링크 추가:

```markdown
## 목차

- [{주제명}](./{파일명}.md) - 한 줄 설명
```

### 사용 예시

사용자 요청:
> "오늘의 CS: TCP 3-way handshake"

Claude 작업:
1. `cs/network/tcp-handshake.md` 파일 생성
2. 템플릿에 맞게 내용 작성 (왜? 포함)
3. `cs/network/README.md`에 링크 추가
4. `git add` 실행

---

## 부록

### A. 카테고리별 주제 레퍼런스

각 카테고리에서 다룰 수 있는 주제 목록입니다.

#### Network (네트워크)

> 컴퓨터 간 데이터 통신의 원리와 프로토콜

| 분류 | 주제 | 설명 |
|------|------|------|
| 기초 | OSI 7계층 | 물리~응용 계층의 역할과 책임 |
| 기초 | TCP/IP 4계층 | 실제 인터넷에서 사용하는 계층 구조 |
| 전송 | TCP | 3/4-way handshake, 흐름/혼잡 제어, 재전송 |
| 전송 | UDP | 비연결형, 데이터그램, 체크섬 |
| 응용 | HTTP/HTTPS | HTTP/1.1, HTTP/2, HTTP/3, TLS |
| 응용 | DNS | 도메인 해석, 레코드 종류, 캐싱 |
| 응용 | WebSocket | 양방향 실시간 통신 |
| 응용 | REST API | RESTful 설계, 멱등성, 상태 코드 |
| 응용 | gRPC | Protocol Buffers, HTTP/2 기반 |
| 인프라 | 로드밸런싱 | L4/L7, 알고리즘, 헬스체크 |
| 인프라 | CDN | 콘텐츠 캐싱, 엣지 서버 |
| 인프라 | 프록시 | Forward/Reverse Proxy |

#### OS (운영체제)

> 하드웨어 자원을 관리하고 프로그램 실행 환경을 제공

| 분류 | 주제 | 설명 |
|------|------|------|
| 프로세스 | 프로세스 vs 스레드 | PCB, TCB, 컨텍스트 스위칭, 자원 공유 |
| 프로세스 | 프로세스 상태 | New, Ready, Running, Waiting, Terminated |
| 프로세스 | IPC | 파이프, 메시지 큐, 공유 메모리, 소켓 |
| 스케줄링 | 스케줄링 알고리즘 | FCFS, SJF, RR, Priority, MLFQ |
| 동기화 | 경쟁 조건 | Race Condition, 임계 영역 |
| 동기화 | 동기화 기법 | 뮤텍스, 세마포어, 모니터 |
| 동기화 | 데드락 | 발생 조건, 예방, 회피, 탐지 |
| 메모리 | 가상 메모리 | 주소 변환, 페이지 테이블, TLB |
| 메모리 | 페이징 | 페이지, 프레임, 페이지 폴트 |
| 메모리 | 페이지 교체 | FIFO, LRU, LFU, Clock |
| I/O | 동기/비동기 | Sync vs Async |
| I/O | 블로킹/논블로킹 | Blocking vs Non-blocking |
| I/O | I/O 멀티플렉싱 | select, poll, epoll, kqueue |

#### DB (데이터베이스)

> 데이터의 저장, 관리, 조회를 위한 시스템

| 분류 | 주제 | 설명 |
|------|------|------|
| 인덱스 | B-Tree / B+Tree | 구조, 탐색, 삽입, 삭제 |
| 인덱스 | 클러스터드/논클러스터드 | 물리적 정렬, 별도 인덱스 |
| 인덱스 | 커버링 인덱스 | 인덱스만으로 쿼리 처리 |
| 트랜잭션 | ACID | 원자성, 일관성, 격리성, 지속성 |
| 트랜잭션 | 격리 수준 | Read Uncommitted ~ Serializable |
| 트랜잭션 | 락 | 공유락, 배타락, 데드락 |
| 트랜잭션 | MVCC | 다중 버전 동시성 제어 |
| SQL | 실행 계획 | EXPLAIN, 쿼리 분석 |
| SQL | JOIN | Nested Loop, Hash, Sort Merge |
| 설계 | 정규화 | 1NF ~ 5NF, 이상 현상 제거 |
| 설계 | 반정규화 | 조회 성능을 위한 의도적 중복 |
| 분산 | 레플리케이션 | Master-Slave, Master-Master |
| 분산 | 샤딩 | 수평 분할, 샤드 키 선택 |
| NoSQL | NoSQL 유형 | Document, Key-Value, Column, Graph |
| NoSQL | CAP 정리 | 일관성, 가용성, 분할 내성 |

#### Data Structure (자료구조)

> 데이터를 효율적으로 저장하고 접근하기 위한 구조

| 분류 | 주제 | 설명 |
|------|------|------|
| 선형 | 배열 | 연속 메모리, O(1) 접근 |
| 선형 | 연결 리스트 | 단일/이중/원형, 동적 크기 |
| 선형 | 스택/큐/덱 | LIFO, FIFO, 양방향 |
| 비선형 | 이진 트리 | 전위/중위/후위/레벨 순회 |
| 비선형 | BST | 삽입/삭제/탐색 |
| 비선형 | 균형 트리 | AVL, Red-Black Tree |
| 비선형 | 힙 | 최대힙/최소힙, heapify |
| 비선형 | 트라이 | 문자열 저장, 접두사 검색 |
| 해시 | 해시 테이블 | 해시 함수, O(1) 평균 접근 |
| 해시 | 충돌 해결 | 체이닝, 개방 주소법 |
| 그래프 | 그래프 표현 | 인접 행렬, 인접 리스트 |

#### Algorithm (알고리즘)

> 문제를 해결하기 위한 절차와 방법

| 분류 | 주제 | 설명 |
|------|------|------|
| 복잡도 | 시간/공간 복잡도 | Big-O, Big-Ω, Big-Θ |
| 정렬 | 비교 정렬 | 퀵, 병합, 힙 정렬 |
| 정렬 | 비비교 정렬 | 계수, 기수, 버킷 정렬 |
| 탐색 | 이진 탐색 | 정렬된 배열 O(log N) 탐색 |
| 탐색 | DFS/BFS | 깊이/너비 우선 탐색 |
| 그래프 | 최단 경로 | 다익스트라, 벨만포드, 플로이드워셜 |
| 그래프 | MST | 크루스칼, 프림 |
| 그래프 | 위상 정렬 | DAG에서 순서 결정 |
| 설계 | 분할 정복 | 문제를 나누어 해결 후 병합 |
| 설계 | 동적 프로그래밍 | 메모이제이션, 타뷸레이션 |
| 설계 | 그리디 | 매 순간 최적 선택 |
| 설계 | 백트래킹 | 가지치기를 통한 탐색 |

#### System Design (시스템 설계)

> 대규모 시스템의 아키텍처 설계 원칙과 패턴

| 분류 | 주제 | 설명 |
|------|------|------|
| 확장성 | 수직/수평 확장 | Scale-Up vs Scale-Out |
| 확장성 | 캐싱 전략 | Cache-Aside, Write-Through/Back/Around |
| 가용성 | 고가용성 (HA) | 이중화, 페일오버, 헬스체크 |
| 가용성 | 서킷 브레이커 | 장애 전파 차단, 폴백 |
| 가용성 | Rate Limiting | 토큰 버킷, 슬라이딩 윈도우 |
| 분산 | CAP 정리 | 일관성, 가용성, 분할 내성 |
| 분산 | 분산 트랜잭션 | 2PC, Saga 패턴 |
| 분산 | 분산 락 | Redis, ZooKeeper |
| 아키텍처 | MSA vs 모놀리식 | 장단점, 전환 전략 |
| 아키텍처 | 이벤트 드리븐 | 이벤트 소싱, CQRS |
| 메시징 | 메시지 큐 | Kafka, RabbitMQ, SQS |
| 컨테이너 | Docker/Kubernetes | 컨테이너 오케스트레이션 |

#### Programming (프로그래밍)

> 프로그래밍 패러다임과 소프트웨어 설계 원칙

| 분류 | 주제 | 설명 |
|------|------|------|
| 패러다임 | OOP | 캡슐화, 상속, 다형성, 추상화 |
| 패러다임 | 함수형 프로그래밍 | 순수 함수, 불변성, 고차 함수 |
| 설계 | SOLID | SRP, OCP, LSP, ISP, DIP |
| 설계 | DRY / KISS / YAGNI | 중복 제거, 단순화, 불필요한 것 배제 |
| 디자인 패턴 | 생성 패턴 | Singleton, Factory, Builder, Prototype |
| 디자인 패턴 | 구조 패턴 | Adapter, Decorator, Proxy, Facade |
| 디자인 패턴 | 행위 패턴 | Strategy, Observer, Template Method, State |
| 클린 코드 | 네이밍 | 의도를 드러내는 이름 |
| 클린 코드 | 함수 설계 | 한 가지 일만, 작게, 추상화 수준 일치 |
| 클린 코드 | 리팩토링 | 코드 스멜, 리팩토링 기법 |

#### Security (보안)

> 시스템과 데이터를 보호하기 위한 기술과 원칙

| 분류 | 주제 | 설명 |
|------|------|------|
| 인증 | 인증 vs 인가 | Authentication vs Authorization |
| 인증 | 세션/토큰 기반 | 서버 세션, JWT |
| 인증 | OAuth 2.0 | 인가 프레임워크, 플로우 |
| 웹 보안 | OWASP Top 10 | 주요 웹 취약점 |
| 웹 보안 | XSS / CSRF | 스크립트 삽입, 요청 위조 |
| 웹 보안 | SQL Injection | SQL 삽입, 방어 |
| 암호화 | 대칭키/비대칭키 | AES, RSA |
| 암호화 | 해시 | SHA, bcrypt, salt |
| 암호화 | TLS/SSL | 핸드셰이크, 인증서 |

#### Git (버전 관리)

> 소스 코드 버전 관리와 협업

| 분류 | 주제 | 설명 |
|------|------|------|
| 기초 | Git 기본 개념 | Repository, Commit, Branch |
| 기초 | Git 내부 구조 | Object, Tree, Blob, Ref |
| 브랜치 | Git Flow | feature, develop, release, hotfix |
| 브랜치 | GitHub Flow | main + feature 브랜치 |
| 고급 | Rebase vs Merge | 히스토리 정리 vs 보존 |
| 고급 | Git Hooks | 커밋/푸시 시 자동화 |

#### Language (언어별 심화)

> 특정 언어의 깊은 이해와 최적화

| 분류 | 주제 | 설명 |
|------|------|------|
| Java | JVM 구조 | 클래스로더, 런타임 영역, 실행 엔진 |
| Java | GC | Serial, Parallel, G1, ZGC |
| Java | 동시성 | synchronized, volatile, Atomic, Lock |
| Java | 컬렉션 프레임워크 | List, Set, Map 구현체별 특성 |
| Kotlin | Null Safety | ?, !!, let, elvis |
| Kotlin | Coroutine | suspend, launch, async, Flow |

#### AI Agent (AI 에이전트)

> AI 에이전트의 기능 확장과 외부 시스템 연결

| 분류 | 주제 | 설명 |
|------|------|------|
| 기초 | AI Agent란 | AI 에이전트의 정의, 구성 요소, 동작 원리 |
| 기초 | LLM 기초 | 대규모 언어 모델의 기본 개념 |
| 프로토콜 | MCP | Model Context Protocol, 외부 시스템 연결 표준 |
| 확장 | Skill | 기능 모듈화, 능력 패키징 시스템 |
| 확장 | Hook | 생명주기 자동 실행 셸 명령어 |
| 확장 | Slash Command | 자주 사용하는 프롬프트 명령어화 |
| 심화 | Sub Agent | 독립적 작업 위임, 병렬 실행 |
| 심화 | Agent SDK | 커스텀 에이전트 빌드 |

#### Automation (업무 자동화)

> 반복 작업 자동화와 워크플로우 효율화

| 분류 | 주제 | 설명 |
|------|------|------|
| 기초 | 자동화란 | RPA vs 스크립트 자동화, 적용 사례 |
| 플랫폼 | Google Apps Script | Google Workspace 자동화, JavaScript 기반 |
| 플랫폼 | n8n | 오픈소스 워크플로우 자동화, 노코드 |
| 스크립트 | 쉘 스크립트 | Bash/PowerShell 자동화 |
| CI/CD | GitHub Actions | 배포 자동화, 워크플로우 파이프라인 |
| CI/CD | Jenkins | 빌드/배포 파이프라인 |

---

### B. "쉽게 이해하기" 비유 모음

문서 작성 시 참고할 수 있는 비유 모음입니다.

#### Network (네트워크)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| TCP | 등기우편 | 받는 사람이 수령 확인 서명을 해야 배송 완료. 분실 시 재발송 |
| UDP | 전단지 배포 | 일단 뿌리고 받았는지 확인 안 함. 빠르지만 도착 보장 없음 |
| 3-way handshake | 전화 통화 시작 | "여보세요?"(SYN) → "네, 들려요"(SYN-ACK) → "좋아요, 얘기해요"(ACK) |
| HTTP | 식당 주문 | 손님(클라이언트)이 메뉴판 보고 주문(요청)하면 주방(서버)에서 음식(응답) 제공 |
| DNS | 전화번호부 | "홍길동"(도메인)을 검색하면 "010-1234-5678"(IP) 알려줌 |
| 로드밸런싱 | 은행 번호표 시스템 | 창구(서버)가 여러 개일 때 대기 고객을 빈 창구로 안내 |
| CDN | 편의점 체인 | 본사 창고(원본 서버)에서 가져오면 느리니까, 동네 편의점(엣지 서버)에 미리 재고를 배치 |
| WebSocket | 전화 통화 | HTTP가 편지(요청-응답)라면, WebSocket은 전화(실시간 양방향) |

#### OS (운영체제)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 프로세스 | 독립된 사무실 | 각 사무실(프로세스)은 자체 공간, 가구, 문서(메모리)를 가짐 |
| 스레드 | 사무실 안의 직원들 | 같은 사무실(프로세스) 안에서 책상, 프린터(메모리)를 공유하며 일함 |
| 컨텍스트 스위칭 | 멀티태스킹 직장인 | A업무 하다가 B업무로 전환할 때, A 상태를 메모해두고 B로 전환 |
| 데드락 | 좁은 복도의 교착 상태 | 두 사람이 마주보고 "먼저 비켜주세요"라며 기다림 |
| 뮤텍스 | 화장실 잠금장치 | 한 명만 사용 가능. 잠그고 들어가면 다른 사람은 밖에서 대기 |
| 세마포어 | 주차장 만차 표시 | 주차 가능 대수(카운터)를 관리. 0이면 대기 |
| 가상 메모리 | 도서관 열람실 책상 | 책상(RAM)은 작지만, 필요한 책만 꺼내 놓고 나머지는 서가(디스크)에 둠 |
| 페이지 폴트 | 책상에 없는 서류 | "이 서류 어딨지?" → 서랍(디스크)에서 찾아서 책상(메모리)에 올림 |
| 캐시 | 책상 위 자주 쓰는 물건 | 펜, 포스트잇은 서랍 안이 아닌 책상 위에 둬야 바로 사용 가능 |

#### DB (데이터베이스)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 인덱스 | 책의 색인(찾아보기) | 책 전체를 읽지 않고 "ㄱ: 가나다 - 15페이지"처럼 바로 찾아감 |
| 클러스터드 인덱스 | 사전 | 단어(데이터) 자체가 알파벳순으로 정렬되어 있음 |
| 논클러스터드 인덱스 | 책 뒤의 색인 | 색인 페이지에서 단어 찾고, 해당 페이지로 이동 (두 번 찾기) |
| 트랜잭션 | 은행 송금 | A계좌 출금 + B계좌 입금이 둘 다 성공하거나, 둘 다 취소 |
| ACID | 송금의 4가지 보장 | 원자성, 일관성, 격리성, 지속성 |
| 락(Lock) | 화장실 사용 중 표시 | 누가 쓰고 있으면 다른 사람은 대기 |
| 정규화 | 중복 서류 정리 | 같은 정보를 여러 곳에 적지 않고, 한 곳에만 적고 참조 |

#### Algorithm & Data Structure

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 배열 | 사물함 | 1번, 2번, 3번... 번호로 바로 접근. 중간에 끼워넣기 어려움 |
| 연결 리스트 | 보물찾기 쪽지 | 각 쪽지에 "다음 쪽지는 OO에 있음" 정보 포함 |
| 스택 | 접시 쌓기 | 마지막에 올린 접시를 먼저 꺼냄 (LIFO) |
| 큐 | 줄서기 | 먼저 온 사람이 먼저 나감 (FIFO) |
| 해시 테이블 | 회사 사물함 | 이름을 해시 함수에 넣으면 사물함 번호가 나옴 |
| 이진 탐색 | 사전에서 단어 찾기 | 중간 펼쳐서 앞/뒤 판단 반복. 절반씩 범위 축소 |
| DFS | 미로 탐색 (한 길 끝까지) | 갈림길에서 한 방향으로 끝까지 가보고, 막히면 되돌아와 |
| BFS | 물결 퍼지듯 탐색 | 현재 위치에서 한 칸씩 모든 방향으로 동시에 퍼져나감 |
| O(1) | 사물함 열기 | 번호만 알면 바로 열기. 사물함 개수와 무관 |
| O(N) | 출석 부르기 | 학생 수만큼 시간 걸림 |
| O(log N) | 사전 검색 | 절반씩 줄이니까 1000페이지도 10번이면 찾음 |

#### System Design (시스템 설계)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 수직 확장 | 더 큰 트럭 구매 | 1톤 트럭 → 5톤 트럭. 한계가 있고 비쌈 |
| 수평 확장 | 트럭 대수 늘리기 | 1톤 트럭 5대. 필요하면 계속 추가 가능 |
| 캐시 | 냉장고 | 마트(DB)까지 안 가고 냉장고(캐시)에서 바로 꺼내 먹기 |
| 캐시 미스 | 냉장고에 없음 | 냉장고에 없으면 마트 가야 함 (느림) |
| 메시지 큐 | 식당 주문 대기표 | 주문(메시지)을 대기표(큐)에 넣으면, 주방(워커)이 순서대로 처리 |
| 서킷 브레이커 | 두꺼비집 차단기 | 과부하 시 자동 차단해서 화재(장애 전파) 방지 |
| 레플리케이션 | 교과서 복사본 | 원본 1개 + 복사본 여러 개. 원본 분실해도 복사본 있음 |
| 샤딩 | 반 나누기 | 학생 1000명을 A~J반(10개 샤드)으로 나눠서 관리 |
| MSA | 전문 음식점 거리 | 한식, 중식, 일식 각각 전문점. 독립 운영, 필요한 곳만 확장 |
| 모놀리식 | 뷔페 식당 | 모든 음식을 한 주방에서. 관리 편하지만 특정 메뉴만 늘리기 어려움 |
| CAP 정리 | 빠름/정확/안정 중 2개만 | "빠르고 정확하고 저렴하게" 중 2개만 가능한 것처럼 |

#### Programming (프로그래밍)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| OOP | 레고 블록 | 미리 만든 블록(객체)을 조립해서 큰 작품(프로그램) 완성 |
| 캡슐화 | 자동차 운전 | 엔진 구조 몰라도 핸들, 페달만 알면 운전 가능 |
| 상속 | 가업 물려받기 | 부모의 재산(속성), 사업 노하우(메서드)를 자식이 물려받음 |
| 다형성 | 리모컨의 전원 버튼 | TV, 에어컨, 선풍기 다 다르지만 "전원" 버튼은 동일하게 동작 |
| 인터페이스 | USB 포트 | USB 규격만 맞으면 마우스, 키보드, 외장하드 다 연결됨 |
| 의존성 주입 | 배터리 교체형 장난감 | 배터리(의존성)를 외부에서 끼워줌. 충전식, 건전지 자유롭게 교체 |

#### Security (보안)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 인증 | 신분증 확인 | "당신이 홍길동이 맞나요?" 확인 |
| 인가 | 출입 권한 확인 | "홍길동은 이 방에 들어갈 수 있나요?" 확인 |
| 세션 | 놀이공원 팔찌 | 입장 시 팔찌 받고, 팔찌 보여주면 재입장 가능 |
| JWT | 신분증 + 자격증 | 신분 정보와 권한이 적힌 카드. 서버가 매번 DB 안 봐도 됨 |
| 암호화 | 자물쇠 금고 | 열쇠(키) 있는 사람만 내용물 확인 가능 |
| 해시 | 지문 | 원본에서 지문(해시)은 추출 가능하지만, 지문으로 원본 복원 불가 |
| XSS | 식당 설문지에 폭탄 | 설문지(입력창)에 악성 스크립트를 넣어 다른 손님 공격 |
| SQL Injection | 주문서 조작 | "아메리카노 1잔" 대신 "아메리카노 1잔; 금고 열어" 주문 |

#### AI Agent (AI 에이전트)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| MCP | USB 허브 | 다양한 장치(도구)를 하나의 규격으로 연결. 프린터, 마우스 등 다 USB로 |
| Skill | 앱 스토어 앱 | 필요한 기능(앱)을 설치해서 능력 확장. 카메라, 지도 등 |
| Hook | 자동문 센서 | 사람이 다가오면(이벤트) 자동으로 문이 열림(액션 실행) |
| Sub Agent | 팀 프로젝트 분업 | 리더가 각 팀원에게 파트를 맡기고, 결과를 취합 |
| Tool Use | 도구 상자 | 망치, 드라이버 등 필요한 도구를 꺼내서 작업 수행 |
| Context Window | 책상 위 공간 | 동시에 펼쳐놓을 수 있는 서류 양. 공간이 좁으면 자주 치워야 함 |
