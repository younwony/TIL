# CS 학습 문서 작성 가이드

이 문서는 CS 지식 문서 작성 시 Claude가 참고하는 가이드입니다.

---

## 카테고리 구조

```
cs/
├── network/           # 네트워크
├── os/                # 운영체제
├── db/                # 데이터베이스
├── data-structure/    # 자료구조
├── algorithm/         # 알고리즘
├── system-design/     # 시스템 설계
├── programming/       # 프로그래밍 패러다임 & 원칙
├── security/          # 보안
├── git/               # 버전 관리
└── language/          # 언어별 심화 (Java, Kotlin 등)
```

---

## 카테고리별 주제

### Network (네트워크)

> 컴퓨터 간 데이터 통신의 원리와 프로토콜

#### 기초 이론

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| OSI 7계층 | 물리~응용 계층의 역할과 책임 | 네트워크 문제 발생 시 어느 계층 문제인지 파악 가능 |
| TCP/IP 4계층 | 실제 인터넷에서 사용하는 계층 구조 | 실무에서 사용하는 실제 프로토콜 스택 이해 |

#### 전송 계층

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| TCP | 3/4-way handshake, 흐름/혼잡 제어, 재전송 | 신뢰성 있는 통신이 어떻게 보장되는지 이해 |
| UDP | 비연결형, 데이터그램, 체크섬 | 실시간 스트리밍, 게임 등 저지연 통신에 필수 |
| TCP vs UDP | 사용 사례별 선택 기준 | 서비스 특성에 맞는 프로토콜 선택 능력 |

#### 응용 계층

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| HTTP/HTTPS | HTTP/1.1, HTTP/2, HTTP/3, TLS | 웹 통신의 기본, 보안 연결 원리 |
| DNS | 도메인 해석, 레코드 종류, 캐싱 | 모든 웹 요청의 시작점 |
| WebSocket | 양방향 실시간 통신, HTTP와 차이 | 채팅, 실시간 알림 구현에 필수 |
| REST API | RESTful 설계, 멱등성, 상태 코드 | API 설계의 표준 |
| gRPC | Protocol Buffers, HTTP/2 기반 | MSA 간 고성능 통신 |

#### 인프라

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 로드밸런싱 | L4/L7, 알고리즘, 헬스체크 | 고가용성 서비스 구축의 핵심 |
| CDN | 콘텐츠 캐싱, 엣지 서버 | 전세계 사용자에게 빠른 응답 제공 |
| 프록시 | Forward/Reverse Proxy, 용도 | 보안, 캐싱, 로드밸런싱 구현 |

---

### OS (운영체제)

> 하드웨어 자원을 관리하고 프로그램 실행 환경을 제공

#### 프로세스 관리

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 프로세스 vs 스레드 | PCB, TCB, 컨텍스트 스위칭, 자원 공유 | 멀티태스킹과 동시성 프로그래밍의 기초 |
| 프로세스 상태 | New, Ready, Running, Waiting, Terminated | 프로세스 라이프사이클 이해 |
| IPC | 파이프, 메시지 큐, 공유 메모리, 소켓 | 프로세스 간 데이터 교환 방법 |

#### CPU 스케줄링

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 스케줄링 알고리즘 | FCFS, SJF, RR, Priority, MLFQ | CPU 자원 할당 최적화 이해 |
| 선점 vs 비선점 | 인터럽트 기반 스케줄링 | 실시간 시스템 vs 일반 시스템 차이 |

#### 동기화

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 경쟁 조건 | Race Condition, 임계 영역 | 동시성 버그의 원인 파악 |
| 동기화 기법 | 뮤텍스, 세마포어, 모니터 | 공유 자원 접근 제어 방법 |
| 데드락 | 발생 조건, 예방, 회피, 탐지 | 시스템 멈춤 현상 방지 |

#### 메모리 관리

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 가상 메모리 | 주소 변환, 페이지 테이블, TLB | 물리 메모리보다 큰 프로그램 실행 가능 |
| 페이징 | 페이지, 프레임, 페이지 폴트 | 메모리 단편화 해결, 효율적 메모리 사용 |
| 페이지 교체 | FIFO, LRU, LFU, Clock | 제한된 메모리에서 최적 성능 유지 |
| 세그멘테이션 | 논리적 단위 분할, 외부 단편화 | 코드/데이터/스택 분리 관리 |

#### 파일 시스템

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 파일 시스템 구조 | inode, 디렉토리, 파일 할당 | 데이터 영속성의 기반 |
| 저널링 | Write-Ahead Logging, 복구 | 시스템 크래시 시 데이터 보호 |

#### I/O

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 동기/비동기 | Sync vs Async, 차이점 | I/O 모델 선택의 기준 |
| 블로킹/논블로킹 | Blocking vs Non-blocking | 고성능 서버 구현에 필수 |
| I/O 멀티플렉싱 | select, poll, epoll, kqueue | 대용량 연결 처리 |

---

### DB (데이터베이스)

> 데이터의 저장, 관리, 조회를 위한 시스템

#### 인덱스

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| B-Tree / B+Tree | 구조, 탐색, 삽입, 삭제 | 대부분의 RDBMS 인덱스 구조 |
| 클러스터드 인덱스 | 데이터 물리적 정렬, PK | 범위 검색 최적화 |
| 논클러스터드 인덱스 | 별도 인덱스 구조, 포인터 | 다양한 검색 조건 지원 |
| 커버링 인덱스 | 인덱스만으로 쿼리 처리 | 테이블 접근 제거로 성능 향상 |
| 인덱스 설계 | 카디널리티, 선택도, 복합 인덱스 순서 | 효과적인 인덱스 전략 수립 |

#### 트랜잭션

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| ACID | 원자성, 일관성, 격리성, 지속성 | 데이터 무결성 보장의 기본 원칙 |
| 격리 수준 | Read Uncommitted ~ Serializable | 동시성 vs 정합성 트레이드오프 |
| 락 | 공유락, 배타락, 데드락 | 동시 접근 제어 |
| MVCC | 다중 버전 동시성 제어, 스냅샷 | 락 없이 읽기 성능 향상 |

#### SQL 최적화

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 실행 계획 | EXPLAIN, 쿼리 분석 | 느린 쿼리 원인 파악 |
| JOIN | Nested Loop, Hash, Sort Merge | 조인 전략별 성능 특성 |
| 쿼리 튜닝 | 인덱스 활용, 서브쿼리 최적화 | 실무 성능 개선 |

#### 정규화 & 설계

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 정규화 | 1NF ~ 5NF, 이상 현상 제거 | 데이터 중복 제거, 무결성 보장 |
| 반정규화 | 조회 성능을 위한 의도적 중복 | 읽기 성능 최적화 |
| ERD 설계 | 엔티티, 관계, 카디널리티 | 요구사항을 DB 구조로 변환 |

#### 분산 DB

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 레플리케이션 | Master-Slave, Master-Master | 읽기 분산, 고가용성 |
| 샤딩 | 수평 분할, 샤드 키 선택 | 대용량 데이터 처리 |
| 커넥션 풀 | HikariCP, 풀 사이징 | DB 연결 오버헤드 감소 |

#### NoSQL

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| NoSQL 유형 | Document, Key-Value, Column, Graph | 데이터 특성에 맞는 DB 선택 |
| CAP 정리 | 일관성, 가용성, 분할 내성 | 분산 시스템의 근본적 제약 |
| Redis | 캐시, 세션, 랭킹, Pub/Sub | 고성능 인메모리 활용 |
| MongoDB | 문서 DB, 스키마 유연성 | 비정형 데이터 처리 |

---

### Data Structure (자료구조)

> 데이터를 효율적으로 저장하고 접근하기 위한 구조

#### 선형 자료구조

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 배열 | 연속 메모리, O(1) 접근 | 가장 기본적인 자료구조 |
| 연결 리스트 | 단일/이중/원형, 동적 크기 | 삽입/삭제 O(1), 포인터 이해 |
| 스택 | LIFO, push/pop | 함수 호출, 괄호 검사, DFS |
| 큐 | FIFO, enqueue/dequeue | BFS, 작업 스케줄링 |
| 덱 | 양방향 삽입/삭제 | 슬라이딩 윈도우 최적화 |

#### 비선형 자료구조

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 이진 트리 | 전위/중위/후위/레벨 순회 | 계층 구조 표현, 탐색 기초 |
| 이진 탐색 트리 | BST, 삽입/삭제/탐색 | 정렬된 데이터의 효율적 관리 |
| 균형 트리 | AVL, Red-Black Tree | 최악 O(log N) 보장 |
| 힙 | 최대힙/최소힙, heapify | 우선순위 큐, 힙 정렬 |
| 트라이 | 문자열 저장, 접두사 검색 | 자동완성, 사전 구현 |

#### 해시

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 해시 테이블 | 해시 함수, O(1) 평균 접근 | 빠른 검색이 필요한 모든 곳 |
| 충돌 해결 | 체이닝, 개방 주소법 | 해시 성능 유지 |
| 해시 함수 | 좋은 해시의 조건, 균등 분포 | 충돌 최소화 |

#### 그래프

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 그래프 표현 | 인접 행렬, 인접 리스트 | 메모리 vs 탐색 시간 트레이드오프 |
| 그래프 종류 | 방향/무방향, 가중치, 순환 | 문제 모델링 |

---

### Algorithm (알고리즘)

> 문제를 해결하기 위한 절차와 방법

#### 복잡도 분석

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 시간 복잡도 | Big-O, Big-Ω, Big-Θ | 알고리즘 효율성 비교 기준 |
| 공간 복잡도 | 메모리 사용량 분석 | 메모리 제약 환경 대응 |
| 최선/평균/최악 | 입력에 따른 성능 변화 | 실제 성능 예측 |

#### 정렬

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 비교 정렬 | 퀵, 병합, 힙 정렬 | O(N log N) 정렬의 이해 |
| 비비교 정렬 | 계수, 기수, 버킷 정렬 | O(N) 정렬이 가능한 조건 |
| 정렬 선택 기준 | 안정성, 제자리, 적응성 | 상황에 맞는 정렬 선택 |

#### 탐색

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 이진 탐색 | 정렬된 배열 O(log N) 탐색 | 검색 최적화의 기본 |
| DFS/BFS | 깊이/너비 우선 탐색 | 그래프 탐색의 기본 |
| 이진 탐색 응용 | 파라메트릭 서치, Lower/Upper Bound | 최적화 문제 해결 |

#### 그래프 알고리즘

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 최단 경로 | 다익스트라, 벨만포드, 플로이드워셜 | 네비게이션, 네트워크 라우팅 |
| MST | 크루스칼, 프림 | 최소 비용 네트워크 구축 |
| 위상 정렬 | DAG에서 순서 결정 | 작업 의존성 해결, 빌드 순서 |
| Union-Find | Disjoint Set, 경로 압축 | 그룹핑, 사이클 탐지 |

#### 알고리즘 설계 기법

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 분할 정복 | 문제를 나누어 해결 후 병합 | 병합정렬, 퀵정렬, 이진탐색 |
| 동적 프로그래밍 | 메모이제이션, 타뷸레이션 | 중복 부분문제 최적화 |
| 그리디 | 매 순간 최적 선택 | 탐욕적 선택 속성 만족 시 |
| 백트래킹 | 가지치기를 통한 탐색 | 조합, 순열, N-Queen |

---

### System Design (시스템 설계)

> 대규모 시스템의 아키텍처 설계 원칙과 패턴

#### 확장성 & 성능

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 수직/수평 확장 | Scale-Up vs Scale-Out | 트래픽 증가 대응 전략 |
| 캐싱 전략 | Cache-Aside, Write-Through/Back/Around | 읽기 성능 최적화 |
| 캐시 무효화 | TTL, 이벤트 기반, 버전닝 | 데이터 정합성 유지 |
| 데이터베이스 확장 | 레플리케이션, 샤딩, 파티셔닝 | 데이터 계층 병목 해소 |

#### 가용성 & 안정성

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 고가용성 (HA) | 이중화, 페일오버, 헬스체크 | 서비스 연속성 보장 |
| 서킷 브레이커 | 장애 전파 차단, 폴백 | 장애 격리 및 복구 |
| Rate Limiting | 토큰 버킷, 슬라이딩 윈도우 | 과부하 보호 |
| Retry & Timeout | 지수 백오프, 데드라인 | 일시적 장애 극복 |

#### 분산 시스템

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| CAP 정리 | 일관성, 가용성, 분할 내성 | 분산 시스템 설계의 근본 제약 |
| 분산 트랜잭션 | 2PC, Saga 패턴 | 여러 서비스 간 데이터 정합성 |
| 분산 락 | Redis, ZooKeeper | 분산 환경 동시성 제어 |
| 합의 알고리즘 | Raft, Paxos | 분산 시스템 상태 일관성 |

#### 아키텍처 패턴

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| MSA vs 모놀리식 | 장단점, 전환 전략 | 시스템 규모에 맞는 아키텍처 선택 |
| 이벤트 드리븐 | 이벤트 소싱, CQRS | 느슨한 결합, 확장성 |
| API 게이트웨이 | 라우팅, 인증, 집계 | MSA 진입점 관리 |

#### 메시징

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 메시지 큐 | Kafka, RabbitMQ, SQS | 비동기 처리, 시스템 분리 |
| Pub/Sub | 발행-구독 패턴, 토픽 | 다대다 통신 |
| 메시지 보장 | At-most/At-least/Exactly-once | 메시지 유실/중복 처리 |

#### 컨테이너 & 오케스트레이션

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| Docker | 컨테이너, 이미지, Dockerfile | 환경 일관성, 배포 단순화 |
| Kubernetes | Pod, Service, Deployment, Ingress | 컨테이너 오케스트레이션 표준 |
| 서비스 메시 | Istio, Envoy | MSA 통신 관리 |

#### 설계 원칙

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 계층 분리 | Presentation, Business, Data | 관심사 분리, 유지보수성 |
| DTO-Entity 변환 | 의존성 방향, 도메인 순수성 | Clean Architecture 실현 |
| API 설계 | 버전닝, 페이지네이션, 에러 처리 | 클라이언트 친화적 인터페이스 |

---

### Programming (프로그래밍)

> 프로그래밍 패러다임과 소프트웨어 설계 원칙

#### 패러다임

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| OOP | 캡슐화, 상속, 다형성, 추상화 | 대규모 소프트웨어의 복잡성 관리 |
| 함수형 프로그래밍 | 순수 함수, 불변성, 고차 함수 | 동시성 안전, 테스트 용이성 |
| 절차적 프로그래밍 | 순차 실행, 함수 단위 | 단순한 작업에 적합 |

#### 설계 원칙

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| SOLID | SRP, OCP, LSP, ISP, DIP | 유지보수성, 확장성 있는 설계 |
| DRY / KISS / YAGNI | 중복 제거, 단순화, 불필요한 것 배제 | 코드 품질 기본 원칙 |
| 결합도와 응집도 | 낮은 결합도, 높은 응집도 | 변경 영향 최소화 |

#### 디자인 패턴

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 생성 패턴 | Singleton, Factory, Builder, Prototype | 객체 생성 로직 캡슐화 |
| 구조 패턴 | Adapter, Decorator, Proxy, Facade | 클래스/객체 구조 유연하게 구성 |
| 행위 패턴 | Strategy, Observer, Template Method, State | 객체 간 책임 분배 |

#### 클린 코드

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 네이밍 | 의도를 드러내는 이름 | 코드 가독성의 기본 |
| 함수 설계 | 한 가지 일만, 작게, 추상화 수준 일치 | 이해하기 쉬운 코드 |
| 에러 처리 | 예외 vs 리턴 코드, 예외 계층 | 견고한 프로그램 |
| 리팩토링 | 코드 스멜, 리팩토링 기법 | 지속적인 코드 개선 |

---

### Security (보안)

> 시스템과 데이터를 보호하기 위한 기술과 원칙

#### 인증 & 인가

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 인증 vs 인가 | Authentication vs Authorization | 보안의 두 축 이해 |
| 세션 기반 인증 | 서버 세션, 쿠키 | 전통적인 상태 유지 방식 |
| 토큰 기반 인증 | JWT, Access/Refresh Token | 무상태 인증, MSA에 적합 |
| OAuth 2.0 | 인가 프레임워크, 플로우 | 제3자 인증 위임 |

#### 웹 보안

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| OWASP Top 10 | 주요 웹 취약점 | 가장 흔한 공격 벡터 인지 |
| XSS | 스크립트 삽입, 방어 | 클라이언트 측 공격 방어 |
| CSRF | 사이트 간 요청 위조 | 사용자 권한 도용 방지 |
| SQL Injection | SQL 삽입, 방어 | DB 보안의 기본 |

#### 암호화

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 대칭키 암호화 | AES, 키 관리 | 데이터 암호화 |
| 비대칭키 암호화 | RSA, 공개키/개인키 | 키 교환, 전자서명 |
| 해시 | SHA, bcrypt, salt | 비밀번호 저장 |
| TLS/SSL | 핸드셰이크, 인증서 | 전송 구간 암호화 |

---

### Git (버전 관리)

> 소스 코드 버전 관리와 협업

#### 기초

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| Git 기본 개념 | Repository, Commit, Branch | 버전 관리의 기본 |
| Git 내부 구조 | Object, Tree, Blob, Ref | Git 동작 원리 이해 |

#### 브랜치 전략

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| Git Flow | feature, develop, release, hotfix | 복잡한 릴리스 관리 |
| GitHub Flow | main + feature 브랜치 | 단순하고 빠른 배포 |
| Trunk Based | 짧은 브랜치, 빈번한 머지 | CI/CD에 최적화 |

#### 고급

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| Rebase vs Merge | 히스토리 정리 vs 보존 | 깔끔한 커밋 히스토리 |
| Cherry-pick | 특정 커밋 선택 적용 | 핫픽스 백포트 |
| Git Hooks | 커밋/푸시 시 자동화 | 품질 검사 자동화 |

---

### Language (언어별 심화)

> 특정 언어의 깊은 이해와 최적화

#### Java

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| JVM 구조 | 클래스로더, 런타임 영역, 실행 엔진 | Java 동작 원리 이해 |
| GC | Serial, Parallel, G1, ZGC | 메모리 관리 최적화 |
| 동시성 | synchronized, volatile, Atomic, Lock | 멀티스레드 프로그래밍 |
| 컬렉션 프레임워크 | List, Set, Map 구현체별 특성 | 적절한 자료구조 선택 |
| Stream API | 내부 동작, 병렬 스트림, 성능 | 함수형 스타일 코딩 |
| 제네릭 | 타입 소거, 와일드카드, PECS | 타입 안전한 코드 |

#### Kotlin

| 주제 | 설명 | 왜 중요한가? |
|------|------|-------------|
| Null Safety | ?, !!, let, elvis | NPE 방지 |
| Coroutine | suspend, launch, async, Flow | 비동기 프로그래밍 |
| 확장 함수 | 기존 클래스 확장 | 유틸리티 코드 개선 |
| Data Class | equals, hashCode, copy 자동 생성 | DTO 간소화 |

---

## 문서 작성 템플릿

```markdown
# {주제명}

> 한 줄 정의

## 핵심 개념

{주제의 핵심 개념 3-5개를 불릿포인트로 정리}

## 쉽게 이해하기

{비전공자도 이해할 수 있는 실생활 비유나 예시로 개념 설명}

## 상세 설명

### {소주제 1}

{상세 내용}

**왜 이렇게 하는가?**
{이유 설명}

### {소주제 2}

**권장 (O)**: {권장 패턴}
**비권장 (X)**: {비권장 패턴}

**왜?**
{구체적인 이유 - 기술적 근거 포함}

**만약 지키지 않으면?**
{실제 발생 가능한 문제}

## 동작 원리 (해당되는 경우)

{순서도, 다이어그램, 또는 단계별 설명}

## 예제 코드 (해당되는 경우)

```java
// 예제 코드
```

## 트레이드오프 (해당되는 경우)

| 장점 | 단점 |
|------|------|
| {장점 1} | {단점 1} |
| {장점 2} | {단점 2} |

## 면접 예상 질문

- Q: {질문 1}
  - A: {답변 - "왜?"에 대한 설명 포함}

## 참고 자료

- {참고 링크 또는 서적}
```

---

## 작성 규칙

### 파일명

- kebab-case 사용: `tcp-handshake.md`, `process-vs-thread.md`
- 영문 소문자: `index.md` (O), `Index.md` (X)

### 내용 작성

| 항목 | 규칙 |
|------|------|
| 핵심 개념 | 3-5개의 불릿포인트로 요약 |
| 쉽게 이해하기 | 실생활 비유, 일상 예시로 개념 설명 (비전공자 대상) |
| 상세 설명 | 개념별 소제목(H3)으로 구분, **"왜?"** 포함 필수 |
| 예제 코드 | 언어 명시, 주석으로 설명 추가 |
| 면접 질문 | 실제 면접에서 자주 나오는 질문 2-3개, 답변에 이유 포함 |
| 참고 자료 | 공식 문서, 신뢰할 수 있는 출처 |

### 품질 기준

- **정확성**: 공식 문서 및 신뢰할 수 있는 출처 기반
- **이해 용이성**: 비전공자도 이해할 수 있는 실생활 비유와 예시 포함
- **논리성**: 모든 주장에 "왜?"에 대한 답변 포함
- **실용성**: 면접 대비, 실무 적용 가능한 내용
- **일관성**: 동일한 템플릿과 스타일 유지

---

## "왜?" 중심 작성 원칙

> **모든 설명은 "왜?"라는 질문에 답할 수 있어야 한다.**

### 핵심 원칙

단순히 "이렇게 해라" 또는 "이것은 이렇다"가 아닌, **왜 그런지 이유를 반드시 설명**한다.

| Bad (이유 없음) | Good (이유 포함) |
|----------------|-----------------|
| Entity에서 DTO를 생성하면 안 된다 | Entity에서 DTO를 생성하면 안 된다. **왜냐하면** 도메인 계층이 응용 계층에 의존하게 되어 DIP를 위반하고, DTO 변경 시 Entity까지 재컴파일되기 때문이다 |
| 인덱스를 사용하면 조회가 빨라진다 | 인덱스를 사용하면 조회가 빨라진다. **왜냐하면** B+Tree 구조로 O(log N) 탐색이 가능하고, 풀 테이블 스캔 대신 인덱스 스캔만 하면 되기 때문이다 |
| TCP는 신뢰성이 있다 | TCP는 신뢰성이 있다. **왜냐하면** 3-way handshake로 연결을 수립하고, ACK/재전송 메커니즘으로 패킷 손실을 복구하며, 순서 번호로 순서를 보장하기 때문이다 |

### "된다 / 안 된다" 작성 가이드

권장 사항이나 금지 사항을 설명할 때는 반드시 **구체적인 이유**와 **실제 문제 상황**을 함께 제시한다.

#### 작성 형식

```markdown
### {주제}

**권장 (O)**: {권장 패턴}
**비권장 (X)**: {비권장 패턴}

**왜?**
{구체적인 이유 설명 - 기술적 근거 포함}

**만약 지키지 않으면?**
{실제로 발생할 수 있는 문제 상황}

**예외 상황**
{이 규칙을 따르지 않아도 되는 경우가 있다면 명시}
```

### 기술적 근거 제시

설명에는 반드시 **기술적 근거**를 포함한다:

| 유형 | 예시 |
|------|------|
| 시간/공간 복잡도 | "O(N)에서 O(log N)으로 개선되기 때문에" |
| 설계 원칙 | "SRP/OCP/DIP를 위반하기 때문에" |
| 메모리/성능 | "메모리 단편화가 발생하기 때문에" |
| 동시성/안전성 | "Race Condition이 발생할 수 있기 때문에" |
| 결합도/응집도 | "높은 결합도로 변경 영향이 전파되기 때문에" |
| 트레이드오프 | "읽기 성능은 좋지만 쓰기 성능이 저하되기 때문에" |

### 심층 분석 포함

복잡한 개념에는 다음을 포함한다:

#### 1. 문제 상황 → 해결책 → 이유 구조

```markdown
### 문제 상황
대용량 테이블에서 특정 컬럼 조회 시 풀 테이블 스캔으로 10초 이상 소요

### 해결책
해당 컬럼에 B+Tree 인덱스 생성

### 왜 이 해결책인가?
- B+Tree는 정렬된 구조로 O(log N) 탐색 가능
- 리프 노드가 연결 리스트로 연결되어 범위 검색에 효율적
- 디스크 I/O 최소화 (높이가 보통 3-4로 제한됨)

### 왜 다른 방법이 아닌가?
- Hash 인덱스: 범위 검색 불가 (동등 비교만 가능)
- Full-text 인덱스: 텍스트 검색 전용, 일반 조회에 부적합
- 파티셔닝: 관리 복잡도 증가, 단순 조회에는 과도함
```

#### 2. 트레이드오프 명시

```markdown
### 인덱스 사용의 트레이드오프

| 장점 | 단점 |
|------|------|
| 조회 성능 향상 (O(N) → O(log N)) | INSERT/UPDATE/DELETE 성능 저하 |
| 정렬 비용 절감 | 추가 저장 공간 필요 (테이블의 10-20%) |
| 커버링 인덱스로 테이블 접근 제거 | 인덱스 유지보수 오버헤드 |

**결론**: 조회가 많고 쓰기가 적은 테이블에 적합.
OLTP 시스템에서는 신중하게 적용, OLAP 시스템에서는 적극 활용.
```

#### 3. 단계별 인과 관계

```markdown
### TCP 3-way Handshake가 필요한 이유

**문제**: 신뢰할 수 없는 네트워크에서 양방향 통신 수립

**왜 3단계인가?**

1. **SYN (Client → Server)**
   - 클라이언트가 통신 의사 표시
   - 초기 순서 번호(ISN) 전달
   - 왜? → 서버가 클라이언트의 존재를 확인해야 함

2. **SYN-ACK (Server → Client)**
   - 서버가 요청 수락 + 자신의 ISN 전달
   - 왜? → 클라이언트가 서버의 수신 능력을 확인해야 함
   - 왜 SYN만으로 부족? → 서버→클라이언트 방향 확인 안 됨

3. **ACK (Client → Server)**
   - 클라이언트가 서버의 SYN-ACK 수신 확인
   - 왜? → 서버가 자신의 응답이 도착했음을 알아야 함
   - 왜 2단계로 부족? → 서버는 자신의 응답 도착 여부를 모름

**왜 4단계가 아닌가?**
- 3단계로 양방향 통신 확인 완료
- 추가 단계는 불필요한 오버헤드
```

### 면접 질문 작성 가이드

면접 질문 답변에도 "왜?"를 포함한다:

```markdown
## 면접 예상 질문

- Q: 왜 TCP는 3-way handshake를 사용하나요? 2-way로는 안 되나요?
  - A: 2-way로는 서버가 자신의 응답(SYN-ACK)이 클라이언트에 도착했는지
    확인할 수 없습니다. 만약 SYN-ACK가 유실되면 서버는 연결이 수립되었다고
    생각하지만 클라이언트는 아직 대기 중인 상태가 됩니다.
    3번째 ACK를 통해 양방향 통신이 모두 가능함을 확인할 수 있습니다.
    4-way는 이미 양방향 확인이 완료되어 불필요한 오버헤드입니다.

- Q: 인덱스를 많이 만들면 좋은 거 아닌가요?
  - A: 아닙니다. 인덱스는 조회 성능을 높이지만 쓰기 성능을 저하시킵니다.
    **왜냐하면** INSERT/UPDATE/DELETE 시 인덱스도 함께 갱신해야 하기 때문입니다.
    또한 인덱스는 테이블 크기의 10-20% 추가 공간을 차지합니다.
    **따라서** 자주 조회되는 컬럼, WHERE/JOIN/ORDER BY에 사용되는 컬럼에만
    선별적으로 생성해야 합니다.
```

---

## README.md 업데이트

새 문서 작성 시 해당 카테고리의 README.md에 링크 추가:

```markdown
## 목차

- [{주제명}](./{파일명}.md) - 한 줄 설명
```

---

## 사용 예시

사용자 요청:
> "오늘의 CS: TCP 3-way handshake"

Claude 작업:
1. `cs/network/tcp-handshake.md` 파일 생성
2. 템플릿에 맞게 내용 작성 (왜? 포함)
3. `cs/network/README.md`에 링크 추가
4. `git add` 실행

---

## "쉽게 이해하기" 작성 가이드

> 비전공자도 이해할 수 있도록 **실생활 비유**와 **일상 예시**를 활용한다.
> 모든 CS 문서에는 반드시 "쉽게 이해하기" 섹션을 포함해야 한다.

### 좋은 비유의 조건

| 조건 | 설명 | 왜 중요한가? |
|------|------|-------------|
| 친숙함 | 누구나 아는 일상적인 상황 사용 | 새로운 개념을 익숙한 것에 연결해야 이해가 빠름 |
| 정확성 | 개념의 핵심 특성을 잘 반영 | 잘못된 비유는 오개념을 만듦 |
| 단순함 | 복잡한 비유보다 간단한 비유 선호 | 비유 자체가 복잡하면 본말전도 |
| 확장성 | 비유를 통해 파생 개념도 설명 가능 | 하나의 비유로 여러 개념을 연결 |

### 카테고리별 비유 모음

#### Network (네트워크)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| OSI 7계층 | 택배 배송 시스템 | 물건(데이터)을 보내려면 포장(응용)→송장(전송)→주소(네트워크)→트럭(데이터링크)→도로(물리) 단계를 거침 |
| TCP | 등기우편 | 받는 사람이 수령 확인 서명을 해야 배송 완료. 분실 시 재발송 |
| UDP | 전단지 배포 | 일단 뿌리고 받았는지 확인 안 함. 빠르지만 도착 보장 없음 |
| TCP 3-way handshake | 전화 통화 시작 | "여보세요?"(SYN) → "네, 들려요"(SYN-ACK) → "좋아요, 얘기해요"(ACK) |
| HTTP | 식당 주문 | 손님(클라이언트)이 메뉴판 보고 주문(요청)하면 주방(서버)에서 음식(응답) 제공 |
| HTTPS | 귓속말 주문 | 다른 손님이 못 듣게 암호화된 귓속말로 주문 |
| DNS | 전화번호부 | "홍길동"(도메인)을 검색하면 "010-1234-5678"(IP) 알려줌 |
| 로드밸런싱 | 은행 번호표 시스템 | 창구(서버)가 여러 개일 때 대기 고객을 빈 창구로 안내 |
| CDN | 편의점 체인 | 본사 창고(원본 서버)에서 가져오면 느리니까, 동네 편의점(엣지 서버)에 미리 재고를 배치 |
| WebSocket | 전화 통화 | HTTP가 편지(요청-응답)라면, WebSocket은 전화(실시간 양방향) |

#### OS (운영체제)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 운영체제 | 회사의 총무팀 | 직원(프로그램)들이 회의실, 프린터, 비품(하드웨어) 쓰려면 총무팀(OS)을 통해야 함 |
| 프로세스 | 독립된 사무실 | 각 사무실(프로세스)은 자체 공간, 가구, 문서(메모리)를 가짐. 다른 사무실과 격리 |
| 스레드 | 사무실 안의 직원들 | 같은 사무실(프로세스) 안에서 책상, 프린터(메모리)를 공유하며 일하는 직원들 |
| 컨텍스트 스위칭 | 멀티태스킹하는 직장인 | A업무 하다가 B업무로 전환할 때, A 상태를 메모해두고(저장) B로 전환. 다시 A로 돌아올 때 메모 확인(복원) |
| 데드락 | 좁은 복도의 교착 상태 | 두 사람이 마주보고 "먼저 비켜주세요"라며 기다림. 둘 다 양보 안 하면 영원히 못 지나감 |
| 뮤텍스 | 화장실 잠금장치 | 한 명만 사용 가능. 잠그고 들어가면 다른 사람은 밖에서 대기 |
| 세마포어 | 주차장 만차 표시 | 주차 가능 대수(카운터)를 관리. 0이면 대기, 차 빠지면 +1 |
| 가상 메모리 | 도서관 열람실 책상 | 책상(RAM)은 작지만, 필요한 책만 꺼내 놓고 나머지는 서가(디스크)에 둠 |
| 페이징 | 바인더 파일 | 문서를 낱장(페이지)으로 나눠 필요한 장만 바인더에 끼움 |
| 페이지 폴트 | 책상에 없는 서류 | "이 서류 어딨지?" → 서랍(디스크)에서 찾아서 책상(메모리)에 올림 |
| 캐시 | 책상 위 자주 쓰는 물건 | 펜, 포스트잇은 서랍 안이 아닌 책상 위에 둬야 바로 사용 가능 |

#### DB (데이터베이스)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 데이터베이스 | 도서관 | 책(데이터)을 체계적으로 분류, 보관, 검색할 수 있는 시스템 |
| 테이블 | 엑셀 시트 | 행(레코드)과 열(컬럼)로 구성된 데이터 표 |
| 인덱스 | 책의 색인(찾아보기) | 책 전체를 읽지 않고 "ㄱ: 가나다 - 15페이지"처럼 바로 찾아감 |
| B+Tree 인덱스 | 도서관 서가 배치 | 가나다순 정렬된 서가에서 이진 탐색으로 빠르게 책 찾기 |
| 클러스터드 인덱스 | 사전 | 단어(데이터) 자체가 알파벳순으로 정렬되어 있음 |
| 논클러스터드 인덱스 | 책 뒤의 색인 | 색인 페이지에서 단어 찾고, 해당 페이지로 이동 (두 번 찾기) |
| 트랜잭션 | 은행 송금 | A계좌 출금 + B계좌 입금이 둘 다 성공하거나, 둘 다 취소되어야 함 |
| ACID | 송금의 4가지 보장 | 원자성(둘 다 or 둘 다X), 일관성(잔액 정확), 격리성(다른 송금과 독립), 지속성(완료 후 보존) |
| 락(Lock) | 화장실 사용 중 표시 | 누가 쓰고 있으면 다른 사람은 대기 |
| 데드락 | 서로 다른 열쇠 기다리기 | A가 1번 열쇠 들고 2번 기다림, B가 2번 열쇠 들고 1번 기다림 → 영원히 대기 |
| 정규화 | 중복 서류 정리 | 같은 정보를 여러 곳에 적지 않고, 한 곳에만 적고 참조 |
| 반정규화 | 자주 보는 정보 복사 | 매번 다른 서류함 찾기 귀찮으니까, 자주 보는 건 복사해서 붙여둠 |

#### Algorithm & Data Structure (알고리즘 & 자료구조)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 배열 | 사물함 | 1번, 2번, 3번... 번호로 바로 접근. 중간에 끼워넣기 어려움 |
| 연결 리스트 | 보물찾기 쪽지 | 각 쪽지에 "다음 쪽지는 OO에 있음" 정보 포함. 중간 삽입 쉬움 |
| 스택 | 접시 쌓기 | 마지막에 올린 접시를 먼저 꺼냄 (LIFO) |
| 큐 | 줄서기 | 먼저 온 사람이 먼저 나감 (FIFO) |
| 해시 테이블 | 회사 사물함 | 이름을 해시 함수에 넣으면 사물함 번호가 나옴. 바로 찾아감 |
| 해시 충돌 | 같은 사물함 배정 | 두 사람 이름이 같은 번호로 계산됨 → 한 사물함에 두 명 물건 |
| 이진 트리 | 가계도 | 부모 하나에 자식 최대 둘. 위에서 아래로 탐색 |
| 힙 | VIP 대기열 | 항상 가장 중요한(크거나 작은) 사람이 맨 앞 |
| 이진 탐색 | 사전에서 단어 찾기 | 중간 펼쳐서 앞/뒤 판단 반복. 절반씩 범위 축소 |
| DFS | 미로 탐색 (한 길 끝까지) | 갈림길에서 한 방향으로 끝까지 가보고, 막히면 되돌아와서 다른 길 |
| BFS | 물결 퍼지듯 탐색 | 현재 위치에서 한 칸씩 모든 방향으로 동시에 퍼져나감 |
| 정렬 | 카드 정리 | 흩어진 카드를 숫자순으로 배열 |
| O(1) | 사물함 열기 | 번호만 알면 바로 열기. 사물함 개수와 무관 |
| O(N) | 출석 부르기 | 학생 수만큼 시간 걸림 |
| O(log N) | 사전 검색 | 절반씩 줄이니까 1000페이지도 10번이면 찾음 |
| O(N²) | 모두와 악수 | N명이 서로 악수하면 N×N번 |

#### System Design (시스템 설계)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 수직 확장 | 더 큰 트럭 구매 | 1톤 트럭 → 5톤 트럭. 한계가 있고 비쌈 |
| 수평 확장 | 트럭 대수 늘리기 | 1톤 트럭 5대. 필요하면 계속 추가 가능 |
| 캐시 | 냉장고 | 마트(DB)까지 안 가고 냉장고(캐시)에서 바로 꺼내 먹기 |
| 캐시 미스 | 냉장고에 없음 | 냉장고에 없으면 마트 가야 함 (느림) |
| 캐시 무효화 | 유통기한 관리 | 오래된 음식(데이터)은 버리고 새로 사와야 함 |
| 메시지 큐 | 식당 주문 대기표 | 주문(메시지)을 대기표(큐)에 넣으면, 주방(워커)이 순서대로 처리 |
| 서킷 브레이커 | 두꺼비집 차단기 | 과부하 시 자동 차단해서 화재(장애 전파) 방지 |
| Rate Limiting | 놀이기구 탑승 제한 | 한 번에 10명만. 나머지는 대기 |
| 레플리케이션 | 교과서 복사본 | 원본 1개 + 복사본 여러 개. 원본 분실해도 복사본 있음 |
| 샤딩 | 반 나누기 | 학생 1000명을 A~J반(10개 샤드)으로 나눠서 관리 |
| MSA | 전문 음식점 거리 | 한식, 중식, 일식 각각 전문점. 독립 운영, 필요한 곳만 확장 |
| 모놀리식 | 뷔페 식당 | 모든 음식을 한 주방에서. 관리 편하지만 특정 메뉴만 늘리기 어려움 |
| API 게이트웨이 | 호텔 프론트 데스크 | 모든 요청이 프론트를 거쳐 객실(서비스)로 전달 |
| CAP 정리 | 빠름/정확/안정 중 2개만 | "빠르고 정확하고 저렴하게" 중 2개만 가능한 것처럼 |

#### Programming (프로그래밍)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| OOP | 레고 블록 | 미리 만든 블록(객체)을 조립해서 큰 작품(프로그램) 완성 |
| 캡슐화 | 자동차 운전 | 엔진 구조 몰라도 핸들, 페달만 알면 운전 가능 |
| 상속 | 가업 물려받기 | 부모의 재산(속성), 사업 노하우(메서드)를 자식이 물려받음 |
| 다형성 | 리모컨의 전원 버튼 | TV, 에어컨, 선풍기 다 다르지만 "전원" 버튼은 동일하게 동작 |
| 추상화 | 지하철 노선도 | 실제 거리, 곡선 무시하고 핵심(역, 연결)만 표현 |
| 인터페이스 | USB 포트 | USB 규격만 맞으면 마우스, 키보드, 외장하드 다 연결됨 |
| 의존성 주입 | 배터리 교체형 장난감 | 배터리(의존성)를 외부에서 끼워줌. 충전식, 건전지 자유롭게 교체 |
| SOLID-SRP | 요리사는 요리만 | 요리사가 서빙, 계산, 청소까지 하면 안 됨 |
| SOLID-OCP | 플러그인 시스템 | 본체 수정 없이 플러그인 추가로 기능 확장 |
| SOLID-DIP | 콘센트 규격 | 가전제품이 콘센트 규격(추상화)에 의존. 벽 안 배선(구현)을 몰라도 됨 |
| 함수형 프로그래밍 | 수학 공식 | f(x) = x + 1. 같은 입력엔 항상 같은 출력. 부작용 없음 |
| 불변성 | 공증된 계약서 | 한번 작성하면 수정 불가. 새 계약서를 작성해야 함 |

#### Security (보안)

| 개념 | 비유 | 상세 설명 |
|------|------|----------|
| 인증 | 신분증 확인 | "당신이 홍길동이 맞나요?" 확인 |
| 인가 | 출입 권한 확인 | "홍길동은 이 방에 들어갈 수 있나요?" 확인 |
| 세션 | 놀이공원 팔찌 | 입장 시 팔찌 받고, 팔찌 보여주면 재입장 가능 |
| JWT | 신분증 + 자격증 | 신분 정보와 권한이 적힌 카드. 서버가 매번 DB 안 봐도 됨 |
| OAuth | 대리인 위임장 | "구글님, 이 앱이 제 이메일을 볼 수 있게 허락합니다" |
| 암호화 | 자물쇠 금고 | 열쇠(키) 있는 사람만 내용물 확인 가능 |
| 해시 | 지문 | 원본에서 지문(해시)은 추출 가능하지만, 지문으로 원본 복원 불가 |
| Salt | 지문에 얼룩 추가 | 같은 비밀번호도 사람마다 다른 해시값 생성 |
| XSS | 식당 설문지에 폭탄 | 설문지(입력창)에 악성 스크립트를 넣어 다른 손님 공격 |
| SQL Injection | 주문서 조작 | "아메리카노 1잔" 대신 "아메리카노 1잔; 금고 열어" 주문 |
| CSRF | 위조된 계좌이체 신청서 | 피해자 이름으로 가짜 신청서 제출 |

### 작성 형식

```markdown
## 쉽게 이해하기

**{핵심 개념}**을 {비유 대상}에 비유할 수 있습니다.

{비유 설명 - 왜 이 비유가 적절한지 2~3문장}

예를 들어, {구체적인 일상 상황 예시}

{비유의 한계점이 있다면 언급 - "단, 실제로는 ~라는 점이 다릅니다"}
```

### 작성 예시 모음

#### 예시 1: 페이징

```markdown
## 쉽게 이해하기

**페이징**을 도서관 열람실에 비유할 수 있습니다.

열람실 책상(RAM)은 공간이 제한되어 있어 도서관의 모든 책을 올려놓을 수 없습니다.
그래서 지금 읽을 책만 책상에 두고, 나머지는 서가(디스크)에 둡니다.
다른 책이 필요하면 그때 서가에서 가져옵니다.

예를 들어, 100권짜리 백과사전을 공부할 때:
- 지금 보는 1~3권만 책상에 올림
- 5권이 필요하면 서가에서 가져옴 (페이지 폴트)
- 책상이 꽉 차면 안 보는 책을 서가로 반납 (페이지 교체)

단, 실제 컴퓨터는 사람처럼 "필요할 것 같은 책"을 미리 가져오기도 합니다 (프리페칭).
```

#### 예시 2: 트랜잭션

```markdown
## 쉽게 이해하기

**트랜잭션**을 은행 송금에 비유할 수 있습니다.

A가 B에게 100만원을 송금할 때, 두 가지 작업이 일어납니다:
1. A 계좌에서 100만원 출금
2. B 계좌에 100만원 입금

이 두 작업은 **반드시 둘 다 성공하거나, 둘 다 취소**되어야 합니다.
만약 1만 성공하고 2가 실패하면? 100만원이 공중에서 사라집니다.

예를 들어, 송금 중 시스템 장애가 발생하면:
- 출금만 되고 입금 안 됨 → 돈 증발 (X)
- 트랜잭션 덕분에 → 출금도 취소되어 원래대로 복구 (O)

이것이 ACID의 원자성(Atomicity)입니다.
"All or Nothing" - 전부 성공하거나, 전부 취소하거나.
```

#### 예시 3: 캡슐화

```markdown
## 쉽게 이해하기

**캡슐화**를 자동차 운전에 비유할 수 있습니다.

운전자는 핸들, 페달, 기어만 알면 됩니다.
엔진이 4기통인지 6기통인지, 연료 분사가 어떻게 되는지 몰라도 운전에 문제없습니다.
자동차 제조사가 엔진을 바꿔도, 핸들과 페달이 그대로면 운전 방법은 같습니다.

예를 들어, 은행 계좌 클래스:
- 외부에 공개: `입금()`, `출금()`, `잔액조회()` (핸들, 페달)
- 내부에 숨김: `잔액`, `이자계산로직`, `보안검증` (엔진)

**왜 숨기나요?**
- 잔액을 직접 수정하면 음수가 될 수 있음 (위험)
- `출금()` 메서드를 통하면 잔액 체크 후 안전하게 처리

이것이 **정보 은닉**입니다. 내부 구현을 숨기고, 안전한 인터페이스만 제공합니다.
```

#### 예시 4: 로드밸런싱

```markdown
## 쉽게 이해하기

**로드밸런싱**을 마트 계산대에 비유할 수 있습니다.

마트에 계산대가 5개 있고, 고객이 계속 들어옵니다.
안내 직원(로드밸런서)이 "3번 계산대로 가세요"라고 안내합니다.

안내 방식(알고리즘)은 여러 가지입니다:
- **라운드 로빈**: 1번 → 2번 → 3번 → 1번... 순서대로
- **최소 연결**: 줄이 가장 짧은 계산대로 안내
- **가중치**: 베테랑 직원 계산대에 더 많이 배정

예를 들어, 쇼핑몰 웹사이트:
- 서버 5대가 있음 (계산대 5개)
- 사용자 요청이 들어오면 (고객 입장)
- 로드밸런서가 여유 있는 서버로 전달 (안내)

**왜 필요한가요?**
- 한 서버에 몰리면 느려짐 (한 계산대만 긴 줄)
- 서버 하나가 고장나도 나머지가 처리 (한 계산대 마감해도 OK)
```
