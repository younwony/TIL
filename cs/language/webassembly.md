# WebAssembly (Wasm)

> `[2] 입문` · 선수 지식: [프로그래밍 언어란](./what-is-language.md)

> `Trend` 2026

> 브라우저에서 네이티브에 가까운 성능으로 코드를 실행하기 위한 바이너리 명령어 형식(Binary Instruction Format)

`#WebAssembly` `#Wasm` `#웹어셈블리` `#WASI` `#바이너리포맷` `#BinaryFormat` `#StackBasedVM` `#스택기반` `#샌드박싱` `#Sandboxing` `#포터블` `#Portable` `#Emscripten` `#Rust` `#C` `#C++` `#AssemblyScript` `#엣지컴퓨팅` `#EdgeComputing` `#서버리스` `#Serverless` `#클라우드네이티브` `#CloudNative` `#Wasmtime` `#Wasmer` `#컴파일타겟` `#성능최적화` `#크로스플랫폼` `#브라우저` `#런타임`

## 왜 알아야 하는가?

WebAssembly는 2017년 브라우저에서 시작하여, 2026년 현재 서버사이드, 엣지 컴퓨팅, 클라우드 네이티브까지 확장된 핵심 기술입니다.

- **실무**: 고성능 웹 앱(게임, 이미지/영상 편집, CAD), 엣지 함수, 서버리스 컴퓨팅에서 사용
- **면접**: "브라우저에서 C++/Rust 코드를 어떻게 실행하나요?", "Wasm의 보안 모델은?"
- **기반 지식**: 컴파일러, 가상 머신, 샌드박싱 개념과 연결되며, 현대 클라우드 아키텍처 이해에 필수

## 핵심 개념

- **바이너리 포맷**: 텍스트가 아닌 바이너리로 빠른 파싱과 로딩
- **스택 기반 가상 머신**: JVM처럼 가상 머신 위에서 실행
- **샌드박싱**: 호스트 시스템과 격리된 안전한 실행 환경
- **언어 독립적**: C, C++, Rust, Go 등 다양한 언어에서 컴파일 가능

## 쉽게 이해하기

**택배 배송 시스템에 비유:**

기존 JavaScript는 "편지"와 같습니다. 사람이 읽을 수 있지만 배송(실행)하려면 우체국(인터프리터)에서 하나하나 해석해야 합니다.

WebAssembly는 "규격화된 택배 상자"입니다:
- 이미 포장이 완료되어 있어 바로 배송 가능 (바이너리라 파싱 빠름)
- 어떤 배송 시스템(브라우저, 서버)에서도 동일하게 처리 (포터블)
- 상자 안의 내용물은 밖에서 건드릴 수 없음 (샌드박싱)

## 상세 설명

### WebAssembly의 탄생 배경

```
┌─────────────────────────────────────────────────────────────────┐
│                    브라우저 성능 진화                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│   1995              2008              2015           2017        │
│    │                 │                 │              │          │
│ JavaScript ───► JIT 컴파일러 ───► asm.js ───► WebAssembly       │
│ (인터프리터)     (V8, SpiderMonkey)   (타입 힌트)    (바이너리)   │
│                                                                  │
│   느림 ──────────────────────────────────────► 네이티브 수준     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**왜 JavaScript만으로는 부족했는가?**

JavaScript는 동적 타입 언어로, 실행 시점에 타입을 추론해야 합니다. 이는 최적화의 한계를 가져옵니다. 게임, 영상 편집 같은 고성능 앱은 JavaScript만으로는 네이티브 앱 수준의 성능을 내기 어려웠습니다.

### WebAssembly의 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                    WebAssembly 실행 과정                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────┐     ┌──────────┐     ┌──────────┐                 │
│  │   C++    │     │   Rust   │     │    Go    │                 │
│  │  소스    │     │  소스    │     │  소스    │                 │
│  └────┬─────┘     └────┬─────┘     └────┬─────┘                 │
│       │                │                │                        │
│       ▼                ▼                ▼                        │
│  ┌─────────────────────────────────────────────────────┐        │
│  │              컴파일러 (LLVM 백엔드)                   │        │
│  │         Emscripten, wasm-pack, TinyGo               │        │
│  └──────────────────────┬──────────────────────────────┘        │
│                         │                                        │
│                         ▼                                        │
│               ┌──────────────────┐                               │
│               │   .wasm 파일     │ ◄─ 바이너리 형식               │
│               │  (모듈)          │                               │
│               └────────┬─────────┘                               │
│                        │                                         │
│       ┌────────────────┼────────────────┐                        │
│       ▼                ▼                ▼                        │
│  ┌─────────┐     ┌──────────┐     ┌──────────┐                  │
│  │ 브라우저 │     │  Node.js  │     │  Wasmtime │                  │
│  │ (V8)    │     │          │     │  (서버)   │                  │
│  └─────────┘     └──────────┘     └──────────┘                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 스택 기반 가상 머신

WebAssembly는 JVM과 유사한 스택 기반 가상 머신에서 실행됩니다.

```
┌───────────────────────────────────────┐
│     WebAssembly 스택 연산 예시         │
├───────────────────────────────────────┤
│                                        │
│  코드: (i32.add (i32.const 3)         │
│                 (i32.const 5))        │
│                                        │
│  실행:                                 │
│  ┌─────┐                              │
│  │     │  1. i32.const 3 → push 3     │
│  │  5  │  2. i32.const 5 → push 5     │
│  │  3  │  3. i32.add → pop 3,5        │
│  └─────┘              → push 8        │
│  스택                                  │
│                                        │
│  결과:                                 │
│  ┌─────┐                              │
│  │  8  │                              │
│  └─────┘                              │
│                                        │
└───────────────────────────────────────┘
```

### 샌드박스 보안 모델

WebAssembly의 가장 큰 강점 중 하나는 보안입니다.

```
┌───────────────────────────────────────────────────────────────┐
│                  WebAssembly 샌드박스 모델                      │
├───────────────────────────────────────────────────────────────┤
│                                                                │
│  ┌────────────────────────────────────────────────────────┐   │
│  │                    호스트 환경                           │   │
│  │  ┌──────────────────────────────────────────────────┐  │   │
│  │  │              Wasm 런타임 (샌드박스)                │  │   │
│  │  │  ┌────────────────────────────────────────────┐  │  │   │
│  │  │  │            Wasm 모듈                        │  │  │   │
│  │  │  │                                             │  │  │   │
│  │  │  │  - 선형 메모리 (자체 메모리 공간)            │  │  │   │
│  │  │  │  - 스택 (격리됨)                            │  │  │   │
│  │  │  │  - 테이블 (함수 참조)                       │  │  │   │
│  │  │  │                                             │  │  │   │
│  │  │  │  ✗ 파일 시스템 직접 접근 불가               │  │  │   │
│  │  │  │  ✗ 네트워크 직접 접근 불가                  │  │  │   │
│  │  │  │  ✗ 호스트 메모리 접근 불가                  │  │  │   │
│  │  │  └────────────────────────────────────────────┘  │  │   │
│  │  │                      │                            │  │   │
│  │  │          Import/Export API (명시적 연결)          │  │   │
│  │  │                      │                            │  │   │
│  │  └──────────────────────┼───────────────────────────┘  │   │
│  │                         ▼                              │   │
│  │  ┌──────────────────────────────────────────────────┐  │   │
│  │  │   호스트 함수 (File I/O, Network, etc.)          │  │   │
│  │  └──────────────────────────────────────────────────┘  │   │
│  └────────────────────────────────────────────────────────┘   │
│                                                                │
└───────────────────────────────────────────────────────────────┘
```

**왜 이렇게 하는가?**

신뢰할 수 없는 코드(서드파티 라이브러리, 사용자 업로드 코드)도 안전하게 실행할 수 있습니다. 악성 코드가 있더라도 호스트 시스템에 영향을 줄 수 없습니다.

### WASI: 브라우저를 넘어서

**WASI(WebAssembly System Interface)**는 Wasm이 브라우저 밖에서 시스템 자원에 접근할 수 있게 하는 표준 인터페이스입니다.

```
┌───────────────────────────────────────────────────────────────┐
│                    WASI 아키텍처                               │
├───────────────────────────────────────────────────────────────┤
│                                                                │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                    Wasm 모듈                             │  │
│  │                        │                                 │  │
│  │                 WASI API 호출                            │  │
│  │     (fd_read, fd_write, path_open, clock_get_time)      │  │
│  └────────────────────────┬────────────────────────────────┘  │
│                           │                                    │
│                           ▼                                    │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │                WASI 런타임 구현                          │  │
│  │         (Wasmtime, Wasmer, WasmEdge)                    │  │
│  │                        │                                 │  │
│  │    ┌───────────────────┼───────────────────────┐        │  │
│  │    ▼                   ▼                       ▼        │  │
│  │  Linux              macOS                  Windows      │  │
│  │  syscall            syscall                syscall      │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                │
│  "Write once, run anywhere" - 진정한 크로스 플랫폼             │
│                                                                │
└───────────────────────────────────────────────────────────────┘
```

### 2026년 Wasm 활용 영역

| 영역 | 활용 사례 | 이점 |
|------|----------|------|
| **브라우저** | 게임(Unity), 이미지 편집(Photopea), CAD | 네이티브급 성능 |
| **엣지 컴퓨팅** | Cloudflare Workers, Fastly Compute | 빠른 콜드스타트 (< 1ms) |
| **서버리스** | Fermyon Spin, WasmCloud | 컨테이너 대비 경량 |
| **플러그인 시스템** | Envoy 필터, Figma 플러그인 | 안전한 확장성 |
| **블록체인** | Polkadot, NEAR Protocol | 결정론적 실행 |

## 예제 코드

### Rust → WebAssembly (기본 예제)

```rust
// lib.rs
#[no_mangle]
pub extern "C" fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

```bash
# Wasm으로 컴파일
cargo build --target wasm32-unknown-unknown --release
```

### JavaScript에서 Wasm 로드

```javascript
// Wasm 모듈 로드 및 실행
async function loadWasm() {
    const response = await fetch('add.wasm');
    const bytes = await response.arrayBuffer();
    const { instance } = await WebAssembly.instantiate(bytes);

    // Wasm 함수 호출
    const result = instance.exports.add(3, 5);
    console.log(result); // 8
}

loadWasm();
```

### WAT (WebAssembly Text Format)

```wat
;; 사람이 읽을 수 있는 Wasm 텍스트 형식
(module
  (func $add (param $a i32) (param $b i32) (result i32)
    local.get $a
    local.get $b
    i32.add
  )
  (export "add" (func $add))
)
```

## 트레이드오프

| 장점 | 단점 |
|------|------|
| 네이티브에 가까운 성능 | 디버깅 어려움 (바이너리) |
| 보안 (샌드박싱) | DOM 직접 조작 불가 |
| 언어 독립적 (다양한 언어 지원) | 파일 크기 증가 가능 |
| 크로스 플랫폼 (브라우저, 서버, 엣지) | GC 없음 (수동 메모리 관리 필요) |
| 빠른 콜드스타트 (컨테이너 대비) | 생태계가 아직 성장 중 |

## JavaScript vs WebAssembly

```
┌───────────────────────────────────────────────────────────────┐
│             JavaScript vs WebAssembly 비교                     │
├───────────────────────────────────────────────────────────────┤
│                                                                │
│  특성            JavaScript              WebAssembly           │
│  ─────────────────────────────────────────────────────────────│
│  실행 방식       JIT 컴파일              AOT 컴파일             │
│  타입 시스템     동적 타입               정적 타입              │
│  메모리 관리     GC                      수동 / 언어별 GC       │
│  DOM 접근        직접 가능               JS 통해서만            │
│  파싱 시간       느림 (텍스트)           빠름 (바이너리)        │
│  최적화          실행 중 최적화          미리 최적화됨          │
│  디버깅          쉬움                    어려움                 │
│  사용 언어       JavaScript/TypeScript   C/C++/Rust/Go 등       │
│                                                                │
│  권장 사용 케이스:                                              │
│  - JavaScript: UI 조작, 비즈니스 로직, 일반 웹 앱              │
│  - WebAssembly: 연산 집약적 작업 (이미지/비디오, 게임, 암호화) │
│                                                                │
└───────────────────────────────────────────────────────────────┘
```

## 면접 예상 질문

### Q: WebAssembly가 JavaScript를 대체하나요?

A: **대체가 아닌 보완 관계**입니다. WebAssembly는 DOM에 직접 접근할 수 없어 UI 조작에는 JavaScript가 필요합니다. 연산 집약적인 작업(이미지 처리, 게임 물리 엔진 등)은 Wasm이, UI와 이벤트 처리는 JavaScript가 담당하는 **협력 구조**가 일반적입니다.

### Q: WebAssembly의 보안 모델을 설명해주세요.

A: Wasm은 **샌드박스 환경**에서 실행됩니다. 모듈은 자체 선형 메모리만 접근 가능하고, 파일 시스템/네트워크/호스트 메모리에 직접 접근할 수 없습니다. 외부 자원은 반드시 **Import API**를 통해 호스트가 명시적으로 제공해야 합니다. 이를 통해 신뢰할 수 없는 코드도 안전하게 실행할 수 있습니다.

### Q: WASI란 무엇이며 왜 필요한가요?

A: **WASI(WebAssembly System Interface)**는 Wasm이 브라우저 밖에서 시스템 자원(파일, 네트워크, 시계 등)에 접근하기 위한 표준 인터페이스입니다. 브라우저에서는 Web API가 있지만, 서버/엣지 환경에서는 표준이 없었습니다. WASI 덕분에 "한 번 컴파일, 어디서든 실행(Write once, run anywhere)"이 가능해졌습니다.

### Q: 왜 Wasm이 컨테이너보다 엣지 컴퓨팅에 적합한가요?

A: **콜드스타트 시간** 때문입니다. Docker 컨테이너는 수백 ms~수 초가 걸리지만, Wasm 모듈은 1ms 미만으로 시작됩니다. 또한 바이너리 크기가 작고(KB~MB), 샌드박스 보안이 내장되어 있어 엣지 환경에 이상적입니다.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [프로그래밍 언어란](./what-is-language.md) | 컴파일/인터프리터 개념 | [1] 정의 |
| [JVM 구조](./java/jvm.md) | 가상 머신 비교 | [3] 중급 |
| [엣지 컴퓨팅](../system-design/edge-computing.md) | Wasm 활용 영역 | [3] 중급 |
| [서버리스](../system-design/serverless.md) | Wasm 런타임 | [3] 중급 |

## 참고 자료

- [WebAssembly 공식 사이트](https://webassembly.org/)
- [MDN WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)
- [WASI 공식 문서](https://wasi.dev/)
- [Bytecode Alliance](https://bytecodealliance.org/)
- [Top 20 Software Development Trends in 2026 - Intelegain](https://www.intelegain.com/top-20-software-development-trends-in-2026/)
- [3 Notable Software Development Trends for 2026 - DevOps.com](https://devops.com/3-notable-software-development-trends-for-2026-and-beyond/)
