# 가용성 (Availability)

> `[2] 입문` · 선수 지식: 없음

> 시스템이 정상적으로 동작하여 서비스를 제공할 수 있는 시간의 비율

## 왜 알아야 하는가?

- **실무**: 서비스 중단은 곧 매출 손실. 1시간 다운타임 = 수억 원 손실 (아마존 기준)
- **면접**: "99.9% 가용성을 어떻게 달성하나요?" 필수 질문
- **기반 지식**: SLA, SLO, 이중화, 페일오버 등 시스템 설계의 기초

## 핵심 개념

- **가용성 (Availability)**: 전체 시간 중 시스템이 정상 동작하는 시간의 비율 (99.9% = 연 8.76시간 다운타임)
- **이중화 (Redundancy)**: 장애 대비를 위해 동일한 컴포넌트를 2개 이상 운영하는 전략
- **페일오버 (Failover)**: 주 시스템 장애 시 대기 시스템으로 자동 전환하는 메커니즘
- **헬스체크 (Health Check)**: 시스템 상태를 주기적으로 확인하여 장애를 조기 탐지하는 기법
- **SLA/SLO**: 서비스 수준 약정(SLA)과 목표(SLO)로 가용성을 정량화
- **9의 법칙**: 가용성을 9의 개수로 표현 (99.999% = Five Nines)

## 쉽게 이해하기

**가용성**을 24시간 편의점 운영에 비유할 수 있습니다.

### 편의점이 문을 닫으면 안 되는 이유

편의점이 "24시간"을 표방한다면, 고객은 언제든 문이 열려있다고 기대합니다.

```
일반 가게 (낮은 가용성):
├── 오전 9시~오후 9시만 운영 (50% 가용성)
├── 점심시간 휴게 (고객 불편)
└── 주인 혼자라 화장실 가면 가게 비움

24시간 편의점 (높은 가용성):
├── 365일 24시간 운영 (99.9% 가용성)
├── 직원 교대 근무 (이중화)
└── 한 직원이 아파도 다른 직원이 투입 (페일오버)
```

### 99.9%가 의미하는 것

| 편의점 비유 | 시스템 개념 | 허용 다운타임 |
|------------|------------|--------------|
| 1년에 8시간 정도 닫힘 | 99.9% (Three Nines) | 연 8.76시간 |
| 1년에 1시간만 닫힘 | 99.99% (Four Nines) | 연 52.56분 |
| 1년에 5분만 닫힘 | 99.999% (Five Nines) | 연 5.26분 |

**왜 99%에서 99.9%로 높이는 것이 어려운가?**
- 99% → 99.9%: 다운타임을 3.65일에서 8.76시간으로 줄여야 함 (약 10배 어려움)
- 99.9% → 99.99%: 다운타임을 8.76시간에서 52분으로 줄여야 함 (약 10배 더 어려움)
- 각 9를 추가할 때마다 비용과 복잡도가 10배씩 증가

### 이중화 = 직원 2명 배치

```
직원 1명만 있을 때 (단일 장애점):
├── 직원이 아프면 → 가게 닫음
├── 화장실 가면 → 손님 못 받음
└── 단순하지만 위험함

직원 2명 교대 (이중화):
├── 직원A 근무 중, 직원B 대기
├── 직원A 아프면 → 직원B가 바로 투입 (페일오버)
└── 복잡하지만 안정적

직원 3명 (Active-Active):
├── 평소에도 2명이 동시 근무
├── 바쁠 때 효율적, 한 명 빠져도 괜찮음
└── 비용은 높지만 최고 가용성
```

### 헬스체크 = 매니저의 점검

편의점 매니저가 주기적으로 전화해서 확인:
```
매니저: "가게 잘 돌아가고 있어?"
직원A: "네, 정상입니다" → 헬스체크 성공

매니저: "가게 잘 돌아가고 있어?"
(응답 없음) → 헬스체크 실패 → 직원B 긴급 투입
```

실제 시스템:
```
로드밸런서: 서버1에 /health 요청
서버1: 200 OK → 정상

로드밸런서: 서버2에 /health 요청
(타임아웃) → 서버2를 트래픽 분배에서 제외
```

## 상세 설명

### 1. 가용성 측정

**가용성 계산 공식:**

```
가용성 = (전체 시간 - 다운타임) / 전체 시간 × 100%

예: 1년(8760시간) 중 8.76시간 다운
→ (8760 - 8.76) / 8760 × 100 = 99.9%
```

**9의 법칙 (Nines):**

| 가용성 | 명칭 | 연간 다운타임 | 월간 다운타임 | 주간 다운타임 | 일간 다운타임 |
|--------|------|--------------|--------------|--------------|--------------|
| 90% | One Nine | 36.5일 | 72시간 | 16.8시간 | 2.4시간 |
| 99% | Two Nines | 3.65일 | 7.2시간 | 1.68시간 | 14.4분 |
| 99.9% | Three Nines | 8.76시간 | 43.2분 | 10.1분 | 1.44분 |
| 99.99% | Four Nines | 52.56분 | 4.32분 | 1.01분 | 8.64초 |
| 99.999% | Five Nines | 5.26분 | 25.9초 | 6.05초 | 0.86초 |
| 99.9999% | Six Nines | 31.5초 | 2.59초 | 0.605초 | 0.086초 |

**산업별 목표 가용성:**

```
┌─────────────────────────────────────────────────────────────┐
│ 산업                      목표 가용성      이유              │
├─────────────────────────────────────────────────────────────┤
│ 통신 인프라                99.999%        사회 기반 시설     │
│ 금융 거래                  99.99%         돈 관련, 신뢰 중요 │
│ 이커머스 (성수기)           99.99%         매출 직결         │
│ 일반 웹 서비스              99.9%          합리적 목표        │
│ 내부 관리 도구              99%            비용 대비 효과     │
└─────────────────────────────────────────────────────────────┘
```

**왜 이렇게 하는가?**
- 정량화된 목표가 없으면 "안정적"이라는 모호한 기준만 남음
- SLA(서비스 수준 약정)로 고객과 약속을 명확히 함
- 가용성에 따라 필요한 아키텍처와 비용이 결정됨

### 2. 이중화 (Redundancy)

**이중화 패턴:**

```
[Active-Standby] (비용 효율적)
┌─────────────┐                 ┌─────────────┐
│   Primary   │ ←── 평소 ────→ │   Standby   │
│  (활성)     │                 │   (대기)    │
└──────┬──────┘                 └──────┬──────┘
       │                               │
       ▼                               ▼
   정상 처리                       대기만 함

   Primary 장애 시:
       Standby가 Primary 역할 승계 (Failover)

   장점: 비용 절감 (Standby는 유휴 상태)
   단점: Standby 리소스 낭비, 전환 시간 필요


[Active-Active] (고성능)
┌─────────────┐                 ┌─────────────┐
│   Server 1  │                 │   Server 2  │
│   (활성)    │ ←── 로드밸런싱 ──→ │   (활성)    │
└──────┬──────┘                 └──────┬──────┘
       │                               │
       ▼                               ▼
   50% 트래픽                      50% 트래픽

   장점: 리소스 효율적, 즉시 전환
   단점: 데이터 동기화 복잡, 비용 높음
```

**계층별 이중화:**

```
┌─────────────────────────────────────────────────────────────┐
│                       전체 시스템 이중화                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [클라이언트]                                               │
│       │                                                     │
│       ▼                                                     │
│  ┌──────────────────────────────────────┐                  │
│  │    DNS 라운드 로빈 (다중 IP)          │                  │
│  └────────────────┬─────────────────────┘                  │
│                   │                                         │
│    ┌──────────────┼──────────────┐                         │
│    ▼              ▼              ▼                         │
│  ┌─────┐       ┌─────┐       ┌─────┐                      │
│  │ LB1 │       │ LB2 │       │ LB3 │  ← 로드밸런서 이중화  │
│  └──┬──┘       └──┬──┘       └──┬──┘                      │
│     │             │             │                          │
│     └─────────────┼─────────────┘                          │
│                   │                                         │
│      ┌────────────┼────────────┐                           │
│      ▼            ▼            ▼                           │
│  ┌───────┐   ┌───────┐   ┌───────┐                        │
│  │ App1  │   │ App2  │   │ App3  │  ← 애플리케이션 이중화 │
│  └───┬───┘   └───┬───┘   └───┬───┘                        │
│      │           │           │                             │
│      └───────────┼───────────┘                             │
│                  │                                          │
│         ┌────────┼────────┐                                │
│         ▼        ▼        ▼                                │
│     ┌───────┐ ┌───────┐ ┌───────┐                         │
│     │ Cache1│ │ Cache2│ │ Cache3│  ← 캐시 이중화 (센티넬) │
│     └───────┘ └───────┘ └───────┘                         │
│                  │                                          │
│                  ▼                                          │
│            ┌──────────┐                                    │
│            │ DB Master│                                    │
│            └─────┬────┘                                    │
│                  │                                          │
│        ┌─────────┼─────────┐                               │
│        ▼         ▼         ▼                               │
│   ┌────────┐┌────────┐┌────────┐                          │
│   │Replica1││Replica2││Replica3│  ← DB 이중화 (레플리카)   │
│   └────────┘└────────┘└────────┘                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**왜 이렇게 하는가?**
- 단일 장애점(SPOF) 제거: 어느 컴포넌트가 죽어도 서비스 지속
- 계층별 이중화: 한 계층의 장애가 전체로 전파되지 않음
- 지리적 분산: 데이터센터 장애에도 대응 (멀티 리전)

**만약 지키지 않으면?**
- DB가 하나뿐이면 DB 장애 = 서비스 전체 중단
- 로드밸런서가 하나뿐이면 LB 장애 = 모든 서버 접근 불가
- 단일 리전만 있으면 자연재해/정전 시 복구 불가능

### 3. 페일오버 (Failover)

**페일오버 유형:**

| 유형 | 설명 | 전환 시간 | 데이터 손실 | 비용 |
|------|------|----------|------------|------|
| **Hot Standby** | Standby가 실시간 동기화, 즉시 전환 | 초 단위 | 없음 | 높음 |
| **Warm Standby** | Standby가 주기적 동기화, 설정 후 전환 | 분 단위 | 일부 | 중간 |
| **Cold Standby** | Standby가 꺼져있음, 부팅 후 전환 | 시간 단위 | 많음 | 낮음 |

**자동 페일오버 동작 흐름:**

```
정상 상태:
  ┌─────────┐  Heartbeat  ┌─────────┐
  │ Primary │ ◀────────▶ │ Standby │
  │ (Active)│  "살아있어" │ (대기)  │
  └────┬────┘            └─────────┘
       │
       ▼
   트래픽 처리

장애 발생:
  ┌─────────┐  Heartbeat  ┌─────────┐
  │ Primary │      X      │ Standby │
  │ (죽음)  │ ◀────────▶ │ (감지)  │
  └─────────┘  응답 없음   └────┬────┘
                              │
                              ▼
                        헬스체크 실패 감지
                        (3회 연속 타임아웃)

페일오버 실행:
  ┌─────────┐            ┌─────────┐
  │ Primary │            │ Standby │
  │ (격리)  │            │ (승격)  │
  └─────────┘            └────┬────┘
                              │
                              ▼
                          Primary 역할 승계
                          VIP 인계받기
                          트래픽 수신 시작

복구 후:
  ┌─────────┐  동기화    ┌─────────┐
  │ Primary │ ◀────────▶│ Standby │
  │ (복구됨)│  데이터    │ (Active)│
  └────┬────┘            └─────────┘
       │
       ▼
  Standby로 강등
  (또는 재부팅 후 Active-Active)
```

**페일오버 구현 예시 (데이터베이스):**

```java
// 자동 페일오버 감지 및 전환
public class DatabaseFailoverHandler {
    private DataSource primaryDS;
    private DataSource replicaDS;
    private AtomicBoolean primaryHealthy = new AtomicBoolean(true);

    @Scheduled(fixedDelay = 5000) // 5초마다 헬스체크
    public void healthCheck() {
        try {
            primaryDS.getConnection()
                     .createStatement()
                     .execute("SELECT 1");

            if (!primaryHealthy.get()) {
                log.info("Primary DB 복구 감지");
                primaryHealthy.set(true);
            }
        } catch (SQLException e) {
            log.error("Primary DB 장애 감지", e);
            primaryHealthy.set(false);
            // 알림 발송 (PagerDuty, Slack 등)
            alertOps("Primary DB down, failover to replica");
        }
    }

    public Connection getConnection() throws SQLException {
        if (primaryHealthy.get()) {
            return primaryDS.getConnection();
        } else {
            log.warn("Replica DB로 페일오버");
            return replicaDS.getConnection();
        }
    }
}
```

**왜 이렇게 하는가?**
- 수동 전환은 느림: 담당자 호출 → 상황 파악 → 전환 결정 (수십 분)
- 자동 전환은 빠름: 헬스체크 실패 → 즉시 전환 (수 초)
- 사람은 실수함: 새벽 3시 긴급 호출 시 잘못된 명령어 실행 가능

**만약 지키지 않으면?**
- 수동 페일오버만 있으면: 장애 발견 → 담당자 연락 → 전환 (20분) → 고객 이탈
- 자동 페일오버 없으면: 주말/야간 장애 시 복구 지연

### 4. 헬스체크 (Health Check)

**헬스체크 계층:**

```
┌─────────────────────────────────────────────────────────────┐
│                    헬스체크 계층별 전략                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [로드밸런서 → 애플리케이션]                                │
│  ┌────────────┐   GET /health    ┌──────────────┐          │
│  │    LB      │ ───────────────▶ │  Application │          │
│  └────────────┘   200 OK / 503   └──────────────┘          │
│                                                             │
│  검사 항목:                                                 │
│  ✓ HTTP 응답 (200 OK)                                      │
│  ✓ 응답 시간 < 500ms                                       │
│                                                             │
│  실패 조건:                                                 │
│  ✗ 3회 연속 타임아웃 → 트래픽 차단                          │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [애플리케이션 → 데이터베이스]                              │
│  ┌──────────────┐  SELECT 1   ┌──────────────┐             │
│  │ Application  │ ───────────▶│   Database   │             │
│  └──────────────┘  성공/실패  └──────────────┘             │
│                                                             │
│  검사 항목:                                                 │
│  ✓ DB 커넥션 풀 사용 가능                                   │
│  ✓ 쿼리 실행 성공                                           │
│  ✓ 응답 시간 < 1초                                          │
│                                                             │
│  실패 시:                                                   │
│  → 503 Service Unavailable 반환                            │
│  → LB가 해당 서버 트래픽 차단                               │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [모니터링 → 전체 시스템]                                   │
│  ┌──────────────┐  메트릭 수집  ┌──────────────┐           │
│  │  Prometheus  │ ◀────────────│   시스템      │           │
│  └──────────────┘              └──────────────┘           │
│                                                             │
│  검사 항목:                                                 │
│  ✓ CPU 사용률 < 80%                                        │
│  ✓ 메모리 사용률 < 85%                                     │
│  ✓ 디스크 사용률 < 90%                                     │
│  ✓ 에러율 < 1%                                             │
│  ✓ p99 응답시간 < 1초                                      │
│                                                             │
│  실패 시:                                                   │
│  → 알림 발송 (Slack, PagerDuty)                            │
│  → 자동 스케일링 트리거                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**헬스체크 엔드포인트 구현:**

```java
@RestController
public class HealthCheckController {

    @Autowired
    private DataSource dataSource;

    @Autowired
    private RedisTemplate<String, String> redis;

    // 단순 헬스체크 (로드밸런서용)
    @GetMapping("/health")
    public ResponseEntity<String> health() {
        return ResponseEntity.ok("OK");
    }

    // 상세 헬스체크 (모니터링용)
    @GetMapping("/health/detail")
    public ResponseEntity<HealthStatus> detailedHealth() {
        HealthStatus status = new HealthStatus();

        // DB 연결 확인
        try {
            dataSource.getConnection()
                      .createStatement()
                      .execute("SELECT 1");
            status.setDatabase("UP");
        } catch (Exception e) {
            status.setDatabase("DOWN");
            status.setHealthy(false);
        }

        // Redis 연결 확인
        try {
            redis.opsForValue().get("health-check");
            status.setCache("UP");
        } catch (Exception e) {
            status.setCache("DOWN");
            status.setHealthy(false);
        }

        // 디스크 용량 확인
        long usableDisk = new File("/").getUsableSpace();
        long totalDisk = new File("/").getTotalSpace();
        double diskUsagePercent =
            (1 - (double)usableDisk / totalDisk) * 100;

        if (diskUsagePercent > 90) {
            status.setDisk("CRITICAL");
            status.setHealthy(false);
        } else {
            status.setDisk("UP");
        }

        return status.isHealthy()
            ? ResponseEntity.ok(status)
            : ResponseEntity.status(503).body(status);
    }
}
```

**헬스체크 설정 베스트 프랙티스:**

| 항목 | 권장값 | 이유 |
|------|--------|------|
| **체크 주기** | 5-10초 | 너무 짧으면 오버헤드, 너무 길면 장애 발견 지연 |
| **타임아웃** | 2-5초 | 정상 응답은 ms 단위, 초 단위 응답은 문제 징후 |
| **실패 임계값** | 3회 연속 | 일시적 네트워크 지연 오탐 방지 |
| **성공 임계값** | 2회 연속 | 복구 확인 후 트래픽 재개 |
| **엔드포인트 경로** | /health, /healthz | 업계 표준 경로 사용 |

**왜 이렇게 하는가?**
- 장애 조기 발견: 서비스 영향 전에 문제 감지
- 자동 복구: 장애 서버를 트래픽에서 제외
- 오탐 방지: 일시적 네트워크 지연을 장애로 오판하지 않음

**만약 지키지 않으면?**
- 헬스체크 없으면: 장애 서버로 트래픽이 계속 유입 → 에러율 급증
- 타임아웃 없으면: 응답 안 오는 서버를 무한정 대기 → 전체 시스템 지연
- 단순 TCP 체크만: 애플리케이션은 죽었는데 포트는 열려있어 정상으로 판단

### 5. SLA / SLO (Service Level Agreement / Objective)

**SLA vs SLO vs SLI:**

```
┌─────────────────────────────────────────────────────────────┐
│                      SLA / SLO / SLI                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  SLI (Service Level Indicator) - 실제 측정값                │
│  ├── 가용성: 99.95%                                         │
│  ├── 에러율: 0.01%                                          │
│  ├── p99 지연: 150ms                                        │
│  └── 처리량: 10,000 RPS                                     │
│       ▲                                                     │
│       │ 달성 여부 판단                                       │
│       │                                                     │
│  SLO (Service Level Objective) - 내부 목표                 │
│  ├── 가용성 ≥ 99.9%                                        │
│  ├── 에러율 < 0.1%                                          │
│  ├── p99 지연 < 200ms                                       │
│  └── 처리량 ≥ 5,000 RPS                                     │
│       ▲                                                     │
│       │ 법적 약속                                            │
│       │                                                     │
│  SLA (Service Level Agreement) - 고객 약속                 │
│  ├── 가용성 ≥ 99.5% 보장                                   │
│  ├── 위반 시 환불 20%                                       │
│  └── 월 최대 다운타임 3.6시간                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘

관계: SLI ≥ SLO > SLA
(실제 성능 ≥ 내부 목표 > 고객 약속)
```

**SLA 위반 시 패널티 예시 (AWS EC2):**

| 가용성 | 서비스 크레딧 |
|--------|--------------|
| < 99.99% | 10% |
| < 99.0% | 25% |
| < 95.0% | 100% |

**에러 예산 (Error Budget):**

```
목표 가용성: 99.9%
→ 허용 장애율: 0.1%
→ 월간 허용 다운타임: 43.2분

에러 예산 소진:
┌─────────────────────────────────────────────────────────────┐
│ 주차  │ 발생 장애  │ 누적 다운타임 │ 잔여 예산  │
├─────────────────────────────────────────────────────────────┤
│ 1주차 │ DB 장애    │ 10분         │ 33.2분     │
│ 2주차 │ 배포 롤백  │ 5분          │ 28.2분     │
│ 3주차 │ 캐시 장애  │ 15분         │ 13.2분     │
│ 4주차 │ 예산 부족  │ -            │ 13.2분     │
└─────────────────────────────────────────────────────────────┘

에러 예산 소진 시:
→ 신규 기능 개발 중단
→ 안정성 개선 집중 (리팩토링, 테스트 보강)
→ 배포 동결 (긴급 버그 수정만)
```

**왜 이렇게 하는가?**
- 정량적 목표: "안정적"이 아닌 "99.9% 가용성"으로 명확히
- 책임 분명: SLA 위반 시 보상으로 신뢰 유지
- 에러 예산: 혁신과 안정성의 균형 (100% 가용성은 불가능하고 불필요)

**만약 지키지 않으면?**
- SLA 없으면: 고객 불만에도 법적 책임 없음 → 신뢰 상실
- SLO 없으면: 개발팀이 어느 수준까지 최적화해야 할지 모름
- 에러 예산 없으면: 무리한 배포로 가용성 하락 or 지나친 보수로 혁신 저해

### 6. 가용성 패턴

**Circuit Breaker (서킷 브레이커):**

```
정상 상태 (Closed):
  요청 → [Circuit Breaker] → 외부 서비스 → 응답
                ▲
                │ 실패율 모니터링 (< 50%)

장애 감지 (Open):
  요청 → [Circuit Breaker] ╳ 외부 서비스
                │
                ▼
            즉시 실패 반환
            (Fallback 응답)

일부 복구 시도 (Half-Open):
  요청 → [Circuit Breaker] → 외부 서비스 (일부만 전송)
                ▲
                │ 성공 시 → Closed
                │ 실패 시 → Open
```

**Bulkhead (격벽):**

```
스레드풀 분리:
┌─────────────────────────────────────────────────────────────┐
│                        서버                                 │
├─────────────────────────────────────────────────────────────┤
│  [주문 API 스레드풀: 20개]    [결제 API 스레드풀: 10개]     │
│  ├─ 스레드 1                  ├─ 스레드 1                   │
│  ├─ 스레드 2                  ├─ 스레드 2                   │
│  └─ ...                       └─ ...                        │
│                                                             │
│  결제 API가 느려져도 주문 API는 정상 동작                    │
│  → 장애 격리                                                │
└─────────────────────────────────────────────────────────────┘
```

**Graceful Degradation (우아한 성능 저하):**

```
정상 시:
  사용자 요청 → [추천 시스템] → AI 기반 개인화 추천 → 응답 (500ms)

장애 시:
  사용자 요청 → [추천 시스템 타임아웃]
              → 인기 상품 목록 반환 (캐시) → 응답 (50ms)

  기능은 축소되지만 서비스는 지속
```

## 트레이드오프

| 장점 | 단점 |
|------|------|
| 서비스 신뢰성 향상 | 비용 증가 (서버 2배 이상) |
| 고객 신뢰 확보 | 아키텍처 복잡도 증가 |
| 매출 기회 손실 방지 | 운영 난이도 상승 |
| SLA 준수로 법적 리스크 감소 | 데이터 동기화 오버헤드 |
| 계획된 점검 가능 (무중단 배포) | 디버깅 어려움 (분산 환경) |

**가용성 vs 비용:**

```
      비용
       ▲
       │                           ┌────
       │                        ┌──┘ 99.999%
       │                    ┌───┘ 99.99%
       │               ┌────┘ 99.9%
       │          ┌────┘ 99%
       │    ┌─────┘ 90%
       │────┘
       └──────────────────────────────▶ 가용성

각 9를 추가할 때마다 비용 10배 증가
```

**가용성 vs 일관성 (CAP 정리):**

```
네트워크 분할(Partition) 발생 시:

[CP 선택] - 일관성 우선
├── 가용성 희생: 일부 노드 응답 중단
└── 예: 금융 거래 (잘못된 금액보다 일시 중단이 나음)

[AP 선택] - 가용성 우선
├── 일관성 희생: 노드마다 다른 데이터
└── 예: SNS 타임라인 (약간 다른 피드는 괜찮음)
```

## 면접 예상 질문

- Q: 99.9%와 99.99% 가용성의 차이는 무엇인가요?
  - A: 허용 다운타임이 10배 차이입니다. 99.9%는 연간 8.76시간, 99.99%는 52.56분입니다. **왜 이 차이가 중요한가?** 각 9를 추가할 때마다 비용과 복잡도가 약 10배씩 증가하기 때문입니다. 99.9%는 단일 리전 이중화로 달성 가능하지만, 99.99%는 멀티 리전, 자동 페일오버, 실시간 동기화 등이 필요합니다. 따라서 비즈니스 요구사항에 맞는 적절한 수준을 선택해야 합니다.

- Q: Active-Standby와 Active-Active의 차이는?
  - A: Active-Standby는 주 서버만 동작하고 대기 서버는 장애 시에만 활성화되는 방식이고, Active-Active는 모든 서버가 동시에 트래픽을 처리하는 방식입니다. **왜 선택이 나뉘는가?** Active-Standby는 비용 효율적이지만(대기 서버는 유휴) 페일오버 시간이 필요하고, Active-Active는 비용이 높지만(모든 서버 가동) 즉시 전환 가능하고 리소스 효율적입니다. DB는 보통 Active-Standby(마스터-레플리카), 웹 서버는 Active-Active(로드밸런싱)를 사용합니다.

- Q: 헬스체크를 어떻게 구현하나요?
  - A: 계층별로 다르게 구현합니다. **로드밸런서는 HTTP GET /health 엔드포인트로 단순 체크**(응답 200 OK 확인), **애플리케이션은 DB 커넥션, 캐시 연결, 디스크 용량 등 의존성 체크**, **모니터링 시스템은 메트릭 수집**(CPU, 메모리, 에러율)을 합니다. **왜 이렇게 나누는가?** 로드밸런서는 빠른 판단이 중요해서 단순 체크만 하고, 모니터링은 근본 원인 파악을 위해 상세 메트릭을 수집합니다. 또한 3회 연속 실패 시에만 장애로 판단하여 일시적 네트워크 지연 오탐을 방지합니다.

- Q: 페일오버 시 데이터 손실을 방지하는 방법은?
  - A: 동기식 레플리케이션을 사용합니다. **왜 동기식인가?** 비동기 레플리케이션은 Primary에 쓴 데이터가 Replica에 복제되기 전에 Primary가 죽으면 해당 데이터가 유실되기 때문입니다. 동기식은 Primary와 Replica 모두에 쓰기가 완료된 후 성공 응답을 주므로 데이터 손실이 없습니다. **트레이드오프:** 동기식은 쓰기 지연이 2배 증가하므로, 금융/재고 등 데이터 손실이 치명적인 경우에만 사용하고, 일반적으로는 비동기 + 짧은 복제 지연(수 ms)으로 타협합니다.

- Q: 에러 예산(Error Budget)이 무엇이고 왜 필요한가요?
  - A: 목표 가용성(예: 99.9%)에서 허용되는 장애 시간(0.1%, 월 43.2분)을 예산처럼 관리하는 개념입니다. **왜 필요한가?** 100% 가용성은 불가능하고, 지나치게 보수적이면 혁신이 저해되기 때문입니다. 에러 예산이 남아있으면 적극적으로 신규 기능을 배포하고, 예산이 소진되면 배포를 중단하고 안정성 개선에 집중합니다. 이를 통해 개발 속도(혁신)와 안정성의 균형을 정량적으로 관리할 수 있습니다. **실무 예:** 구글 SRE는 에러 예산 50% 소진 시 경고, 100% 소진 시 배포 동결 정책을 사용합니다.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [확장성](./scalability.md) | 가용성 확보를 위한 수평 확장 | 입문 |
| [서킷브레이커](./circuit-breaker.md) | 장애 전파 방지로 가용성 향상 | 심화 |
| [일관성](./consistency.md) | CAP 정리: 가용성 vs 일관성 트레이드오프 | 중급 |
| [대규모 시스템 설계](./large-scale-system.md) | 가용성을 고려한 전체 시스템 설계 | 심화 |

## 참고 자료

- [Google SRE Book - Embracing Risk](https://sre.google/sre-book/embracing-risk/)
- [AWS Well-Architected Framework - Reliability Pillar](https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/)
- [The Calculus of Service Availability](https://queue.acm.org/detail.cfm?id=3096459)
- Martin Kleppmann, "Designing Data-Intensive Applications" - Chapter 8 (The Trouble with Distributed Systems)
