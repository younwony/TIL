# 확장성 (Scalability)

> 시스템이 증가하는 작업 부하를 처리할 수 있도록 용량을 늘리는 능력

## 핵심 개념

- **수직 확장(Scale Up)**: 단일 서버의 하드웨어 성능을 높이는 방식 (CPU, RAM, SSD 업그레이드)
- **수평 확장(Scale Out)**: 서버 대수를 늘려 부하를 분산하는 방식
- **탄력성(Elasticity)**: 부하에 따라 자동으로 리소스를 조절하는 능력
- **확장성 병목**: 데이터베이스, 네트워크, 디스크 I/O 등 확장의 한계를 만드는 지점
- **선형 확장성**: 리소스 추가에 비례하여 처리량이 증가하는 이상적인 상태

## 쉽게 이해하기

**확장성**을 음식점 운영에 비유할 수 있습니다.

### 수직 확장 (Scale Up) = 더 크고 좋은 주방 장비

손님이 늘어서 주문을 감당하기 힘들 때:
- 더 큰 가스레인지 구매
- 더 빠른 오븐 설치
- 냉장고 용량 업그레이드

**장점**: 기존 운영 방식 그대로 유지
**단점**: 장비에는 한계가 있음 (세상에서 가장 큰 오븐도 한계가 있다)

### 수평 확장 (Scale Out) = 지점을 더 내기

손님이 더 늘어났을 때:
- 2호점, 3호점 오픈
- 각 지점에서 분산 처리

**장점**: 이론상 무한 확장 가능
**단점**: 관리가 복잡해짐 (레시피 통일, 재고 관리 등)

| 비유 | 개념 | 특징 |
|------|------|------|
| 더 큰 주방 | 수직 확장 | 단순하지만 한계 있음 |
| 지점 늘리기 | 수평 확장 | 복잡하지만 무제한 |
| 본사 물류 센터 | 로드밸런서 | 어떤 지점으로 보낼지 결정 |
| 매뉴얼 표준화 | 무상태 설계 | 어느 지점에서든 동일한 서비스 |

### 로드밸런서 = 안내 데스크

백화점 안내 데스크처럼, 손님(요청)을 어느 매장(서버)으로 안내할지 결정합니다.

- **라운드 로빈**: "1번, 2번, 3번... 순서대로 안내"
- **최소 연결**: "지금 제일 한가한 매장으로 안내"
- **IP 해시**: "이 손님은 항상 1번 매장으로" (단골 고객 개념)

### 무상태(Stateless) 설계가 중요한 이유

**상태가 있는 음식점 (문제)**
```
손님: "어제 주문했던 거 똑같이요"
직원: "저 어제 여기 없었는데요... 뭘 드셨죠?"
```

**무상태 음식점 (해결)**
```
손님: "멤버십 카드 여기요" (세션 토큰)
직원: (본사 시스템 조회) "아, 어제 비빔밥 드셨네요!"
```

모든 지점(서버)이 본사 시스템(Redis)을 통해 고객 정보를 공유하면, 어느 지점에서든 동일한 서비스가 가능합니다.

## 상세 설명

### 수직 확장 (Vertical Scaling / Scale Up)

단일 서버의 성능을 향상시키는 방식이다.

| 장점 | 단점 |
|------|------|
| 구현이 단순함 | 하드웨어 한계 존재 |
| 애플리케이션 수정 불필요 | 비용 증가가 비선형적 |
| 데이터 일관성 유지 용이 | 단일 장애점(SPOF) 문제 |
| 운영 복잡도 낮음 | 다운타임 발생 가능 |

```
[Before]          [After Scale Up]
┌─────────┐       ┌─────────────┐
│ 4 CPU   │  →    │ 16 CPU      │
│ 16GB RAM│       │ 64GB RAM    │
│ 500GB   │       │ 2TB SSD     │
└─────────┘       └─────────────┘
```

### 수평 확장 (Horizontal Scaling / Scale Out)

서버 인스턴스를 추가하여 부하를 분산하는 방식이다.

| 장점 | 단점 |
|------|------|
| 이론상 무한 확장 가능 | 구현 복잡도 증가 |
| 고가용성 확보 용이 | 데이터 일관성 관리 어려움 |
| 비용 효율적 | 네트워크 오버헤드 발생 |
| 장애 격리 가능 | 분산 시스템 문제 발생 |

```
[Before]              [After Scale Out]
┌─────────┐           ┌─────────┐
│ Server  │           │ Server1 │
└─────────┘           └─────────┘
                      ┌─────────┐
        →             │ Server2 │
                      └─────────┘
                      ┌─────────┐
                      │ Server3 │
                      └─────────┘
```

### 확장 전략 비교

| 기준 | 수직 확장 | 수평 확장 |
|------|----------|----------|
| 비용 곡선 | 지수적 증가 | 선형적 증가 |
| 장애 복구 | 어려움 | 용이함 |
| 복잡도 | 낮음 | 높음 |
| 한계 | 하드웨어 제약 | 이론상 무제한 |
| 적합 상황 | 초기 단계, DB | 대규모 트래픽 |

### 수평 확장을 위한 핵심 기술

#### 1. 로드 밸런싱

```
                 ┌─────────────┐
  Client ───────→│Load Balancer│
                 └──────┬──────┘
           ┌───────────┼───────────┐
           ▼           ▼           ▼
      ┌────────┐  ┌────────┐  ┌────────┐
      │Server 1│  │Server 2│  │Server 3│
      └────────┘  └────────┘  └────────┘
```

**주요 알고리즘:**
- Round Robin: 순차적으로 요청 분배
- Weighted Round Robin: 서버 성능에 따라 가중치 부여
- Least Connections: 연결 수가 적은 서버로 분배
- IP Hash: 클라이언트 IP 기반 고정 서버 할당

#### 2. 무상태(Stateless) 설계

```java
// 잘못된 예: 서버에 상태 저장
public class SessionController {
    private Map<String, User> sessions = new HashMap<>(); // 서버 메모리에 저장

    public void login(String sessionId, User user) {
        sessions.put(sessionId, user); // 다른 서버에서 접근 불가
    }
}

// 올바른 예: 외부 저장소 사용
public class SessionController {
    private final RedisTemplate<String, User> redis;

    public void login(String sessionId, User user) {
        redis.opsForValue().set(sessionId, user); // 모든 서버에서 접근 가능
    }
}
```

#### 3. 데이터베이스 확장

**읽기 확장 - 레플리케이션:**
```
         ┌──────────────┐
         │ Master (쓰기) │
         └──────┬───────┘
     ┌──────────┼──────────┐
     ▼          ▼          ▼
┌─────────┐┌─────────┐┌─────────┐
│Replica 1││Replica 2││Replica 3│
│ (읽기)  ││ (읽기)  ││ (읽기)  │
└─────────┘└─────────┘└─────────┘
```

**쓰기 확장 - 샤딩:**
```
              ┌─────────────┐
              │ Shard Router│
              └──────┬──────┘
       ┌─────────────┼─────────────┐
       ▼             ▼             ▼
  ┌─────────┐   ┌─────────┐   ┌─────────┐
  │ Shard 1 │   │ Shard 2 │   │ Shard 3 │
  │ (A-H)   │   │ (I-P)   │   │ (Q-Z)   │
  └─────────┘   └─────────┘   └─────────┘
```

### 확장성 측정 지표

| 지표 | 설명 | 목표 |
|------|------|------|
| Throughput | 초당 처리 요청 수 (RPS/TPS) | 부하에 비례하여 증가 |
| Latency | 요청 처리 시간 | 부하 증가에도 일정 유지 |
| Amdahl's Law | 병렬화 가능 부분에 따른 성능 향상 한계 | 병렬화 가능 영역 극대화 |

**Amdahl's Law:**
```
S = 1 / ((1 - P) + P/N)

S: 전체 성능 향상 비율
P: 병렬화 가능한 부분의 비율
N: 프로세서(서버) 수
```

예: 90% 병렬화 가능, 10대 서버
```
S = 1 / ((1 - 0.9) + 0.9/10) = 1 / (0.1 + 0.09) = 5.26배 향상
```

## 실무 적용 가이드

### 확장성 설계 원칙

1. **무상태 설계**: 서버가 세션 상태를 갖지 않도록 설계
2. **캐싱 활용**: Redis, Memcached로 DB 부하 감소
3. **비동기 처리**: 메시지 큐를 통한 작업 분리
4. **데이터 분할**: 샤딩, 파티셔닝으로 데이터 분산
5. **CDN 활용**: 정적 콘텐츠 엣지 서버로 분산

### 단계별 확장 전략

```
[단계 1] 단일 서버
    └── 수직 확장으로 시작

[단계 2] 애플리케이션-DB 분리
    └── 웹서버와 DB 서버 분리

[단계 3] 로드밸런서 + 다중 서버
    └── 수평 확장 시작, Stateless 설계 필수

[단계 4] DB 레플리케이션
    └── Read Replica 추가

[단계 5] 캐시 레이어 추가
    └── Redis/Memcached 도입

[단계 6] 샤딩 + 마이크로서비스
    └── 대규모 시스템 아키텍처
```

## 면접 예상 질문

- Q: 수직 확장과 수평 확장의 차이점과 각각의 장단점은?
  - A: 수직 확장은 단일 서버 성능 향상으로 구현이 단순하지만 한계가 있고, 수평 확장은 서버 추가로 이론상 무한 확장 가능하지만 분산 시스템 복잡도가 증가한다. 초기에는 수직 확장, 규모가 커지면 수평 확장이 적합하다.

- Q: 수평 확장 시 세션 관리는 어떻게 하는가?
  - A: Sticky Session(로드밸런서가 같은 서버로 라우팅), Session Clustering(서버 간 세션 공유), 외부 저장소(Redis) 사용 방식이 있다. 외부 저장소 방식이 가장 확장성이 좋고 권장된다.

- Q: 데이터베이스 확장 전략에는 어떤 것들이 있는가?
  - A: 읽기 확장은 레플리케이션(Master-Slave), 쓰기 확장은 샤딩을 사용한다. 캐시 레이어 추가, 쿼리 최적화, 커넥션 풀링도 함께 적용한다. 샤딩은 조인 어려움, 리밸런싱 복잡도 등의 트레이드오프가 있다.

## 참고 자료

- [AWS Well-Architected Framework - Reliability Pillar](https://docs.aws.amazon.com/wellarchitected/latest/reliability-pillar/)
- [Google Cloud - Patterns for scalable and resilient apps](https://cloud.google.com/architecture/scalable-and-resilient-apps)
- Martin Kleppmann, "Designing Data-Intensive Applications" (O'Reilly)
