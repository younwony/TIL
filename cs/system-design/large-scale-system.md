# 대규모 시스템 설계 기초 (Large-Scale System Design)

> 수백만 사용자와 대용량 데이터를 처리하는 시스템을 설계할 때 반드시 고려해야 하는 핵심 요소들

## 핵심 개념

- **확장성 (Scalability)**: 부하 증가에 따라 시스템 용량을 늘릴 수 있는 능력
- **가용성 (Availability)**: 시스템이 정상 작동하는 시간의 비율 (99.9% = 연 8.76시간 다운타임)
- **일관성 (Consistency)**: 모든 노드가 동일한 데이터를 보는 것
- **지연시간 (Latency)**: 요청부터 응답까지 걸리는 시간
- **처리량 (Throughput)**: 단위 시간당 처리할 수 있는 요청 수
- **내결함성 (Fault Tolerance)**: 일부 장애에도 시스템이 계속 동작하는 능력

## 대규모 시스템의 정의

### 규모의 기준

| 구분 | 소규모 | 중규모 | 대규모 |
|------|--------|--------|--------|
| DAU (일일 활성 사용자) | ~10K | 10K~1M | 1M+ |
| QPS (초당 쿼리) | ~100 | 100~10K | 10K+ |
| 데이터 크기 | ~10GB | 10GB~1TB | 1TB+ |
| 서버 수 | 1~5 | 5~50 | 50+ |

### 대규모가 되면 달라지는 것

```
소규모 시스템:                    대규모 시스템:
┌─────────────┐                  ┌─────────────────────────────────┐
│   Client    │                  │          Clients (수백만)        │
└──────┬──────┘                  └───────────────┬─────────────────┘
       │                                         │
       ▼                                         ▼
┌─────────────┐                  ┌─────────────────────────────────┐
│   Server    │                  │     Load Balancer (다중화)       │
└──────┬──────┘                  └───────────────┬─────────────────┘
       │                                         │
       ▼                          ┌──────────────┼──────────────┐
┌─────────────┐                   ▼              ▼              ▼
│     DB      │           ┌──────────┐   ┌──────────┐   ┌──────────┐
└─────────────┘           │ Server 1 │   │ Server 2 │   │ Server N │
                          └────┬─────┘   └────┬─────┘   └────┬─────┘
   단순하고 빠른 개발              │              │              │
   but 한계 명확                  └──────────────┼──────────────┘
                                                │
                          ┌─────────────────────┼─────────────────────┐
                          ▼                     ▼                     ▼
                    ┌──────────┐         ┌──────────┐         ┌──────────┐
                    │  Cache   │         │ DB Master│         │  Queue   │
                    │ (Redis)  │         │ + Replica│         │ (Kafka)  │
                    └──────────┘         └──────────┘         └──────────┘

                                  복잡하지만 확장 가능
```

**왜 복잡해지는가?**
- 단일 서버의 물리적 한계 (CPU, 메모리, 네트워크)
- 단일 장애점(SPOF) 제거 필요
- 지리적 분산으로 인한 네트워크 지연
- 데이터 정합성 유지의 어려움

---

## 쉽게 이해하기

**대규모 시스템**을 대형 쇼핑몰 운영에 비유할 수 있습니다.

### 동네 가게 vs 대형 쇼핑몰

| 동네 가게 (소규모) | 대형 쇼핑몰 (대규모) |
|-------------------|---------------------|
| 사장님 혼자 운영 | 수백 명의 직원 |
| 재고는 창고 하나 | 여러 물류센터 |
| 손님이 적어 대기 없음 | 대기열 관리 필요 |
| 문 닫으면 끝 | 24시간 운영 필수 |
| 장부 하나로 관리 | 전산 시스템 필수 |

### 쇼핑몰에서 배우는 시스템 설계

```
┌─────────────────────────────────────────────────────────────────┐
│                      대형 쇼핑몰 운영                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  [입구 관리] ─────────────────────────── Load Balancer          │
│  "어느 층으로 가세요?"                     요청 분산             │
│                                                                 │
│  [층별 매장] ─────────────────────────── 서버 클러스터          │
│  각 층이 독립적으로 운영                   수평 확장             │
│                                                                 │
│  [물류센터] ──────────────────────────── Database               │
│  모든 재고 정보 보관                       데이터 저장           │
│                                                                 │
│  [진열대 재고] ────────────────────────── Cache                 │
│  자주 찾는 상품은 매장에 진열               빠른 조회            │
│                                                                 │
│  [주문 접수대] ────────────────────────── Message Queue         │
│  주문 순서대로 처리                        비동기 처리           │
│                                                                 │
│  [안내방송] ──────────────────────────── 알림 시스템            │
│  "주문하신 상품 준비됐습니다"               실시간 알림           │
│                                                                 │
│  [CCTV 관제실] ────────────────────────── 모니터링              │
│  전체 상황 실시간 파악                     장애 감지             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 핵심 고려 사항

### 1. 확장성 (Scalability)

부하 증가에 따라 시스템 용량을 늘릴 수 있는 능력

```
                    확장성의 두 가지 방향

    수직 확장 (Scale Up)              수평 확장 (Scale Out)
    ┌─────────────────┐              ┌─────┐ ┌─────┐ ┌─────┐
    │                 │              │     │ │     │ │     │
    │    더 강력한     │              │ S1  │ │ S2  │ │ S3  │
    │      서버       │              │     │ │     │ │     │
    │                 │              └─────┘ └─────┘ └─────┘
    │  CPU↑ RAM↑ SSD↑ │                   서버 추가
    │                 │
    └─────────────────┘

    장점: 단순함                      장점: 무한 확장 가능
    단점: 물리적 한계                  단점: 복잡성 증가
```

**설계 원칙:**
- 상태 비저장(Stateless) 설계: 세션은 외부 저장소(Redis)에
- 수평 확장 우선: 서버 추가만으로 용량 증가 가능하도록
- 병목 지점 파악: DB, 네트워크, 디스크 I/O 중 어디가 한계인지

**왜 수평 확장이 권장되는가?**
- 비용 효율: 고사양 1대보다 일반 10대가 저렴
- 가용성: 1대 장애 시에도 나머지가 처리
- 유연성: 트래픽에 따라 동적 조절 가능

---

### 2. 가용성 (Availability)

시스템이 정상적으로 서비스를 제공하는 시간의 비율

```
가용성 수준과 허용 다운타임:

┌────────────┬─────────────────┬─────────────────┐
│   가용성    │   연간 다운타임   │      수준       │
├────────────┼─────────────────┼─────────────────┤
│   99%      │   3.65일        │   일반 서비스    │
│   99.9%    │   8.76시간      │   상용 서비스    │
│   99.99%   │   52.56분       │   금융/의료      │
│   99.999%  │   5.26분        │   통신/인프라    │
└────────────┴─────────────────┴─────────────────┘
```

**가용성 확보 전략:**

```
단일 장애점(SPOF) 제거:

Before (SPOF 존재):              After (이중화):
    ┌─────────┐                     ┌─────────┐
    │ Client  │                     │ Client  │
    └────┬────┘                     └────┬────┘
         │                               │
         ▼                               ▼
    ┌─────────┐                  ┌──────────────┐
    │   LB    │ ← SPOF           │  LB (Active) │
    └────┬────┘                  └──────┬───────┘
         │                              │
         ▼                       ┌──────┴───────┐
    ┌─────────┐                  │  LB (Standby)│ ← Failover 대기
    │ Server  │ ← SPOF           └──────────────┘
    └────┬────┘                         │
         │                    ┌─────────┼─────────┐
         ▼                    ▼         ▼         ▼
    ┌─────────┐           ┌──────┐ ┌──────┐ ┌──────┐
    │   DB    │ ← SPOF    │ S1   │ │ S2   │ │ S3   │
    └─────────┘           └──────┘ └──────┘ └──────┘
                                    │
    어디든 장애 나면 끝          ┌───┴───┐
                              ▼       ▼
                          ┌──────┐ ┌──────┐
                          │Master│ │Replica│
                          └──────┘ └──────┘

                          어디서 장애 나도 지속
```

**핵심 기법:**
- 이중화 (Redundancy): 모든 컴포넌트를 2개 이상
- 페일오버 (Failover): 장애 시 자동 전환
- 헬스체크 (Health Check): 주기적 상태 확인
- 그레이스풀 디그레이데이션: 일부 기능 제한하며 핵심 기능 유지

---

### 3. 일관성 (Consistency)

모든 노드에서 동일한 데이터를 보장하는 것

```
일관성 모델 스펙트럼:

강한 일관성                                      최종 일관성
(Strong)                                       (Eventual)
    │                                               │
    ▼                                               ▼
┌───────────────────────────────────────────────────────────────┐
│ ■────────────■────────────■────────────■────────────■        │
│ 즉시 반영    인과적 일관성  세션 일관성   읽기 후 쓰기   최종 일관성 │
└───────────────────────────────────────────────────────────────┘
    │                                               │
    │ 정합성 보장                        성능/가용성 우선 │
    │ 성능 저하                          일시적 불일치   │
```

**CAP 정리:**

```
        Consistency (일관성)
              ▲
             /│\
            / │ \
           /  │  \
          /   │   \
         / CP │ CA \
        /     │     \
       ▼──────┴──────▼
Partition           Availability
Tolerance             (가용성)
(분할 내성)     AP

┌─────────────────────────────────────────────────────────────┐
│ 분산 시스템에서 네트워크 분할(P)은 피할 수 없다              │
│ → 실질적으로 CP vs AP 선택                                  │
│                                                             │
│ CP 선택: 일관성 우선 (금융, 재고)                            │
│    - 네트워크 분할 시 일부 노드 차단                         │
│    - 예: HBase, MongoDB (기본 설정)                         │
│                                                             │
│ AP 선택: 가용성 우선 (SNS, 추천)                            │
│    - 네트워크 분할 시에도 서비스 지속                        │
│    - 예: Cassandra, DynamoDB                                │
└─────────────────────────────────────────────────────────────┘
```

**실제 선택 기준:**

| 상황 | 선택 | 이유 |
|------|------|------|
| 결제/송금 | 강한 일관성 | 돈이 두 번 빠지면 안 됨 |
| 재고 관리 | 강한 일관성 | 초과 판매 방지 |
| 좋아요 수 | 최종 일관성 | 잠깐 다르게 보여도 괜찮음 |
| 타임라인 | 최종 일관성 | 약간의 지연 허용 |
| 세션 데이터 | 세션 일관성 | 같은 사용자는 일관되게 |

---

### 4. 성능 (Performance)

지연시간(Latency)과 처리량(Throughput)의 최적화

```
지연시간의 구성:

사용자 ──────────────────────────────────────────────▶ 응답
        │                                            │
        │  네트워크    서버 처리    DB 조회    네트워크  │
        │   50ms       20ms       100ms      50ms    │
        │                                            │
        └────────────── 총 220ms ─────────────────────┘


지연시간 참고 수치 (Jeff Dean):
┌─────────────────────────────────────────────────────────────┐
│ L1 캐시 참조                           0.5 ns              │
│ L2 캐시 참조                           7 ns                │
│ 메인 메모리 참조                       100 ns               │
│ SSD 랜덤 읽기                          150,000 ns (150 μs)  │
│ HDD 랜덤 읽기                          10,000,000 ns (10 ms)│
│ 같은 데이터센터 네트워크 왕복           500,000 ns (0.5 ms)  │
│ 다른 대륙 네트워크 왕복                 150,000,000 ns (150 ms) │
└─────────────────────────────────────────────────────────────┘
```

**성능 최적화 전략:**

```
1. 캐싱 (가장 효과적)
   ┌──────────┐     Cache Miss      ┌──────────┐
   │  Client  │ ──────────────────▶ │    DB    │  100ms
   └──────────┘                     └──────────┘

   ┌──────────┐     Cache Hit       ┌──────────┐
   │  Client  │ ──────────────────▶ │  Cache   │  1ms
   └──────────┘                     └──────────┘

   → 100배 성능 향상

2. 비동기 처리
   동기:  요청 → [처리 100ms] → 응답
   비동기: 요청 → [큐 1ms] → 응답 → [백그라운드 처리]

   → 사용자 체감 지연 99% 감소

3. CDN (정적 콘텐츠)
   원본 서버: 서울 → 미국 사용자 (150ms)
   CDN:       미국 엣지 → 미국 사용자 (10ms)

   → 15배 성능 향상

4. DB 최적화
   - 인덱스 추가: 테이블 스캔 → 인덱스 스캔 (100배↑)
   - 쿼리 최적화: N+1 문제 해결
   - 읽기/쓰기 분리: Master-Replica 구조
```

---

### 5. 신뢰성 (Reliability)

시스템이 장애 상황에서도 올바르게 동작하는 것

```
장애 유형과 대응:

┌─────────────────────────────────────────────────────────────┐
│                       장애 피라미드                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│                         ▲                                   │
│                        /│\     재해 (데이터센터 화재)        │
│                       / │ \    → 멀티 리전                  │
│                      /  │  \                                │
│                     /   │   \   하드웨어 장애 (서버 다운)     │
│                    /    │    \  → 이중화, 자동 복구         │
│                   /     │     \                             │
│                  /      │      \ 소프트웨어 버그             │
│                 /       │       \→ 테스트, 카나리 배포       │
│                /        │        \                          │
│               /         │         \ 네트워크 장애           │
│              /          │          \→ 타임아웃, 재시도      │
│             /           │           \                       │
│            /────────────┴────────────\                      │
│                  운영 실수 (가장 빈번)                       │
│                  → 자동화, 권한 관리                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**신뢰성 확보 기법:**

| 기법 | 설명 | 적용 예 |
|------|------|---------|
| **재시도** | 일시적 오류 복구 | 네트워크 타임아웃 |
| **서킷브레이커** | 장애 전파 차단 | 외부 API 장애 시 |
| **벌크헤드** | 장애 격리 | 기능별 스레드풀 분리 |
| **타임아웃** | 무한 대기 방지 | 모든 외부 호출 |
| **Fallback** | 대체 동작 | 캐시 데이터 반환 |
| **Rate Limiting** | 과부하 방지 | API 요청 제한 |

```
서킷브레이커 상태 전이:

    ┌─────────────────────────────────────────────────────┐
    │                                                     │
    │  ┌──────────┐   실패 임계치 초과   ┌──────────┐     │
    │  │  Closed  │ ───────────────────▶│   Open   │     │
    │  │ (정상)   │                     │ (차단)   │     │
    │  └──────────┘                     └────┬─────┘     │
    │       ▲                                │           │
    │       │                          타임아웃 후       │
    │       │                                │           │
    │       │         ┌──────────┐          │           │
    │       │  성공   │Half-Open │◀─────────┘           │
    │       └─────────│ (테스트) │                      │
    │                 └────┬─────┘                      │
    │                      │                            │
    │                    실패                           │
    │                      │                            │
    │                      └────────────────────────────┘
    │                              다시 Open으로         │
    └─────────────────────────────────────────────────────┘
```

---

### 6. 유지보수성 (Maintainability)

시스템을 쉽게 운영, 이해, 수정할 수 있는 것

```
유지보수성의 세 가지 측면:

┌─────────────────────────────────────────────────────────────┐
│                                                             │
│  운영성 (Operability)                                       │
│  ├── 모니터링: 시스템 상태 실시간 파악                       │
│  ├── 자동화: 배포, 스케일링, 복구 자동화                     │
│  └── 문서화: 운영 매뉴얼, 장애 대응 가이드                   │
│                                                             │
│  단순성 (Simplicity)                                        │
│  ├── 복잡성 제거: 불필요한 추상화 금지                       │
│  ├── 일관성: 코드 스타일, 아키텍처 패턴 통일                 │
│  └── 모듈화: 이해하기 쉬운 단위로 분리                       │
│                                                             │
│  진화성 (Evolvability)                                      │
│  ├── 느슨한 결합: 컴포넌트 간 의존성 최소화                  │
│  ├── API 버저닝: 하위 호환성 유지                           │
│  └── 테스트: 변경 시 회귀 방지                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**왜 중요한가?**
- 시스템 수명의 90%는 유지보수 기간
- 개발자 시간의 70%는 기존 코드 이해에 사용
- 장애 대응 시간은 유지보수성에 비례

---

## 설계 체크리스트

### 시스템 설계 시 질문할 것들

```
┌─────────────────────────────────────────────────────────────┐
│                     설계 체크리스트                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [규모 산정]                                                │
│  □ 예상 사용자 수는? (DAU, MAU)                             │
│  □ 피크 트래픽은 평균의 몇 배? (보통 2~10배)                 │
│  □ 읽기/쓰기 비율은? (보통 읽기가 10배 이상)                 │
│  □ 데이터 증가율은? (일/월/년 단위)                         │
│                                                             │
│  [가용성]                                                   │
│  □ 목표 가용성은? (99.9%? 99.99%?)                         │
│  □ 허용 가능한 다운타임은?                                  │
│  □ 단일 장애점(SPOF)은 모두 제거했나?                       │
│  □ 장애 복구 계획(DR)은 있나?                               │
│                                                             │
│  [일관성]                                                   │
│  □ 강한 일관성이 필요한 기능은?                             │
│  □ 최종 일관성으로 충분한 기능은?                           │
│  □ 일관성 위반 시 영향은? (돈? 사용자 경험?)                │
│                                                             │
│  [성능]                                                     │
│  □ 목표 응답시간은? (p50, p99)                              │
│  □ 캐싱 가능한 데이터는?                                    │
│  □ 비동기 처리 가능한 작업은?                               │
│                                                             │
│  [확장성]                                                   │
│  □ 수평 확장 가능한 구조인가?                               │
│  □ 상태 저장은 어디서 하나?                                 │
│  □ 병목 지점은 어디인가?                                    │
│                                                             │
│  [보안]                                                     │
│  □ 인증/인가는 어떻게 하나?                                 │
│  □ 민감 데이터 암호화는?                                    │
│  □ Rate Limiting은 적용했나?                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 규모별 아키텍처 진화

```
[단계 1] 단일 서버 (사용자 < 1,000)
┌──────────────────────────┐
│  Web + App + DB 한 서버   │
└──────────────────────────┘

[단계 2] 웹/DB 분리 (사용자 < 10,000)
┌──────────┐    ┌──────────┐
│   Web    │ →  │    DB    │
└──────────┘    └──────────┘

[단계 3] 캐시 추가 (사용자 < 100,000)
┌──────────┐    ┌──────────┐    ┌──────────┐
│   Web    │ →  │  Cache   │ →  │    DB    │
└──────────┘    └──────────┘    └──────────┘

[단계 4] 수평 확장 (사용자 < 1,000,000)
          ┌──────────┐
          │    LB    │
          └────┬─────┘
    ┌──────────┼──────────┐
    ▼          ▼          ▼
┌──────┐  ┌──────┐  ┌──────┐
│ Web1 │  │ Web2 │  │ Web3 │
└──────┘  └──────┘  └──────┘
    │          │          │
    └──────────┼──────────┘
               ▼
          ┌──────────┐
          │  Cache   │
          └────┬─────┘
               ▼
          ┌──────────┐
          │ DB Master│
          │ + Replica│
          └──────────┘

[단계 5] MSA + 메시지 큐 (사용자 > 1,000,000)
┌─────────────────────────────────────────────────────────────┐
│                        API Gateway                          │
└───────────────────────────┬─────────────────────────────────┘
                            │
    ┌───────────────────────┼───────────────────────┐
    ▼                       ▼                       ▼
┌──────────┐          ┌──────────┐          ┌──────────┐
│ User     │          │ Order    │          │ Product  │
│ Service  │          │ Service  │          │ Service  │
└────┬─────┘          └────┬─────┘          └────┬─────┘
     │                     │                     │
     └─────────────────────┼─────────────────────┘
                           │
                    ┌──────┴──────┐
                    ▼             ▼
              ┌──────────┐  ┌──────────┐
              │  Kafka   │  │  Redis   │
              └──────────┘  └──────────┘
```

---

## 트레이드오프 요약

| 선택 A | vs | 선택 B | 고려사항 |
|--------|----|---------|---------|
| 일관성 | ↔ | 가용성 | CAP: 네트워크 분할 시 양립 불가 |
| 지연시간 | ↔ | 처리량 | 배치 처리 vs 실시간 처리 |
| 정규화 | ↔ | 비정규화 | 쓰기 성능 vs 읽기 성능 |
| 동기 | ↔ | 비동기 | 단순함 vs 확장성 |
| 모놀리식 | ↔ | MSA | 단순함 vs 독립적 배포 |
| SQL | ↔ | NoSQL | 정합성/조인 vs 확장성/유연성 |
| 캐시 | ↔ | 캐시 없음 | 성능 vs 복잡성/정합성 |

---

## 면접 예상 질문

### Q: 대규모 시스템을 설계할 때 가장 먼저 고려하는 것은?

**A:** 요구사항 분석과 규모 산정입니다.

**구체적으로:**
1. **기능 요구사항**: 핵심 기능이 무엇인가?
2. **비기능 요구사항**: 가용성, 지연시간, 일관성 목표
3. **규모 산정**: DAU, QPS, 데이터 크기 추정

**왜 이것이 먼저인가?**
- 규모에 따라 아키텍처가 완전히 달라짐
- 오버 엔지니어링 방지 (소규모에 MSA는 낭비)
- 제약 조건에 따라 트레이드오프 결정

---

### Q: CAP 정리에서 실제로 어떤 선택을 하나요?

**A:** 분산 시스템에서 네트워크 분할(P)은 불가피하므로, 실질적으로 CP vs AP 선택입니다.

| 선택 | 예시 | 이유 |
|------|------|------|
| CP | 결제, 재고 | 데이터 오류가 비즈니스 손실 |
| AP | SNS, 추천 | 잠시 다른 데이터 보여도 괜찮음 |

**실제 시스템은?**
- 기능별로 다르게 선택 (결제는 CP, 피드는 AP)
- 대부분 최종 일관성 + 중요 기능만 강한 일관성

---

### Q: 99.99% 가용성을 달성하려면 어떻게 해야 하나요?

**A:** 연간 52분 다운타임만 허용되므로, 모든 레이어에서 이중화가 필수입니다.

**필수 요소:**
1. **다중 AZ 배포**: 데이터센터 장애 대비
2. **자동 페일오버**: 수동 개입 없이 복구
3. **헬스체크**: 장애 즉시 감지
4. **카나리 배포**: 배포로 인한 장애 최소화
5. **카오스 엔지니어링**: 장애 시뮬레이션으로 검증

**수식:**
```
전체 가용성 = 컴포넌트1 × 컴포넌트2 × ... × 컴포넌트N

예: 각 99.9% 컴포넌트가 3개 직렬
→ 0.999 × 0.999 × 0.999 = 99.7%

예: 99.9% 컴포넌트 2개를 이중화 (병렬)
→ 1 - (0.001 × 0.001) = 99.9999%
```

---

### Q: 캐시는 언제 사용하고 언제 사용하지 않나요?

**A:**

**사용하는 경우:**
- 읽기가 쓰기보다 훨씬 많을 때 (10:1 이상)
- 동일한 데이터가 반복 조회될 때
- 지연시간이 중요할 때

**사용하지 않는 경우:**
- 쓰기가 많고 데이터가 자주 변경될 때
- 강한 일관성이 필수일 때 (캐시 무효화 복잡)
- 데이터마다 조회 패턴이 다를 때 (캐시 히트율 낮음)

**캐시 전략 선택:**
| 전략 | 적합한 상황 |
|------|------------|
| Cache-Aside | 범용적, 읽기 중심 |
| Write-Through | 읽기 후 즉시 쓰기 |
| Write-Behind | 쓰기 성능 중요 |
| Refresh-Ahead | 예측 가능한 접근 패턴 |

---

### Q: 시스템이 느려졌을 때 어떻게 원인을 찾나요?

**A:** 계층별로 병목을 추적합니다.

```
사용자 요청
    │
    ▼
[1] 네트워크 ─── 지연? ─── CDN 확인, 네트워크 대역폭
    │
    ▼
[2] 로드밸런서 ─ 큐잉? ─── 서버 수 부족, 커넥션 풀
    │
    ▼
[3] 애플리케이션 ─ CPU? ── 비효율 로직, GC
    │
    ▼
[4] 캐시 ──────── Miss? ── 캐시 크기, 만료 정책
    │
    ▼
[5] 데이터베이스 ─ 슬로우? ─ 인덱스, 락 경합, 커넥션 풀
```

**도구:**
- APM: 전체 요청 흐름 추적 (Datadog, New Relic)
- 메트릭: CPU, 메모리, 디스크, 네트워크
- 로그: 에러, 슬로우 쿼리
- 프로파일링: 코드 레벨 병목

---

## 참고 자료

- Designing Data-Intensive Applications (Martin Kleppmann)
- System Design Interview (Alex Xu)
- [Google SRE Book](https://sre.google/sre-book/table-of-contents/)
- [AWS Well-Architected Framework](https://aws.amazon.com/architecture/well-architected/)
- [CAP Theorem - Brewer's Original Paper](https://users.ece.cmu.edu/~adrian/731-sp04/readings/GL-cap.pdf)
