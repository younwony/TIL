# 시스템 설계란 (What is System Design)

> `[1] 정의/기초` · 선수 지식: 없음

> 요구사항을 만족하는 소프트웨어 시스템의 아키텍처와 구성요소를 설계하는 과정

`#시스템설계` `#SystemDesign` `#아키텍처` `#Architecture` `#확장성` `#Scalability` `#가용성` `#Availability` `#성능` `#Performance` `#일관성` `#Consistency` `#분산시스템` `#DistributedSystem` `#로드밸런싱` `#LoadBalancing` `#캐싱` `#Caching` `#데이터베이스` `#Database` `#마이크로서비스` `#Microservices` `#CAP` `#트레이드오프` `#Tradeoff` `#면접`

## 왜 알아야 하는가?

시스템 설계는 소프트웨어 엔지니어의 핵심 역량입니다. 작은 서비스는 단순한 구조로 충분하지만, 사용자가 늘어나면 확장성, 가용성, 성능을 고려한 설계가 필수입니다. 시스템 설계 능력은 시니어 개발자로 성장하는 데 필수이며, 대기업 면접에서도 핵심적으로 평가합니다.

## 핵심 개념

- **확장성 (Scalability)**: 부하 증가에 대응하는 능력
- **가용성 (Availability)**: 시스템이 정상 작동하는 시간 비율
- **성능 (Performance)**: 응답 시간, 처리량
- **일관성 (Consistency)**: 모든 노드가 같은 데이터를 보는 것
- **트레이드오프**: 모든 것을 완벽하게 할 수 없음, 선택과 집중

## 쉽게 이해하기

**시스템 설계**를 도시 설계에 비유할 수 있습니다.

- **확장성**: 인구가 늘어나도 도로가 막히지 않게 설계
- **가용성**: 정전이 나도 병원은 계속 운영
- **성능**: 출퇴근 시간에도 빠르게 이동
- **일관성**: 모든 구청에서 같은 주민 정보 조회
- **트레이드오프**: 예산 한도 내에서 우선순위 결정

## 상세 설명

### 시스템 설계의 목표

```
┌─────────────────────────────────────────────────────────────┐
│                    좋은 시스템 설계                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│   │   확장성    │  │   가용성    │  │    성능     │        │
│   │ Scalability │  │ Availability│  │ Performance │        │
│   └─────────────┘  └─────────────┘  └─────────────┘        │
│                                                              │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│   │   일관성    │  │   보안성    │  │  유지보수성  │        │
│   │ Consistency │  │  Security   │  │Maintainability│      │
│   └─────────────┘  └─────────────┘  └─────────────┘        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 확장성 (Scalability)

#### 수직 확장 (Scale Up)

```
Before:           After:
┌─────────┐       ┌─────────────┐
│ 서버 1개 │  →    │  더 큰 서버  │
│ 4GB RAM │       │  64GB RAM   │
│ 4 Core  │       │  32 Core    │
└─────────┘       └─────────────┘
```

**장점**: 간단, 코드 변경 없음
**단점**: 한계 존재, 단일 장애점

#### 수평 확장 (Scale Out)

```
Before:           After:
┌─────────┐       ┌─────────┐ ┌─────────┐ ┌─────────┐
│ 서버 1개 │  →    │ 서버 1  │ │ 서버 2  │ │ 서버 3  │
└─────────┘       └─────────┘ └─────────┘ └─────────┘
                         │         │         │
                         └────┬────┴────┬────┘
                              │         │
                        ┌─────┴─────────┴─────┐
                        │    로드 밸런서       │
                        └─────────────────────┘
```

**장점**: 무한 확장 가능, 고가용성
**단점**: 복잡도 증가, 데이터 동기화 필요

### 가용성 (Availability)

**정의**: 시스템이 정상 작동하는 시간의 비율

| 가용성 | 연간 다운타임 | 서비스 예시 |
|--------|-------------|-------------|
| 99% | 3.65일 | 내부 시스템 |
| 99.9% | 8.76시간 | 일반 웹 서비스 |
| 99.99% | 52.56분 | 금융, 의료 |
| 99.999% | 5.26분 | AWS, Google |

**고가용성 달성 방법**:
- 이중화 (Redundancy)
- 장애 조치 (Failover)
- 헬스 체크 (Health Check)
- 자동 복구 (Auto Recovery)

### 성능 지표

| 지표 | 설명 | 목표 |
|------|------|------|
| **응답 시간 (Latency)** | 요청~응답까지 시간 | 낮을수록 좋음 |
| **처리량 (Throughput)** | 단위 시간당 처리 요청 수 | 높을수록 좋음 |
| **동시 사용자 (Concurrency)** | 동시에 처리 가능한 요청 수 | 높을수록 좋음 |

### 핵심 구성요소

#### 1. 로드 밸런서 (Load Balancer)

```
                    ┌─────────────┐
                    │ 로드 밸런서  │
                    └──────┬──────┘
              ┌───────────┬┴───────────┐
              ▼           ▼            ▼
        ┌─────────┐ ┌─────────┐ ┌─────────┐
        │ 서버 1  │ │ 서버 2  │ │ 서버 3  │
        └─────────┘ └─────────┘ └─────────┘
```

**알고리즘**:
- Round Robin: 순차 분배
- Least Connections: 연결 적은 서버로
- IP Hash: 같은 IP는 같은 서버로

#### 2. 캐시 (Cache)

```
클라이언트 → 캐시 → (캐시 히트) → 응답
              ↓
         (캐시 미스)
              ↓
           데이터베이스 → 캐시 저장 → 응답
```

**전략**:
- Cache-Aside: 애플리케이션이 캐시 관리
- Write-Through: 쓰기 시 캐시와 DB 동시 업데이트
- Write-Behind: 캐시만 업데이트, 나중에 DB 반영

#### 3. 데이터베이스

**읽기 복제 (Read Replica)**:
```
        ┌─────────────┐
        │   Master    │ ← 쓰기
        │    (DB)     │
        └──────┬──────┘
               │ 복제
    ┌──────────┼──────────┐
    ▼          ▼          ▼
┌───────┐ ┌───────┐ ┌───────┐
│Replica│ │Replica│ │Replica│ ← 읽기
└───────┘ └───────┘ └───────┘
```

**샤딩 (Sharding)**:
```
사용자 ID로 샤드 결정:
- ID 1~1000: 샤드 1
- ID 1001~2000: 샤드 2
- ID 2001~3000: 샤드 3
```

#### 4. 메시지 큐 (Message Queue)

```
Producer → [Message Queue] → Consumer

비동기 처리, 부하 분산, 서비스 분리
예: Kafka, RabbitMQ, SQS
```

### CAP 정리

**분산 시스템에서 세 가지를 동시에 만족할 수 없음**:

```
         Consistency
              /\
             /  \
            /    \
           / CAP  \
          /________\
   Availability  Partition
                 Tolerance
```

| 선택 | 포기 | 예시 |
|------|------|------|
| CA | 파티션 내성 | 단일 서버 RDBMS |
| CP | 가용성 | MongoDB, HBase |
| AP | 일관성 | Cassandra, DynamoDB |

### 시스템 설계 접근법

#### 1. 요구사항 명확화

```
기능적 요구사항:
- 사용자 등록/로그인
- 게시글 작성/조회
- 검색

비기능적 요구사항:
- DAU: 100만
- 응답 시간: 200ms 이내
- 가용성: 99.9%
```

#### 2. 규모 추정 (Back-of-the-envelope)

```
DAU: 1,000,000
피크 배수: 3배
초당 요청: 1,000,000 / 86,400 * 3 ≈ 35 QPS

저장 용량:
- 일일 게시글: 100,000개
- 게시글당: 10KB
- 일일: 1GB → 연간: 365GB
```

#### 3. 고수준 설계

```
┌─────────┐    ┌─────────────┐    ┌─────────────┐
│ 클라이언트│───►│ 로드밸런서  │───►│   API 서버  │
└─────────┘    └─────────────┘    └──────┬──────┘
                                         │
                    ┌────────────────────┼────────────────────┐
                    │                    │                    │
              ┌─────▼─────┐       ┌──────▼──────┐     ┌──────▼──────┐
              │   캐시    │       │  데이터베이스 │     │  메시지 큐  │
              │  (Redis)  │       │   (MySQL)   │     │  (Kafka)   │
              └───────────┘       └─────────────┘     └─────────────┘
```

#### 4. 상세 설계

각 컴포넌트의 구체적 설계:
- 데이터 모델
- API 설계
- 알고리즘
- 장애 처리

## 트레이드오프

| 항목 | 트레이드오프 |
|------|-------------|
| 일관성 vs 가용성 | CAP 정리 |
| 성능 vs 비용 | 더 많은 서버 = 더 빠름 = 더 비쌈 |
| 단순성 vs 확장성 | 단순한 설계는 확장이 어려움 |
| 속도 vs 정확성 | 실시간 vs 배치 처리 |

## 면접 예상 질문

### Q: 시스템 설계에서 가장 중요한 것은?

A: **요구사항 파악**이 가장 중요합니다. 기능적 요구사항(무엇을 해야 하는가)과 비기능적 요구사항(얼마나 빠르게, 얼마나 많이)을 명확히 해야 합니다. **왜냐하면** 요구사항에 따라 설계가 완전히 달라지기 때문입니다. 예: DAU 100명 vs 1억 명은 전혀 다른 아키텍처가 필요합니다.

### Q: 수직 확장과 수평 확장의 차이는?

A: **수직 확장(Scale Up)**은 서버 사양을 높이는 것(CPU, RAM 추가)이고, **수평 확장(Scale Out)**은 서버 수를 늘리는 것입니다. **트레이드오프**: 수직 확장은 간단하지만 한계가 있고 단일 장애점이 됩니다. 수평 확장은 무한 확장 가능하지만 데이터 동기화, 세션 관리 등 복잡도가 증가합니다. **실무에서는** 초기에 수직 확장으로 시작하고, 한계에 다다르면 수평 확장으로 전환합니다.

### Q: CAP 정리를 설명해주세요.

A: 분산 시스템에서 **Consistency(일관성)**, **Availability(가용성)**, **Partition Tolerance(파티션 내성)** 세 가지를 동시에 만족할 수 없다는 정리입니다. 네트워크 파티션(장애)은 피할 수 없으므로 실제로는 **CP**(일관성 우선, 가용성 포기)와 **AP**(가용성 우선, 일관성 포기) 중 선택합니다. **예시**: 금융 시스템은 CP(잔액 일관성), SNS 피드는 AP(가용성 우선, 약간의 지연 허용).

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [Rate Limiting](./rate-limiting.md) | 트래픽 제어 | [3] 중급 |
| [분산 트랜잭션](./distributed-transaction.md) | 데이터 일관성 | [4] 심화 |
| [MSA vs 모놀리식](./msa-vs-monolithic.md) | 아키텍처 선택 | [3] 중급 |

## 참고 자료

- System Design Interview - Alex Xu
- Designing Data-Intensive Applications - Martin Kleppmann
- [System Design Primer](https://github.com/donnemartin/system-design-primer)
