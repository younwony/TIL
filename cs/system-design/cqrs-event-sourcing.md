# CQRS & 이벤트 소싱 (CQRS & Event Sourcing)

> `[4] 심화` · 선수 지식: [시스템 설계란](./what-is-system-design.md), [분산 트랜잭션](./distributed-transaction.md)

> 명령과 조회를 분리하고, 상태 변경을 이벤트로 기록하는 아키텍처 패턴

`#CQRS` `#CommandQueryResponsibilitySegregation` `#이벤트소싱` `#EventSourcing` `#명령조회분리` `#이벤트스토어` `#EventStore` `#프로젝션` `#Projection` `#이벤트드리븐` `#EventDriven` `#DDD` `#도메인주도설계` `#읽기모델` `#ReadModel` `#쓰기모델` `#WriteModel` `#최종일관성` `#EventualConsistency`

## 왜 알아야 하는가?

복잡한 도메인에서 읽기와 쓰기의 요구사항이 다를 때 CQRS가 유용합니다. 이벤트 소싱은 모든 변경 이력을 보존하여 감사, 디버깅, 시간 여행을 가능하게 합니다. 금융, 의료 등 이력이 중요한 도메인에서 자주 사용됩니다.

## 핵심 개념

- **CQRS**: Command(쓰기)와 Query(읽기)를 분리
- **이벤트 소싱**: 상태를 이벤트의 시퀀스로 저장
- **이벤트 스토어**: 이벤트를 저장하는 전용 저장소
- **프로젝션**: 이벤트를 읽기 모델로 변환

## 쉽게 이해하기

**CQRS**: 은행에서 입출금(Command)과 잔액조회(Query)를 다른 창구에서 처리

**이벤트 소싱**: 통장에 현재 잔액만 적는 게 아니라, 모든 입출금 내역을 기록
- 전통적: 잔액 = 10,000원
- 이벤트 소싱: 입금 5,000원 → 출금 2,000원 → 입금 7,000원 (재생하면 10,000원)

## 상세 설명

### CQRS (Command Query Responsibility Segregation)

```
              ┌─────────────────────────────────────────┐
              │              클라이언트                  │
              └──────────────────┬──────────────────────┘
                                 │
              ┌──────────────────┴──────────────────┐
              │                                     │
        ┌─────▼─────┐                        ┌──────▼─────┐
        │  Command  │                        │   Query    │
        │  (쓰기)   │                        │  (읽기)    │
        └─────┬─────┘                        └──────┬─────┘
              │                                     │
        ┌─────▼─────┐                        ┌──────▼─────┐
        │ Write DB  │  ─── 동기화 ────────►  │  Read DB   │
        │ (정규화)  │                        │ (비정규화) │
        └───────────┘                        └────────────┘
```

**왜 분리하는가?**
- 읽기와 쓰기의 요구사항이 다름
- 쓰기: 정규화, 무결성, 트랜잭션
- 읽기: 비정규화, 빠른 조회, 캐싱

### 이벤트 소싱 (Event Sourcing)

**전통적 방식 (상태 저장)**:
```
┌──────────────────────────────┐
│ accounts 테이블              │
│ id: 1, balance: 10000        │
└──────────────────────────────┘
```

**이벤트 소싱 (이벤트 저장)**:
```
┌──────────────────────────────────────────────────────┐
│ events 테이블                                        │
│ 1. AccountCreated { id: 1 }                         │
│ 2. MoneyDeposited { id: 1, amount: 5000 }           │
│ 3. MoneyWithdrawn { id: 1, amount: 2000 }           │
│ 4. MoneyDeposited { id: 1, amount: 7000 }           │
└──────────────────────────────────────────────────────┘

현재 상태 = 이벤트 재생: 0 + 5000 - 2000 + 7000 = 10000
```

**장점**:
- 모든 변경 이력 보존
- 감사 로그 자동
- 과거 상태 재현 가능 (시간 여행)
- 디버깅 용이

**단점**:
- 복잡도 증가
- 이벤트 스키마 변경 어려움
- 현재 상태 조회 비효율 (프로젝션 필요)

### CQRS + 이벤트 소싱

```
┌─────────────────────────────────────────────────────────────┐
│                        Command Side                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Command ──► Command Handler ──► Aggregate ──► Event Store  │
│                                      │                       │
│                              이벤트 발행                      │
│                                      │                       │
└──────────────────────────────────────┼───────────────────────┘
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────┐
│                         Query Side                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  이벤트 구독 ──► Projection ──► Read DB ──► Query Handler   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 프로젝션 (Projection)

이벤트를 읽기 모델로 변환:

```java
// 이벤트 핸들러 (프로젝션)
@EventHandler
public void on(AccountCreated event) {
    accountView.insert(event.getAccountId(), 0);
}

@EventHandler
public void on(MoneyDeposited event) {
    accountView.addBalance(event.getAccountId(), event.getAmount());
}

@EventHandler
public void on(MoneyWithdrawn event) {
    accountView.subtractBalance(event.getAccountId(), event.getAmount());
}
```

## 트레이드오프

| 항목 | 전통적 | CQRS + ES |
|------|--------|-----------|
| 복잡도 | 낮음 | 높음 |
| 이력 관리 | 별도 구현 | 자동 |
| 읽기 성능 | 중간 | 높음 (최적화된 읽기 모델) |
| 일관성 | 즉시 | 최종 일관성 |
| 적합한 도메인 | 단순 CRUD | 복잡한 비즈니스 로직 |

## 면접 예상 질문

### Q: CQRS가 무엇이고 언제 사용하나요?

A: **CQRS**는 Command(쓰기)와 Query(읽기)를 분리하는 패턴입니다. **사용 시점**: (1) 읽기/쓰기 요구사항이 매우 다를 때 (2) 읽기 성능 최적화 필요 (3) 복잡한 도메인 로직. **트레이드오프**: 복잡도가 증가하고 최종 일관성을 수용해야 합니다. 단순 CRUD 애플리케이션에는 과도한 엔지니어링입니다.

### Q: 이벤트 소싱의 장단점은?

A: **장점**: (1) 모든 변경 이력 자동 보존 (2) 감사/디버깅 용이 (3) 과거 상태 재현 가능 (4) 이벤트 기반 통합 자연스러움. **단점**: (1) 복잡도 증가 (2) 이벤트 스키마 변경 어려움 (3) 현재 상태 조회 위해 프로젝션 필요 (4) 최종 일관성 수용 필요. **적합**: 금융, 의료 등 이력이 중요한 도메인.

## 연관 문서

| 문서 | 연관성 | 난이도 |
|------|--------|--------|
| [분산 트랜잭션](./distributed-transaction.md) | Saga 패턴 | [4] 심화 |
| [DDD](../programming/ddd.md) | 도메인 모델링 | [4] 심화 |

## 참고 자료

- [Martin Fowler - CQRS](https://martinfowler.com/bliki/CQRS.html)
- [Event Sourcing Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing)
